/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-utils";
exports.ids = ["vendor-chunks/troika-three-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.umd.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\")) :\n  0;\n}(this, (function (exports, three) { 'use strict';\n\n  /**\n   * Regular expression for matching the `void main() {` opener line in GLSL.\n   * @type {RegExp}\n   */\n  const voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n  /**\n   * Recursively expands all `#include <xyz>` statements within string of shader code.\n   * Copied from three's WebGLProgram#parseIncludes for external use.\n   *\n   * @param {string} source - The GLSL source code to evaluate\n   * @return {string} The GLSL code with all includes expanded\n   */\n  function expandShaderIncludes( source ) {\n    const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function replace(match, include) {\n      let chunk = three.ShaderChunk[include];\n      return chunk ? expandShaderIncludes(chunk) : match\n    }\n    return source.replace( pattern, replace )\n  }\n\n  /*\n   * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n   * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n   * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n   */\n\n  const _lut = [];\n\n  for (let i = 0; i < 256; i++) {\n    _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n  }\n\n  function generateUUID() {\n\n    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n    const d0 = Math.random() * 0xffffffff | 0;\n    const d1 = Math.random() * 0xffffffff | 0;\n    const d2 = Math.random() * 0xffffffff | 0;\n    const d3 = Math.random() * 0xffffffff | 0;\n    const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n      _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n      _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n      _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n    // .toUpperCase() here flattens concatenated strings to save heap memory space.\n    return uuid.toUpperCase()\n\n  }\n\n  // Local assign polyfill to avoid importing troika-core\n  const assign = Object.assign || function(/*target, ...sources*/) {\n    let target = arguments[0];\n    for (let i = 1, len = arguments.length; i < len; i++) {\n      let source = arguments[i];\n      if (source) {\n        for (let prop in source) {\n          if (Object.prototype.hasOwnProperty.call(source, prop)) {\n            target[prop] = source[prop];\n          }\n        }\n      }\n    }\n    return target\n  };\n\n\n  const epoch = Date.now();\n  const CONSTRUCTOR_CACHE = new WeakMap();\n  const SHADER_UPGRADE_CACHE = new Map();\n\n  // Material ids must be integers, but we can't access the increment from Three's `Material` module,\n  // so let's choose a sufficiently large starting value that should theoretically never collide.\n  let materialInstanceId = 1e10;\n\n  /**\n   * A utility for creating a custom shader material derived from another material's\n   * shaders. This allows you to inject custom shader logic and transforms into the\n   * builtin ThreeJS materials without having to recreate them from scratch.\n   *\n   * @param {THREE.Material} baseMaterial - the original material to derive from\n   *\n   * @param {Object} options - How the base material should be modified.\n   * @param {Object} options.defines - Custom `defines` for the material\n   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n   *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n   *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n   *        both shaders, and it will automatically be updated on each render frame with a number of\n   *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n   *        true calendar time.\n   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n   *        those attributes exposed by their normal names as read/write values.\n   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n   *        shader's `void main` function.\n   * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n   *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n   *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n   *        want those to apply to your changes use `fragmentColorTransform` instead.\n   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n   *        output value. Will be injected near the end of the `void main` function, but before any\n   *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n   *        `fragmentMainOutro`.\n   * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n   *        for performing custom rewrites of the full shader code. Useful if you need to do something\n   *        special that's not covered by the other builtin options. This function will be executed before\n   *        any other transforms are applied.\n   * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n   *        material, rather than the default behavior of copying it. This allows the derived material to\n   *        automatically pick up changes made to the base material and its properties. This can be useful\n   *        where the derived material is hidden from the user as an implementation detail, allowing them\n   *        to work with the original material like normal. But it can result in unexpected behavior if not\n   *        handled carefully.\n   *\n   * @return {THREE.Material}\n   *\n   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n   * which can be called to get a variant of the derived material for use in shadow casting. If the\n   * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n   * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n   * scenarios, e.g. skipping antialiasing or expensive shader logic.\n   */\n  function createDerivedMaterial(baseMaterial, options) {\n    // Generate a key that is unique to the content of these `options`. We'll use this\n    // throughout for caching and for generating the upgraded shader code. This increases\n    // the likelihood that the resulting shaders will line up across multiple calls so\n    // their GL programs can be shared and cached.\n    const optionsKey = getKeyForOptions(options);\n\n    // First check to see if we've already derived from this baseMaterial using this\n    // unique set of options, and if so reuse the constructor to avoid some allocations.\n    let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n    if (!ctorsByDerivation) {\n      CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n    }\n    if (ctorsByDerivation[optionsKey]) {\n      return new ctorsByDerivation[optionsKey]()\n    }\n\n    const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n    // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material's program\n    const onBeforeCompile = function (shaderInfo, renderer) {\n      baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n      // Upgrade the shaders, caching the result by incoming source code\n      const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n      let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n      if (!upgradedShaders) {\n        const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n        upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n      }\n\n      // Inject upgraded shaders and uniforms into the program\n      shaderInfo.vertexShader = upgradedShaders.vertexShader;\n      shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n      assign(shaderInfo.uniforms, this.uniforms);\n\n      // Inject auto-updating time uniform if requested\n      if (options.timeUniform) {\n        shaderInfo.uniforms[options.timeUniform] = {\n          get value() {return Date.now() - epoch}\n        };\n      }\n\n      // Users can still add their own handlers on top of ours\n      if (this[privateBeforeCompileProp]) {\n        this[privateBeforeCompileProp](shaderInfo);\n      }\n    };\n\n    const DerivedMaterial = function DerivedMaterial() {\n      return derive(options.chained ? baseMaterial : baseMaterial.clone())\n    };\n\n    const derive = function(base) {\n      // Prototype chain to the base material\n      const derived = Object.create(base, descriptor);\n\n      // Store the baseMaterial for reference; this is always the original even when cloning\n      Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n      // Needs its own ids\n      Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n      derived.uuid = generateUUID();\n\n      // Merge uniforms, defines, and extensions\n      derived.uniforms = assign({}, base.uniforms, options.uniforms);\n      derived.defines = assign({}, base.defines, options.defines);\n      derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n      derived.extensions = assign({}, base.extensions, options.extensions);\n\n      // Don't inherit EventDispatcher listeners\n      derived._listeners = undefined;\n\n      return derived\n    };\n\n    const descriptor = {\n      constructor: {value: DerivedMaterial},\n      isDerivedMaterial: {value: true},\n\n      customProgramCacheKey: {\n        writable: true,\n        configurable: true,\n        value: function () {\n          return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n        }\n      },\n\n      onBeforeCompile: {\n        get() {\n          return onBeforeCompile\n        },\n        set(fn) {\n          this[privateBeforeCompileProp] = fn;\n        }\n      },\n\n      copy: {\n        writable: true,\n        configurable: true,\n        value: function (source) {\n          baseMaterial.copy.call(this, source);\n          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n            assign(this.extensions, source.extensions);\n            assign(this.defines, source.defines);\n            assign(this.uniforms, three.UniformsUtils.clone(source.uniforms));\n          }\n          return this\n        }\n      },\n\n      clone: {\n        writable: true,\n        configurable: true,\n        value: function () {\n          const newBase = new baseMaterial.constructor();\n          return derive(newBase).copy(this)\n        }\n      },\n\n      /**\n       * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDepthMaterial: {\n        writable: true,\n        configurable: true,\n        value: function() {\n          let depthMaterial = this._depthMaterial;\n          if (!depthMaterial) {\n            depthMaterial = this._depthMaterial = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDepthMaterial()\n                : new three.MeshDepthMaterial({ depthPacking: three.RGBADepthPacking }),\n              options\n            );\n            depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n            depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n          }\n          return depthMaterial\n        }\n      },\n\n      /**\n       * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDistanceMaterial: {\n        writable: true,\n        configurable: true,\n        value: function() {\n          let distanceMaterial = this._distanceMaterial;\n          if (!distanceMaterial) {\n            distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDistanceMaterial()\n                : new three.MeshDistanceMaterial(),\n              options\n            );\n            distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n            distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n          }\n          return distanceMaterial\n        }\n      },\n\n      dispose: {\n        writable: true,\n        configurable: true,\n        value() {\n          const {_depthMaterial, _distanceMaterial} = this;\n          if (_depthMaterial) _depthMaterial.dispose();\n          if (_distanceMaterial) _distanceMaterial.dispose();\n          baseMaterial.dispose.call(this);\n        }\n      }\n    };\n\n    ctorsByDerivation[optionsKey] = DerivedMaterial;\n    return new DerivedMaterial()\n  }\n\n\n  function upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n    let {\n      vertexDefs,\n      vertexMainIntro,\n      vertexMainOutro,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro,\n      fragmentMainOutro,\n      fragmentColorTransform,\n      customRewriter,\n      timeUniform\n    } = options;\n\n    vertexDefs = vertexDefs || '';\n    vertexMainIntro = vertexMainIntro || '';\n    vertexMainOutro = vertexMainOutro || '';\n    fragmentDefs = fragmentDefs || '';\n    fragmentMainIntro = fragmentMainIntro || '';\n    fragmentMainOutro = fragmentMainOutro || '';\n\n    // Expand includes if needed\n    if (vertexTransform || customRewriter) {\n      vertexShader = expandShaderIncludes(vertexShader);\n    }\n    if (fragmentColorTransform || customRewriter) {\n      // We need to be able to find postprocessing chunks after include expansion in order to\n      // put them after the fragmentColorTransform, so mark them with comments first. Even if\n      // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n      // so we still mark them.\n      fragmentShader = fragmentShader.replace(\n        /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n        '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n      );\n      fragmentShader = expandShaderIncludes(fragmentShader);\n    }\n\n    // Apply custom rewriter function\n    if (customRewriter) {\n      let res = customRewriter({vertexShader, fragmentShader});\n      vertexShader = res.vertexShader;\n      fragmentShader = res.fragmentShader;\n    }\n\n    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n    // those and re-insert them into the outro in the correct place:\n    if (fragmentColorTransform) {\n      let postChunks = [];\n      fragmentShader = fragmentShader.replace(\n        /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n        match => {\n          postChunks.push(match);\n          return ''\n        }\n      );\n      fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n    }\n\n    // Inject auto-updating time uniform if requested\n    if (timeUniform) {\n      const code = `\\nuniform float ${timeUniform};\\n`;\n      vertexDefs = code + vertexDefs;\n      fragmentDefs = code + fragmentDefs;\n    }\n\n    // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n    if (vertexTransform) {\n      // Hoist these defs to the very top so they work in other function defs\n      vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n      vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n      vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n      vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n        return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n      });\n\n      // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n      // Perhaps the other textures too going forward?\n      if (!(material.map && material.map.channel > 0)) {\n        vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n      }\n    }\n\n    // Inject defs and intro/outro snippets\n    vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n    fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n    return {\n      vertexShader,\n      fragmentShader\n    }\n  }\n\n  function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n    if (intro || outro || defs) {\n      shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n      );\n      shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n    }\n    return shaderCode\n  }\n\n\n  function optionsJsonReplacer(key, value) {\n    return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n  }\n\n  let _idCtr = 0;\n  const optionsHashesToIds = new Map();\n  function getKeyForOptions(options) {\n    const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n    let id = optionsHashesToIds.get(optionsHash);\n    if (id == null) {\n      optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n    }\n    return id\n  }\n\n  // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n  // TODO how can we keep this from getting stale?\n  const MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'toon',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite'\n  };\n\n  /**\n   * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n   * used to render that material.\n   *\n   * @param material - the Material instance\n   * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n   */\n  function getShadersForMaterial(material) {\n    let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n  }\n\n  /**\n   * Find all uniforms and their types within a shader code string.\n   *\n   * @param {string} shader - The shader code to parse\n   * @return {object} mapping of uniform names to their glsl type\n   */\n  function getShaderUniformTypes(shader) {\n    let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n    let uniforms = Object.create(null);\n    let match;\n    while ((match = uniformRE.exec(shader)) !== null) {\n      uniforms[match[2]] = match[1];\n    }\n    return uniforms\n  }\n\n  /**\n   * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n   * that happened in ThreeJS r123.\n   * @param {Matrix4} srcMatrix\n   * @param {Matrix4} [tgtMatrix]\n   */\n  function invertMatrix4(srcMatrix, tgtMatrix = new three.Matrix4()) {\n    if (typeof tgtMatrix.invert === 'function') {\n      tgtMatrix.copy(srcMatrix).invert();\n    } else {\n      tgtMatrix.getInverse(srcMatrix);\n    }\n    return tgtMatrix\n  }\n\n  /*\n  Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,\n  divided into a reasonable number of height segments.\n  */\n\n  const vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\n  const vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\n  const fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\n  const fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n  // Debugging: separate color for each of the 6 sides:\n  // const fragmentColorTransform = `\n  // float sideNum = floor(vUV.x * 6.0);\n  // vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n  //   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n  //   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n  //   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n  //   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n  //   vec3(1.0, 0.0, 1.0);\n  // gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n  // `\n\n\n\n  function createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(\n      baseMaterial,\n      {\n        chained: true,\n        uniforms: {\n          pointA: {value: new three.Vector3()},\n          controlA: {value: new three.Vector3()},\n          controlB: {value: new three.Vector3()},\n          pointB: {value: new three.Vector3()},\n          radius: {value: 0.01},\n          dashing: {value: new three.Vector3()} //on, off, offset\n        },\n        vertexDefs,\n        vertexTransform,\n        fragmentDefs,\n        fragmentMainIntro\n      }\n    )\n  }\n\n  let geometry = null;\n\n  const defaultBaseMaterial = /*#__PURE__*/new three.MeshStandardMaterial({color: 0xffffff, side: three.DoubleSide});\n\n\n  /**\n   * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n   * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n   * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n   * automatically.\n   *\n   * The cubiz bezier path is determined by its four `Vector3` properties:\n   * - `pointA`\n   * - `controlA`\n   * - `controlB`\n   * - `pointB`\n   *\n   * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n   *\n   * You can also give the tube a dashed appearance with two properties:\n   *\n   * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n   *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n   *   used as input to the cubic bezier function, not its visible length.)\n   * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n   *\n   * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n   * thicker tubes.\n   *\n   * TODO: proper geometry bounding sphere and raycasting\n   * TODO: allow control of the geometry's segment counts\n   */\n  class BezierMesh extends three.Mesh {\n    static getGeometry() {\n      return geometry || (geometry =\n        new three.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n      )\n    }\n\n    constructor() {\n      super(\n        BezierMesh.getGeometry(),\n        defaultBaseMaterial\n      );\n\n      this.pointA = new three.Vector3();\n      this.controlA = new three.Vector3();\n      this.controlB = new three.Vector3();\n      this.pointB = new three.Vector3();\n      this.radius = 0.01;\n      this.dashArray = new three.Vector2();\n      this.dashOffset = 0;\n\n      // TODO - disabling frustum culling until I figure out how to customize the\n      //  geometry's bounding sphere that gets used\n      this.frustumCulled = false;\n    }\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    get material() {\n      let derivedMaterial = this._derivedMaterial;\n      const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial\n    }\n    set material(baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    }\n\n    // Create and update material for shadows upon request:\n    get customDepthMaterial() {\n      return this.material.getDepthMaterial()\n    }\n    get customDistanceMaterial() {\n      return this.material.getDistanceMaterial()\n    }\n\n    onBeforeRender() {\n      const {uniforms} = this.material;\n      const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    }\n\n    raycast(/*raycaster, intersects*/) {\n      // TODO - just fail for now\n    }\n  }\n\n  exports.BezierMesh = BezierMesh;\n  exports.createDerivedMaterial = createDerivedMaterial;\n  exports.expandShaderIncludes = expandShaderIncludes;\n  exports.getShaderUniformTypes = getShaderUniformTypes;\n  exports.getShadersForMaterial = getShadersForMaterial;\n  exports.invertMatrix4 = invertMatrix4;\n  exports.voidMainRegExp = voidMainRegExp;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLnVtZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMseURBQU87QUFDakcsRUFBRSxDQUNpSTtBQUNuSSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQSx1REFBdUQ7QUFDdkQsWUFBWTtBQUNaO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUSxrRUFBa0Usa0JBQWtCO0FBQ3pHLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FB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Q2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLnVtZC5qcz8xNWM1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgndGhyZWUnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3RocmVlJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwudHJvaWthX3RocmVlX3V0aWxzID0ge30sIGdsb2JhbC5USFJFRSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIHRocmVlKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyB0aGUgYHZvaWQgbWFpbigpIHtgIG9wZW5lciBsaW5lIGluIEdMU0wuXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICBjb25zdCB2b2lkTWFpblJlZ0V4cCA9IC9cXGJ2b2lkXFxzK21haW5cXHMqXFwoXFxzKlxcKVxccyp7L2c7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGV4cGFuZHMgYWxsIGAjaW5jbHVkZSA8eHl6PmAgc3RhdGVtZW50cyB3aXRoaW4gc3RyaW5nIG9mIHNoYWRlciBjb2RlLlxuICAgKiBDb3BpZWQgZnJvbSB0aHJlZSdzIFdlYkdMUHJvZ3JhbSNwYXJzZUluY2x1ZGVzIGZvciBleHRlcm5hbCB1c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgR0xTTCBzb3VyY2UgY29kZSB0byBldmFsdWF0ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBHTFNMIGNvZGUgd2l0aCBhbGwgaW5jbHVkZXMgZXhwYW5kZWRcbiAgICovXG4gIGZ1bmN0aW9uIGV4cGFuZFNoYWRlckluY2x1ZGVzKCBzb3VyY2UgKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IC9eWyBcXHRdKiNpbmNsdWRlICs8KFtcXHdcXGQuL10rKT4vZ207XG4gICAgZnVuY3Rpb24gcmVwbGFjZShtYXRjaCwgaW5jbHVkZSkge1xuICAgICAgbGV0IGNodW5rID0gdGhyZWUuU2hhZGVyQ2h1bmtbaW5jbHVkZV07XG4gICAgICByZXR1cm4gY2h1bmsgPyBleHBhbmRTaGFkZXJJbmNsdWRlcyhjaHVuaykgOiBtYXRjaFxuICAgIH1cbiAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2UgKVxuICB9XG5cbiAgLypcbiAgICogVGhpcyBpcyBhIGRpcmVjdCBjb3B5IG9mIE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQgZnJvbSBUaHJlZS5qcywgdG8gcHJlc2VydmUgY29tcGF0aWJpbGl0eSB3aXRoIHRocmVlXG4gICAqIHZlcnNpb25zIGJlZm9yZSAwLjExMy4wIGFzIGl0IHdhcyBjaGFuZ2VkIGZyb20gTWF0aCB0byBNYXRoVXRpbHMgaW4gdGhhdCB2ZXJzaW9uLlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvZGQ4YjVhYTNiMjcwYzE3MDk2YjkwOTQ1Y2QyZDZkMWIxM2FhZWM1My9zcmMvbWF0aC9NYXRoVXRpbHMuanMjTDE2XG4gICAqL1xuXG4gIGNvbnN0IF9sdXQgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX2x1dFtpXSA9IChpIDwgMTYgPyAnMCcgOiAnJykgKyAoaSkudG9TdHJpbmcoMTYpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5cbiAgICBjb25zdCBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgICBjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgICBjb25zdCBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgICBjb25zdCBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgICBjb25zdCB1dWlkID0gX2x1dFtkMCAmIDB4ZmZdICsgX2x1dFtkMCA+PiA4ICYgMHhmZl0gKyBfbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QwID4+IDI0ICYgMHhmZl0gKyAnLScgK1xuICAgICAgX2x1dFtkMSAmIDB4ZmZdICsgX2x1dFtkMSA+PiA4ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QxID4+IDE2ICYgMHgwZiB8IDB4NDBdICsgX2x1dFtkMSA+PiAyNCAmIDB4ZmZdICsgJy0nICtcbiAgICAgIF9sdXRbZDIgJiAweDNmIHwgMHg4MF0gKyBfbHV0W2QyID4+IDggJiAweGZmXSArICctJyArIF9sdXRbZDIgPj4gMTYgJiAweGZmXSArIF9sdXRbZDIgPj4gMjQgJiAweGZmXSArXG4gICAgICBfbHV0W2QzICYgMHhmZl0gKyBfbHV0W2QzID4+IDggJiAweGZmXSArIF9sdXRbZDMgPj4gMTYgJiAweGZmXSArIF9sdXRbZDMgPj4gMjQgJiAweGZmXTtcblxuICAgIC8vIC50b1VwcGVyQ2FzZSgpIGhlcmUgZmxhdHRlbnMgY29uY2F0ZW5hdGVkIHN0cmluZ3MgdG8gc2F2ZSBoZWFwIG1lbW9yeSBzcGFjZS5cbiAgICByZXR1cm4gdXVpZC50b1VwcGVyQ2FzZSgpXG5cbiAgfVxuXG4gIC8vIExvY2FsIGFzc2lnbiBwb2x5ZmlsbCB0byBhdm9pZCBpbXBvcnRpbmcgdHJvaWthLWNvcmVcbiAgY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbigvKnRhcmdldCwgLi4uc291cmNlcyovKSB7XG4gICAgbGV0IHRhcmdldCA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKGxldCBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZXQgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH07XG5cblxuICBjb25zdCBlcG9jaCA9IERhdGUubm93KCk7XG4gIGNvbnN0IENPTlNUUlVDVE9SX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgU0hBREVSX1VQR1JBREVfQ0FDSEUgPSBuZXcgTWFwKCk7XG5cbiAgLy8gTWF0ZXJpYWwgaWRzIG11c3QgYmUgaW50ZWdlcnMsIGJ1dCB3ZSBjYW4ndCBhY2Nlc3MgdGhlIGluY3JlbWVudCBmcm9tIFRocmVlJ3MgYE1hdGVyaWFsYCBtb2R1bGUsXG4gIC8vIHNvIGxldCdzIGNob29zZSBhIHN1ZmZpY2llbnRseSBsYXJnZSBzdGFydGluZyB2YWx1ZSB0aGF0IHNob3VsZCB0aGVvcmV0aWNhbGx5IG5ldmVyIGNvbGxpZGUuXG4gIGxldCBtYXRlcmlhbEluc3RhbmNlSWQgPSAxZTEwO1xuXG4gIC8qKlxuICAgKiBBIHV0aWxpdHkgZm9yIGNyZWF0aW5nIGEgY3VzdG9tIHNoYWRlciBtYXRlcmlhbCBkZXJpdmVkIGZyb20gYW5vdGhlciBtYXRlcmlhbCdzXG4gICAqIHNoYWRlcnMuIFRoaXMgYWxsb3dzIHlvdSB0byBpbmplY3QgY3VzdG9tIHNoYWRlciBsb2dpYyBhbmQgdHJhbnNmb3JtcyBpbnRvIHRoZVxuICAgKiBidWlsdGluIFRocmVlSlMgbWF0ZXJpYWxzIHdpdGhvdXQgaGF2aW5nIHRvIHJlY3JlYXRlIHRoZW0gZnJvbSBzY3JhdGNoLlxuICAgKlxuICAgKiBAcGFyYW0ge1RIUkVFLk1hdGVyaWFsfSBiYXNlTWF0ZXJpYWwgLSB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgdG8gZGVyaXZlIGZyb21cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBIb3cgdGhlIGJhc2UgbWF0ZXJpYWwgc2hvdWxkIGJlIG1vZGlmaWVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5kZWZpbmVzIC0gQ3VzdG9tIGBkZWZpbmVzYCBmb3IgdGhlIG1hdGVyaWFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmV4dGVuc2lvbnMgLSBDdXN0b20gYGV4dGVuc2lvbnNgIGZvciB0aGUgbWF0ZXJpYWwsIGUuZy4gYHtkZXJpdmF0aXZlczogdHJ1ZX1gXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnVuaWZvcm1zIC0gQ3VzdG9tIGB1bmlmb3Jtc2AgZm9yIHVzZSBpbiB0aGUgbW9kaWZpZWQgc2hhZGVyLiBUaGVzZSBjYW5cbiAgICogICAgICAgIGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZCB2aWEgdGhlIHJlc3VsdGluZyBtYXRlcmlhbCdzIGB1bmlmb3Jtc2AgcHJvcGVydHksIGp1c3QgbGlrZVxuICAgKiAgICAgICAgaW4gYSBTaGFkZXJNYXRlcmlhbC4gWW91IGRvIG5vdCBuZWVkIHRvIHJlcGVhdCB0aGUgYmFzZSBtYXRlcmlhbCdzIG93biB1bmlmb3JtcyBoZXJlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1lVW5pZm9ybSAtIElmIHNwZWNpZmllZCwgYSB1bmlmb3JtIG9mIHRoaXMgbmFtZSB3aWxsIGJlIGluamVjdGVkIGludG9cbiAgICogICAgICAgIGJvdGggc2hhZGVycywgYW5kIGl0IHdpbGwgYXV0b21hdGljYWxseSBiZSB1cGRhdGVkIG9uIGVhY2ggcmVuZGVyIGZyYW1lIHdpdGggYSBudW1iZXIgb2ZcbiAgICogICAgICAgIGVsYXBzZWQgbWlsbGlzZWNvbmRzLiBUaGUgXCJ6ZXJvXCIgZXBvY2ggdGltZSBpcyBub3Qgc2lnbmlmaWNhbnQgc28gZG9uJ3QgcmVseSBvbiB0aGlzIGFzIGFcbiAgICogICAgICAgIHRydWUgY2FsZW5kYXIgdGltZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudmVydGV4RGVmcyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGludG8gdGhlIHZlcnRleCBzaGFkZXIncyB0b3AtbGV2ZWxcbiAgICogICAgICAgIGRlZmluaXRpb25zLCBhYm92ZSB0aGUgYHZvaWQgbWFpbigpYCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudmVydGV4TWFpbkludHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIHRvcCBvZiB0aGUgdmVydGV4XG4gICAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudmVydGV4TWFpbk91dHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgdmVydGV4XG4gICAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudmVydGV4VHJhbnNmb3JtIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBtYW5pcHVsYXRlIHRoZSBgcG9zaXRpb25gLCBgbm9ybWFsYCxcbiAgICogICAgICAgIGFuZC9vciBgdXZgIHZlcnRleCBhdHRyaWJ1dGVzLiBUaGlzIGNvZGUgd2lsbCBiZSB3cmFwcGVkIHdpdGhpbiBhIHN0YW5kYWxvbmUgZnVuY3Rpb24gd2l0aFxuICAgKiAgICAgICAgdGhvc2UgYXR0cmlidXRlcyBleHBvc2VkIGJ5IHRoZWlyIG5vcm1hbCBuYW1lcyBhcyByZWFkL3dyaXRlIHZhbHVlcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnREZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgZnJhZ21lbnQgc2hhZGVyJ3MgdG9wLWxldmVsXG4gICAqICAgICAgICBkZWZpbml0aW9ucywgYWJvdmUgdGhlIGB2b2lkIG1haW4oKWAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50TWFpbkludHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIHRvcCBvZiB0aGUgZnJhZ21lbnRcbiAgICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudE1haW5PdXRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XG4gICAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi4gWW91IGNhbiBtYW5pcHVsYXRlIGBnbF9GcmFnQ29sb3JgIGhlcmUgYnV0IGtlZXAgaW4gbWluZCBpdCBnb2VzXG4gICAqICAgICAgICBhZnRlciBhbnkgb2YgVGhyZWVKUydzIGNvbG9yIHBvc3Rwcm9jZXNzaW5nIHNoYWRlciBjaHVua3MgKHRvbmVtYXBwaW5nLCBmb2csIGV0Yy4pLCBzbyBpZiB5b3VcbiAgICogICAgICAgIHdhbnQgdGhvc2UgdG8gYXBwbHkgdG8geW91ciBjaGFuZ2VzIHVzZSBgZnJhZ21lbnRDb2xvclRyYW5zZm9ybWAgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnRDb2xvclRyYW5zZm9ybSAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gbWFuaXB1bGF0ZSB0aGUgYGdsX0ZyYWdDb2xvcmBcbiAgICogICAgICAgIG91dHB1dCB2YWx1ZS4gV2lsbCBiZSBpbmplY3RlZCBuZWFyIHRoZSBlbmQgb2YgdGhlIGB2b2lkIG1haW5gIGZ1bmN0aW9uLCBidXQgYmVmb3JlIGFueVxuICAgKiAgICAgICAgb2YgVGhyZWVKUydzIGNvbG9yIHBvc3Rwcm9jZXNzaW5nIHNoYWRlciBjaHVua3MgKHRvbmVtYXBwaW5nLCBmb2csIGV0Yy4pLCBhbmQgYmVmb3JlIHRoZVxuICAgKiAgICAgICAgYGZyYWdtZW50TWFpbk91dHJvYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbjx7dmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyfT46e3ZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcn19IG9wdGlvbnMuY3VzdG9tUmV3cml0ZXIgLSBBIGZ1bmN0aW9uXG4gICAqICAgICAgICBmb3IgcGVyZm9ybWluZyBjdXN0b20gcmV3cml0ZXMgb2YgdGhlIGZ1bGwgc2hhZGVyIGNvZGUuIFVzZWZ1bCBpZiB5b3UgbmVlZCB0byBkbyBzb21ldGhpbmdcbiAgICogICAgICAgIHNwZWNpYWwgdGhhdCdzIG5vdCBjb3ZlcmVkIGJ5IHRoZSBvdGhlciBidWlsdGluIG9wdGlvbnMuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZCBiZWZvcmVcbiAgICogICAgICAgIGFueSBvdGhlciB0cmFuc2Zvcm1zIGFyZSBhcHBsaWVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY2hhaW5lZCAtIFNldCB0byBgdHJ1ZWAgdG8gcHJvdG90eXBlLWNoYWluIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvIHRoZSBiYXNlXG4gICAqICAgICAgICBtYXRlcmlhbCwgcmF0aGVyIHRoYW4gdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgY29weWluZyBpdC4gVGhpcyBhbGxvd3MgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgdG9cbiAgICogICAgICAgIGF1dG9tYXRpY2FsbHkgcGljayB1cCBjaGFuZ2VzIG1hZGUgdG8gdGhlIGJhc2UgbWF0ZXJpYWwgYW5kIGl0cyBwcm9wZXJ0aWVzLiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAgICogICAgICAgIHdoZXJlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGlzIGhpZGRlbiBmcm9tIHRoZSB1c2VyIGFzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCwgYWxsb3dpbmcgdGhlbVxuICAgKiAgICAgICAgdG8gd29yayB3aXRoIHRoZSBvcmlnaW5hbCBtYXRlcmlhbCBsaWtlIG5vcm1hbC4gQnV0IGl0IGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvciBpZiBub3RcbiAgICogICAgICAgIGhhbmRsZWQgY2FyZWZ1bGx5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NYXRlcmlhbH1cbiAgICpcbiAgICogVGhlIHJldHVybmVkIG1hdGVyaWFsIHdpbGwgYWxzbyBoYXZlIHR3byBuZXcgbWV0aG9kcywgYGdldERlcHRoTWF0ZXJpYWwoKWAgYW5kIGBnZXREaXN0YW5jZU1hdGVyaWFsKClgLFxuICAgKiB3aGljaCBjYW4gYmUgY2FsbGVkIHRvIGdldCBhIHZhcmlhbnQgb2YgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgZm9yIHVzZSBpbiBzaGFkb3cgY2FzdGluZy4gSWYgdGhlXG4gICAqIHRhcmdldCBtZXNoIGlzIGV4cGVjdGVkIHRvIGNhc3Qgc2hhZG93cywgdGhlbiB5b3UgY2FuIGFzc2lnbiB0aGVzZSB0byB0aGUgbWVzaCdzIGBjdXN0b21EZXB0aE1hdGVyaWFsYFxuICAgKiAoZm9yIGRpcmVjdGlvbmFsIGFuZCBzcG90IGxpZ2h0cykgYW5kL29yIGBjdXN0b21EaXN0YW5jZU1hdGVyaWFsYCAoZm9yIHBvaW50IGxpZ2h0cykgcHJvcGVydGllcyB0b1xuICAgKiBhbGxvdyB0aGUgY2FzdCBzaGFkb3cgdG8gaG9ub3IgeW91ciBkZXJpdmVkIHNoYWRlcidzIHZlcnRleCB0cmFuc2Zvcm1zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLiBUaGVzZVxuICAgKiB3aWxsIGFsc28gc2V0IGEgY3VzdG9tIGAjZGVmaW5lIElTX0RFUFRIX01BVEVSSUFMYCBvciBgI2RlZmluZSBJU19ESVNUQU5DRV9NQVRFUklBTGAgdGhhdCB5b3UgY2FuIGxvb2tcbiAgICogZm9yIGluIHlvdXIgZGVyaXZlZCBzaGFkZXJzIHdpdGggYCNpZmRlZmAgdG8gY3VzdG9taXplIHRoZWlyIGJlaGF2aW9yIGZvciB0aGUgZGVwdGggb3IgZGlzdGFuY2VcbiAgICogc2NlbmFyaW9zLCBlLmcuIHNraXBwaW5nIGFudGlhbGlhc2luZyBvciBleHBlbnNpdmUgc2hhZGVyIGxvZ2ljLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwgb3B0aW9ucykge1xuICAgIC8vIEdlbmVyYXRlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSBjb250ZW50IG9mIHRoZXNlIGBvcHRpb25zYC4gV2UnbGwgdXNlIHRoaXNcbiAgICAvLyB0aHJvdWdob3V0IGZvciBjYWNoaW5nIGFuZCBmb3IgZ2VuZXJhdGluZyB0aGUgdXBncmFkZWQgc2hhZGVyIGNvZGUuIFRoaXMgaW5jcmVhc2VzXG4gICAgLy8gdGhlIGxpa2VsaWhvb2QgdGhhdCB0aGUgcmVzdWx0aW5nIHNoYWRlcnMgd2lsbCBsaW5lIHVwIGFjcm9zcyBtdWx0aXBsZSBjYWxscyBzb1xuICAgIC8vIHRoZWlyIEdMIHByb2dyYW1zIGNhbiBiZSBzaGFyZWQgYW5kIGNhY2hlZC5cbiAgICBjb25zdCBvcHRpb25zS2V5ID0gZ2V0S2V5Rm9yT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIC8vIEZpcnN0IGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IGRlcml2ZWQgZnJvbSB0aGlzIGJhc2VNYXRlcmlhbCB1c2luZyB0aGlzXG4gICAgLy8gdW5pcXVlIHNldCBvZiBvcHRpb25zLCBhbmQgaWYgc28gcmV1c2UgdGhlIGNvbnN0cnVjdG9yIHRvIGF2b2lkIHNvbWUgYWxsb2NhdGlvbnMuXG4gICAgbGV0IGN0b3JzQnlEZXJpdmF0aW9uID0gQ09OU1RSVUNUT1JfQ0FDSEUuZ2V0KGJhc2VNYXRlcmlhbCk7XG4gICAgaWYgKCFjdG9yc0J5RGVyaXZhdGlvbikge1xuICAgICAgQ09OU1RSVUNUT1JfQ0FDSEUuc2V0KGJhc2VNYXRlcmlhbCwgKGN0b3JzQnlEZXJpdmF0aW9uID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpO1xuICAgIH1cbiAgICBpZiAoY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0pIHtcbiAgICAgIHJldHVybiBuZXcgY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0oKVxuICAgIH1cblxuICAgIGNvbnN0IHByaXZhdGVCZWZvcmVDb21waWxlUHJvcCA9IGBfb25CZWZvcmVDb21waWxlJHtvcHRpb25zS2V5fWA7XG5cbiAgICAvLyBQcml2YXRlIG9uQmVmb3JlQ29tcGlsZSBoYW5kbGVyIHRoYXQgaW5qZWN0cyB0aGUgbW9kaWZpZWQgc2hhZGVycyBhbmQgdW5pZm9ybXMgd2hlblxuICAgIC8vIHRoZSByZW5kZXJlciBzd2l0Y2hlcyB0byB0aGlzIG1hdGVyaWFsJ3MgcHJvZ3JhbVxuICAgIGNvbnN0IG9uQmVmb3JlQ29tcGlsZSA9IGZ1bmN0aW9uIChzaGFkZXJJbmZvLCByZW5kZXJlcikge1xuICAgICAgYmFzZU1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZS5jYWxsKHRoaXMsIHNoYWRlckluZm8sIHJlbmRlcmVyKTtcblxuICAgICAgLy8gVXBncmFkZSB0aGUgc2hhZGVycywgY2FjaGluZyB0aGUgcmVzdWx0IGJ5IGluY29taW5nIHNvdXJjZSBjb2RlXG4gICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkgKyAnfCcgKyBzaGFkZXJJbmZvLnZlcnRleFNoYWRlciArICd8JyArIHNoYWRlckluZm8uZnJhZ21lbnRTaGFkZXI7XG4gICAgICBsZXQgdXBncmFkZWRTaGFkZXJzID0gU0hBREVSX1VQR1JBREVfQ0FDSEVbY2FjaGVLZXldO1xuICAgICAgaWYgKCF1cGdyYWRlZFNoYWRlcnMpIHtcbiAgICAgICAgY29uc3QgdXBncmFkZWQgPSB1cGdyYWRlU2hhZGVycyh0aGlzLCBzaGFkZXJJbmZvLCBvcHRpb25zLCBvcHRpb25zS2V5KTtcbiAgICAgICAgdXBncmFkZWRTaGFkZXJzID0gU0hBREVSX1VQR1JBREVfQ0FDSEVbY2FjaGVLZXldID0gdXBncmFkZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEluamVjdCB1cGdyYWRlZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyBpbnRvIHRoZSBwcm9ncmFtXG4gICAgICBzaGFkZXJJbmZvLnZlcnRleFNoYWRlciA9IHVwZ3JhZGVkU2hhZGVycy52ZXJ0ZXhTaGFkZXI7XG4gICAgICBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyID0gdXBncmFkZWRTaGFkZXJzLmZyYWdtZW50U2hhZGVyO1xuICAgICAgYXNzaWduKHNoYWRlckluZm8udW5pZm9ybXMsIHRoaXMudW5pZm9ybXMpO1xuXG4gICAgICAvLyBJbmplY3QgYXV0by11cGRhdGluZyB0aW1lIHVuaWZvcm0gaWYgcmVxdWVzdGVkXG4gICAgICBpZiAob3B0aW9ucy50aW1lVW5pZm9ybSkge1xuICAgICAgICBzaGFkZXJJbmZvLnVuaWZvcm1zW29wdGlvbnMudGltZVVuaWZvcm1dID0ge1xuICAgICAgICAgIGdldCB2YWx1ZSgpIHtyZXR1cm4gRGF0ZS5ub3coKSAtIGVwb2NofVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VycyBjYW4gc3RpbGwgYWRkIHRoZWlyIG93biBoYW5kbGVycyBvbiB0b3Agb2Ygb3Vyc1xuICAgICAgaWYgKHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXSkge1xuICAgICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0oc2hhZGVySW5mbyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IERlcml2ZWRNYXRlcmlhbCA9IGZ1bmN0aW9uIERlcml2ZWRNYXRlcmlhbCgpIHtcbiAgICAgIHJldHVybiBkZXJpdmUob3B0aW9ucy5jaGFpbmVkID8gYmFzZU1hdGVyaWFsIDogYmFzZU1hdGVyaWFsLmNsb25lKCkpXG4gICAgfTtcblxuICAgIGNvbnN0IGRlcml2ZSA9IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAgIC8vIFByb3RvdHlwZSBjaGFpbiB0byB0aGUgYmFzZSBtYXRlcmlhbFxuICAgICAgY29uc3QgZGVyaXZlZCA9IE9iamVjdC5jcmVhdGUoYmFzZSwgZGVzY3JpcHRvcik7XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBiYXNlTWF0ZXJpYWwgZm9yIHJlZmVyZW5jZTsgdGhpcyBpcyBhbHdheXMgdGhlIG9yaWdpbmFsIGV2ZW4gd2hlbiBjbG9uaW5nXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVyaXZlZCwgJ2Jhc2VNYXRlcmlhbCcsIHsgdmFsdWU6IGJhc2VNYXRlcmlhbCB9KTtcblxuICAgICAgLy8gTmVlZHMgaXRzIG93biBpZHNcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkLCAnaWQnLCB7IHZhbHVlOiBtYXRlcmlhbEluc3RhbmNlSWQrKyB9KTtcbiAgICAgIGRlcml2ZWQudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG4gICAgICAvLyBNZXJnZSB1bmlmb3JtcywgZGVmaW5lcywgYW5kIGV4dGVuc2lvbnNcbiAgICAgIGRlcml2ZWQudW5pZm9ybXMgPSBhc3NpZ24oe30sIGJhc2UudW5pZm9ybXMsIG9wdGlvbnMudW5pZm9ybXMpO1xuICAgICAgZGVyaXZlZC5kZWZpbmVzID0gYXNzaWduKHt9LCBiYXNlLmRlZmluZXMsIG9wdGlvbnMuZGVmaW5lcyk7XG4gICAgICBkZXJpdmVkLmRlZmluZXNbYFRST0lLQV9ERVJJVkVEX01BVEVSSUFMXyR7b3B0aW9uc0tleX1gXSA9ICcnOyAvL2ZvcmNlIGEgcHJvZ3JhbSBjaGFuZ2UgZnJvbSB0aGUgYmFzZSBtYXRlcmlhbFxuICAgICAgZGVyaXZlZC5leHRlbnNpb25zID0gYXNzaWduKHt9LCBiYXNlLmV4dGVuc2lvbnMsIG9wdGlvbnMuZXh0ZW5zaW9ucyk7XG5cbiAgICAgIC8vIERvbid0IGluaGVyaXQgRXZlbnREaXNwYXRjaGVyIGxpc3RlbmVyc1xuICAgICAgZGVyaXZlZC5fbGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gZGVyaXZlZFxuICAgIH07XG5cbiAgICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgICAgY29uc3RydWN0b3I6IHt2YWx1ZTogRGVyaXZlZE1hdGVyaWFsfSxcbiAgICAgIGlzRGVyaXZlZE1hdGVyaWFsOiB7dmFsdWU6IHRydWV9LFxuXG4gICAgICBjdXN0b21Qcm9ncmFtQ2FjaGVLZXk6IHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZU1hdGVyaWFsLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgb3B0aW9uc0tleVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvbkJlZm9yZUNvbXBpbGU6IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBvbkJlZm9yZUNvbXBpbGVcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGZuKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdID0gZm47XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvcHk6IHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICBiYXNlTWF0ZXJpYWwuY29weS5jYWxsKHRoaXMsIHNvdXJjZSk7XG4gICAgICAgICAgaWYgKCFiYXNlTWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiAhYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsKSB7XG4gICAgICAgICAgICBhc3NpZ24odGhpcy5leHRlbnNpb25zLCBzb3VyY2UuZXh0ZW5zaW9ucyk7XG4gICAgICAgICAgICBhc3NpZ24odGhpcy5kZWZpbmVzLCBzb3VyY2UuZGVmaW5lcyk7XG4gICAgICAgICAgICBhc3NpZ24odGhpcy51bmlmb3JtcywgdGhyZWUuVW5pZm9ybXNVdGlscy5jbG9uZShzb3VyY2UudW5pZm9ybXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY2xvbmU6IHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCBuZXdCYXNlID0gbmV3IGJhc2VNYXRlcmlhbC5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgIHJldHVybiBkZXJpdmUobmV3QmFzZSkuY29weSh0aGlzKVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERlcHRoTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAgICogdHJhbnNmb3JtYXRpb25zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLlxuICAgICAgICovXG4gICAgICBnZXREZXB0aE1hdGVyaWFsOiB7XG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgZGVwdGhNYXRlcmlhbCA9IHRoaXMuX2RlcHRoTWF0ZXJpYWw7XG4gICAgICAgICAgaWYgKCFkZXB0aE1hdGVyaWFsKSB7XG4gICAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gdGhpcy5fZGVwdGhNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgICAgYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsXG4gICAgICAgICAgICAgICAgPyBiYXNlTWF0ZXJpYWwuZ2V0RGVwdGhNYXRlcmlhbCgpXG4gICAgICAgICAgICAgICAgOiBuZXcgdGhyZWUuTWVzaERlcHRoTWF0ZXJpYWwoeyBkZXB0aFBhY2tpbmc6IHRocmVlLlJHQkFEZXB0aFBhY2tpbmcgfSksXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZXB0aE1hdGVyaWFsLmRlZmluZXMuSVNfREVQVEhfTUFURVJJQUwgPSAnJztcbiAgICAgICAgICAgIGRlcHRoTWF0ZXJpYWwudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zOyAvL2F1dG9tYXRpY2FsbHkgcmVjaWV2ZSBzYW1lIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZXB0aE1hdGVyaWFsXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVXRpbGl0eSB0byBnZXQgYSBNZXNoRGlzdGFuY2VNYXRlcmlhbCB0aGF0IHdpbGwgaG9ub3IgdGhpcyBkZXJpdmVkIG1hdGVyaWFsJ3MgdmVydGV4XG4gICAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgYW5kIGRpc2NhcmRlZCBmcmFnbWVudHMuXG4gICAgICAgKi9cbiAgICAgIGdldERpc3RhbmNlTWF0ZXJpYWw6IHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxldCBkaXN0YW5jZU1hdGVyaWFsID0gdGhpcy5fZGlzdGFuY2VNYXRlcmlhbDtcbiAgICAgICAgICBpZiAoIWRpc3RhbmNlTWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgICAgICAgICBiYXNlTWF0ZXJpYWwuaXNEZXJpdmVkTWF0ZXJpYWxcbiAgICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgICAgICAgICAgICAgICA6IG5ldyB0aHJlZS5NZXNoRGlzdGFuY2VNYXRlcmlhbCgpLFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbC5kZWZpbmVzLklTX0RJU1RBTkNFX01BVEVSSUFMID0gJyc7XG4gICAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtczsgLy9hdXRvbWF0aWNhbGx5IHJlY2lldmUgc2FtZSB1bmlmb3JtIHZhbHVlc1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlzdGFuY2VNYXRlcmlhbFxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkaXNwb3NlOiB7XG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgIGNvbnN0IHtfZGVwdGhNYXRlcmlhbCwgX2Rpc3RhbmNlTWF0ZXJpYWx9ID0gdGhpcztcbiAgICAgICAgICBpZiAoX2RlcHRoTWF0ZXJpYWwpIF9kZXB0aE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgICBpZiAoX2Rpc3RhbmNlTWF0ZXJpYWwpIF9kaXN0YW5jZU1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgICBiYXNlTWF0ZXJpYWwuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldID0gRGVyaXZlZE1hdGVyaWFsO1xuICAgIHJldHVybiBuZXcgRGVyaXZlZE1hdGVyaWFsKClcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdXBncmFkZVNoYWRlcnMobWF0ZXJpYWwsIHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSwgb3B0aW9ucywga2V5KSB7XG4gICAgbGV0IHtcbiAgICAgIHZlcnRleERlZnMsXG4gICAgICB2ZXJ0ZXhNYWluSW50cm8sXG4gICAgICB2ZXJ0ZXhNYWluT3V0cm8sXG4gICAgICB2ZXJ0ZXhUcmFuc2Zvcm0sXG4gICAgICBmcmFnbWVudERlZnMsXG4gICAgICBmcmFnbWVudE1haW5JbnRybyxcbiAgICAgIGZyYWdtZW50TWFpbk91dHJvLFxuICAgICAgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSxcbiAgICAgIGN1c3RvbVJld3JpdGVyLFxuICAgICAgdGltZVVuaWZvcm1cbiAgICB9ID0gb3B0aW9ucztcblxuICAgIHZlcnRleERlZnMgPSB2ZXJ0ZXhEZWZzIHx8ICcnO1xuICAgIHZlcnRleE1haW5JbnRybyA9IHZlcnRleE1haW5JbnRybyB8fCAnJztcbiAgICB2ZXJ0ZXhNYWluT3V0cm8gPSB2ZXJ0ZXhNYWluT3V0cm8gfHwgJyc7XG4gICAgZnJhZ21lbnREZWZzID0gZnJhZ21lbnREZWZzIHx8ICcnO1xuICAgIGZyYWdtZW50TWFpbkludHJvID0gZnJhZ21lbnRNYWluSW50cm8gfHwgJyc7XG4gICAgZnJhZ21lbnRNYWluT3V0cm8gPSBmcmFnbWVudE1haW5PdXRybyB8fCAnJztcblxuICAgIC8vIEV4cGFuZCBpbmNsdWRlcyBpZiBuZWVkZWRcbiAgICBpZiAodmVydGV4VHJhbnNmb3JtIHx8IGN1c3RvbVJld3JpdGVyKSB7XG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBleHBhbmRTaGFkZXJJbmNsdWRlcyh2ZXJ0ZXhTaGFkZXIpO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRDb2xvclRyYW5zZm9ybSB8fCBjdXN0b21SZXdyaXRlcikge1xuICAgICAgLy8gV2UgbmVlZCB0byBiZSBhYmxlIHRvIGZpbmQgcG9zdHByb2Nlc3NpbmcgY2h1bmtzIGFmdGVyIGluY2x1ZGUgZXhwYW5zaW9uIGluIG9yZGVyIHRvXG4gICAgICAvLyBwdXQgdGhlbSBhZnRlciB0aGUgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgc28gbWFyayB0aGVtIHdpdGggY29tbWVudHMgZmlyc3QuIEV2ZW4gaWZcbiAgICAgIC8vIHRoaXMgcGFydGljdWxhciBkZXJpdmF0aW9uIGRvZXNuJ3QgaGF2ZSBhIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0sIG90aGVyIGRlcml2YXRpb25zIG1heSxcbiAgICAgIC8vIHNvIHdlIHN0aWxsIG1hcmsgdGhlbS5cbiAgICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcbiAgICAgICAgL15bIFxcdF0qI2luY2x1ZGUgPCgoPzp0b25lbWFwcGluZ3xlbmNvZGluZ3N8Zm9nfHByZW11bHRpcGxpZWRfYWxwaGF8ZGl0aGVyaW5nKV9mcmFnbWVudCk+L2dtLFxuICAgICAgICAnXFxuLy8hQkVHSU5fUE9TVF9DSFVOSyAkMVxcbiQmXFxuLy8hRU5EX1BPU1RfQ0hVTktcXG4nXG4gICAgICApO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBleHBhbmRTaGFkZXJJbmNsdWRlcyhmcmFnbWVudFNoYWRlcik7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgY3VzdG9tIHJld3JpdGVyIGZ1bmN0aW9uXG4gICAgaWYgKGN1c3RvbVJld3JpdGVyKSB7XG4gICAgICBsZXQgcmVzID0gY3VzdG9tUmV3cml0ZXIoe3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9KTtcbiAgICAgIHZlcnRleFNoYWRlciA9IHJlcy52ZXJ0ZXhTaGFkZXI7XG4gICAgICBmcmFnbWVudFNoYWRlciA9IHJlcy5mcmFnbWVudFNoYWRlcjtcbiAgICB9XG5cbiAgICAvLyBUaGUgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSBuZWVkcyB0byBnbyBiZWZvcmUgYW55IHBvc3Rwcm9jZXNzaW5nIGNodW5rcywgc28gZXh0cmFjdFxuICAgIC8vIHRob3NlIGFuZCByZS1pbnNlcnQgdGhlbSBpbnRvIHRoZSBvdXRybyBpbiB0aGUgY29ycmVjdCBwbGFjZTpcbiAgICBpZiAoZnJhZ21lbnRDb2xvclRyYW5zZm9ybSkge1xuICAgICAgbGV0IHBvc3RDaHVua3MgPSBbXTtcbiAgICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcbiAgICAgICAgL15cXC9cXC8hQkVHSU5fUE9TVF9DSFVOS1teXSs/XlxcL1xcLyFFTkRfUE9TVF9DSFVOSy9nbSwgLy8gW15dKz8gPSBub24tZ3JlZWR5IG1hdGNoIG9mIGFueSBjaGFycyBpbmNsdWRpbmcgbmV3bGluZXNcbiAgICAgICAgbWF0Y2ggPT4ge1xuICAgICAgICAgIHBvc3RDaHVua3MucHVzaChtYXRjaCk7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBmcmFnbWVudE1haW5PdXRybyA9IGAke2ZyYWdtZW50Q29sb3JUcmFuc2Zvcm19XFxuJHtwb3N0Q2h1bmtzLmpvaW4oJ1xcbicpfVxcbiR7ZnJhZ21lbnRNYWluT3V0cm99YDtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgYXV0by11cGRhdGluZyB0aW1lIHVuaWZvcm0gaWYgcmVxdWVzdGVkXG4gICAgaWYgKHRpbWVVbmlmb3JtKSB7XG4gICAgICBjb25zdCBjb2RlID0gYFxcbnVuaWZvcm0gZmxvYXQgJHt0aW1lVW5pZm9ybX07XFxuYDtcbiAgICAgIHZlcnRleERlZnMgPSBjb2RlICsgdmVydGV4RGVmcztcbiAgICAgIGZyYWdtZW50RGVmcyA9IGNvZGUgKyBmcmFnbWVudERlZnM7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IGEgZnVuY3Rpb24gZm9yIHRoZSB2ZXJ0ZXhUcmFuc2Zvcm0gYW5kIHJlbmFtZSBhbGwgdXNhZ2VzIG9mIHBvc2l0aW9uL25vcm1hbC91dlxuICAgIGlmICh2ZXJ0ZXhUcmFuc2Zvcm0pIHtcbiAgICAgIC8vIEhvaXN0IHRoZXNlIGRlZnMgdG8gdGhlIHZlcnkgdG9wIHNvIHRoZXkgd29yayBpbiBvdGhlciBmdW5jdGlvbiBkZWZzXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBgdmVjMyB0cm9pa2FfcG9zaXRpb25fJHtrZXl9O1xudmVjMyB0cm9pa2Ffbm9ybWFsXyR7a2V5fTtcbnZlYzIgdHJvaWthX3V2XyR7a2V5fTtcbiR7dmVydGV4U2hhZGVyfVxuYDtcbiAgICAgIHZlcnRleERlZnMgPSBgJHt2ZXJ0ZXhEZWZzfVxudm9pZCB0cm9pa2FWZXJ0ZXhUcmFuc2Zvcm0ke2tleX0oaW5vdXQgdmVjMyBwb3NpdGlvbiwgaW5vdXQgdmVjMyBub3JtYWwsIGlub3V0IHZlYzIgdXYpIHtcbiAgJHt2ZXJ0ZXhUcmFuc2Zvcm19XG59XG5gO1xuICAgICAgdmVydGV4TWFpbkludHJvID0gYFxudHJvaWthX3Bvc2l0aW9uXyR7a2V5fSA9IHZlYzMocG9zaXRpb24pO1xudHJvaWthX25vcm1hbF8ke2tleX0gPSB2ZWMzKG5vcm1hbCk7XG50cm9pa2FfdXZfJHtrZXl9ID0gdmVjMih1dik7XG50cm9pa2FWZXJ0ZXhUcmFuc2Zvcm0ke2tleX0odHJvaWthX3Bvc2l0aW9uXyR7a2V5fSwgdHJvaWthX25vcm1hbF8ke2tleX0sIHRyb2lrYV91dl8ke2tleX0pO1xuJHt2ZXJ0ZXhNYWluSW50cm99XG5gO1xuICAgICAgdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyLnJlcGxhY2UoL1xcYihwb3NpdGlvbnxub3JtYWx8dXYpXFxiL2csIChtYXRjaCwgbWF0Y2gxLCBpbmRleCwgZnVsbFN0cikgPT4ge1xuICAgICAgICByZXR1cm4gL1xcYmF0dHJpYnV0ZVxccyt2ZWNbMjNdXFxzKyQvLnRlc3QoZnVsbFN0ci5zdWJzdHIoMCwgaW5kZXgpKSA/IG1hdGNoMSA6IGB0cm9pa2FfJHttYXRjaDF9XyR7a2V5fWBcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUaHJlZSByMTUyIGludHJvZHVjZWQgdGhlIE1BUF9VViB0b2tlbiwgcmVwbGFjZSBpdCB0b28gaWYgaXQncyBwb2ludGluZyB0byB0aGUgbWFpbiAndXYnXG4gICAgICAvLyBQZXJoYXBzIHRoZSBvdGhlciB0ZXh0dXJlcyB0b28gZ29pbmcgZm9yd2FyZD9cbiAgICAgIGlmICghKG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuY2hhbm5lbCA+IDApKSB7XG4gICAgICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKC9cXGJNQVBfVVZcXGIvZywgYHRyb2lrYV91dl8ke2tleX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbmplY3QgZGVmcyBhbmQgaW50cm8vb3V0cm8gc25pcHBldHNcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBpbmplY3RJbnRvU2hhZGVyQ29kZSh2ZXJ0ZXhTaGFkZXIsIGtleSwgdmVydGV4RGVmcywgdmVydGV4TWFpbkludHJvLCB2ZXJ0ZXhNYWluT3V0cm8pO1xuICAgIGZyYWdtZW50U2hhZGVyID0gaW5qZWN0SW50b1NoYWRlckNvZGUoZnJhZ21lbnRTaGFkZXIsIGtleSwgZnJhZ21lbnREZWZzLCBmcmFnbWVudE1haW5JbnRybywgZnJhZ21lbnRNYWluT3V0cm8pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5qZWN0SW50b1NoYWRlckNvZGUoc2hhZGVyQ29kZSwgaWQsIGRlZnMsIGludHJvLCBvdXRybykge1xuICAgIGlmIChpbnRybyB8fCBvdXRybyB8fCBkZWZzKSB7XG4gICAgICBzaGFkZXJDb2RlID0gc2hhZGVyQ29kZS5yZXBsYWNlKHZvaWRNYWluUmVnRXhwLCBgXG4ke2RlZnN9XG52b2lkIHRyb2lrYU9yaWdNYWluJHtpZH0oKSB7YFxuICAgICAgKTtcbiAgICAgIHNoYWRlckNvZGUgKz0gYFxudm9pZCBtYWluKCkge1xuICAke2ludHJvfVxuICB0cm9pa2FPcmlnTWFpbiR7aWR9KCk7XG4gICR7b3V0cm99XG59YDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlckNvZGVcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb3B0aW9uc0pzb25SZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGtleSA9PT0gJ3VuaWZvcm1zJyA/IHVuZGVmaW5lZCA6IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZVxuICB9XG5cbiAgbGV0IF9pZEN0ciA9IDA7XG4gIGNvbnN0IG9wdGlvbnNIYXNoZXNUb0lkcyA9IG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gZ2V0S2V5Rm9yT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9uc0hhc2ggPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLCBvcHRpb25zSnNvblJlcGxhY2VyKTtcbiAgICBsZXQgaWQgPSBvcHRpb25zSGFzaGVzVG9JZHMuZ2V0KG9wdGlvbnNIYXNoKTtcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgb3B0aW9uc0hhc2hlc1RvSWRzLnNldChvcHRpb25zSGFzaCwgKGlkID0gKytfaWRDdHIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICAvLyBDb3BpZWQgZnJvbSB0aHJlZWpzIFdlYkdMUHJvZ3JhbXMuanMgc28gd2UgY2FuIHJlc29sdmUgYnVpbHRpbiBtYXRlcmlhbHMgdG8gdGhlaXIgc2hhZGVyc1xuICAvLyBUT0RPIGhvdyBjYW4gd2Uga2VlcCB0aGlzIGZyb20gZ2V0dGluZyBzdGFsZT9cbiAgY29uc3QgTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSUyA9IHtcbiAgICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgICBNZXNoRGlzdGFuY2VNYXRlcmlhbDogJ2Rpc3RhbmNlUkdCQScsXG4gICAgTWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcbiAgICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgICBNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXG4gICAgTWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG4gICAgTWVzaFRvb25NYXRlcmlhbDogJ3Rvb24nLFxuICAgIE1lc2hTdGFuZGFyZE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuICAgIE1lc2hQaHlzaWNhbE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuICAgIE1lc2hNYXRjYXBNYXRlcmlhbDogJ21hdGNhcCcsXG4gICAgTGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gICAgTGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcbiAgICBQb2ludHNNYXRlcmlhbDogJ3BvaW50cycsXG4gICAgU2hhZG93TWF0ZXJpYWw6ICdzaGFkb3cnLFxuICAgIFNwcml0ZU1hdGVyaWFsOiAnc3ByaXRlJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIFRocmVlLmpzIGBNYXRlcmlhbGAgaW5zdGFuY2UsIGZpbmQgdGhlIHNoYWRlcnMvdW5pZm9ybXMgdGhhdCB3aWxsIGJlXG4gICAqIHVzZWQgdG8gcmVuZGVyIHRoYXQgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSBtYXRlcmlhbCAtIHRoZSBNYXRlcmlhbCBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gdGhlIG1hdGVyaWFsJ3Mgc2hhZGVyIGluZm86IGB7dW5pZm9ybXM6e30sIGZyYWdtZW50U2hhZGVyOicnLCB2ZXJ0ZXhTaGFkZXI6Jyd9YFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2hhZGVyc0Zvck1hdGVyaWFsKG1hdGVyaWFsKSB7XG4gICAgbGV0IGJ1aWx0aW5UeXBlID0gTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSU1ttYXRlcmlhbC50eXBlXTtcbiAgICByZXR1cm4gYnVpbHRpblR5cGUgPyB0aHJlZS5TaGFkZXJMaWJbYnVpbHRpblR5cGVdIDogbWF0ZXJpYWwgLy9UT0RPIGZhbGxiYWNrIGZvciB1bmtub3duIHR5cGU/XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhbGwgdW5pZm9ybXMgYW5kIHRoZWlyIHR5cGVzIHdpdGhpbiBhIHNoYWRlciBjb2RlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlciAtIFRoZSBzaGFkZXIgY29kZSB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtvYmplY3R9IG1hcHBpbmcgb2YgdW5pZm9ybSBuYW1lcyB0byB0aGVpciBnbHNsIHR5cGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNoYWRlclVuaWZvcm1UeXBlcyhzaGFkZXIpIHtcbiAgICBsZXQgdW5pZm9ybVJFID0gL1xcYnVuaWZvcm1cXHMrKGludHxmbG9hdHx2ZWNbMjM0XXxtYXRbMzRdKVxccysoW0EtWmEtel9dW1xcd10qKS9nO1xuICAgIGxldCB1bmlmb3JtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IG1hdGNoO1xuICAgIHdoaWxlICgobWF0Y2ggPSB1bmlmb3JtUkUuZXhlYyhzaGFkZXIpKSAhPT0gbnVsbCkge1xuICAgICAgdW5pZm9ybXNbbWF0Y2hbMl1dID0gbWF0Y2hbMV07XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3Jtc1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmb3Igc21vb3RoaW5nIG91dCB0aGUgYG0uZ2V0SW52ZXJzZSh4KWAgLS0+IGBtLmNvcHkoeCkuaW52ZXJ0KClgIGNvbnZlcnNpb25cbiAgICogdGhhdCBoYXBwZW5lZCBpbiBUaHJlZUpTIHIxMjMuXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gc3JjTWF0cml4XG4gICAqIEBwYXJhbSB7TWF0cml4NH0gW3RndE1hdHJpeF1cbiAgICovXG4gIGZ1bmN0aW9uIGludmVydE1hdHJpeDQoc3JjTWF0cml4LCB0Z3RNYXRyaXggPSBuZXcgdGhyZWUuTWF0cml4NCgpKSB7XG4gICAgaWYgKHR5cGVvZiB0Z3RNYXRyaXguaW52ZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0Z3RNYXRyaXguY29weShzcmNNYXRyaXgpLmludmVydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0Z3RNYXRyaXguZ2V0SW52ZXJzZShzcmNNYXRyaXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGd0TWF0cml4XG4gIH1cblxuICAvKlxuICBJbnB1dCBnZW9tZXRyeSBpcyBhIGN5bGluZGVyIHdpdGggcj0xLCBoZWlnaHQgaW4geSBkaW1lbnNpb24gZnJvbSAwIHRvIDEsXG4gIGRpdmlkZWQgaW50byBhIHJlYXNvbmFibGUgbnVtYmVyIG9mIGhlaWdodCBzZWdtZW50cy5cbiAgKi9cblxuICBjb25zdCB2ZXJ0ZXhEZWZzID0gYFxudW5pZm9ybSB2ZWMzIHBvaW50QTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQjtcbnVuaWZvcm0gdmVjMyBwb2ludEI7XG51bmlmb3JtIGZsb2F0IHJhZGl1cztcbnZhcnlpbmcgZmxvYXQgYmV6aWVyVDtcblxudmVjMyBjdWJpY0Jlemllcih2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgZmxvYXQgYjAgPSB0MiAqIHQyICogdDI7XG4gIGZsb2F0IGIxID0gMy4wICogdCAqIHQyICogdDI7XG4gIGZsb2F0IGIyID0gMy4wICogdCAqIHQgKiB0MjtcbiAgZmxvYXQgYjMgPSB0ICogdCAqIHQ7XG4gIHJldHVybiBiMCAqIHAxICsgYjEgKiBjMSArIGIyICogYzIgKyBiMyAqIHAyO1xufVxuXG52ZWMzIGN1YmljQmV6aWVyRGVyaXZhdGl2ZSh2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgcmV0dXJuIC0zLjAgKiBwMSAqIHQyICogdDIgK1xuICAgIGMxICogKDMuMCAqIHQyICogdDIgLSA2LjAgKiB0MiAqIHQpICtcbiAgICBjMiAqICg2LjAgKiB0MiAqIHQgLSAzLjAgKiB0ICogdCkgK1xuICAgIDMuMCAqIHAyICogdCAqIHQ7XG59XG5gO1xuXG4gIGNvbnN0IHZlcnRleFRyYW5zZm9ybSA9IGBcbmZsb2F0IHQgPSBwb3NpdGlvbi55O1xuYmV6aWVyVCA9IHQ7XG52ZWMzIGJlemllckNlbnRlclBvcyA9IGN1YmljQmV6aWVyKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQpO1xudmVjMyBiZXppZXJEaXIgPSBub3JtYWxpemUoY3ViaWNCZXppZXJEZXJpdmF0aXZlKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQpKTtcblxuLy8gTWFrZSBcInNpZGV3YXlzXCIgYWx3YXlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGNhbWVyYSByYXk7IHRoaXMgZW5zdXJlcyB0aGF0IGFueSB0d2lzdHNcbi8vIGluIHRoZSBjeWxpbmRlciBvY2N1ciB3aGVyZSB5b3Ugd29uJ3Qgc2VlIHRoZW06IFxudmVjMyB2aWV3RGlyZWN0aW9uID0gbm9ybWFsTWF0cml4ICogdmVjMygwLjAsIDAuMCwgMS4wKTtcbmlmIChiZXppZXJEaXIgPT0gdmlld0RpcmVjdGlvbikge1xuICBiZXppZXJEaXIgPSBub3JtYWxpemUoY3ViaWNCZXppZXJEZXJpdmF0aXZlKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQgPT0gMS4wID8gdCAtIDAuMDAwMSA6IHQgKyAwLjAwMDEpKTtcbn1cbnZlYzMgc2lkZXdheXMgPSBub3JtYWxpemUoY3Jvc3MoYmV6aWVyRGlyLCB2aWV3RGlyZWN0aW9uKSk7XG52ZWMzIHVwaXNoID0gbm9ybWFsaXplKGNyb3NzKHNpZGV3YXlzLCBiZXppZXJEaXIpKTtcblxuLy8gQnVpbGQgYSBtYXRyaXggZm9yIHRyYW5zZm9ybWluZyB0aGlzIGRpc2MgaW4gdGhlIGN5bGluZGVyOlxubWF0NCBkaXNjVHg7XG5kaXNjVHhbMF0ueHl6ID0gc2lkZXdheXMgKiByYWRpdXM7XG5kaXNjVHhbMV0ueHl6ID0gYmV6aWVyRGlyICogcmFkaXVzO1xuZGlzY1R4WzJdLnh5eiA9IHVwaXNoICogcmFkaXVzO1xuZGlzY1R4WzNdLnh5eiA9IGJlemllckNlbnRlclBvcztcbmRpc2NUeFszXVszXSA9IDEuMDtcblxuLy8gQXBwbHkgdHJhbnNmb3JtLCBpZ25vcmluZyBvcmlnaW5hbCB5XG5wb3NpdGlvbiA9IChkaXNjVHggKiB2ZWM0KHBvc2l0aW9uLngsIDAuMCwgcG9zaXRpb24ueiwgMS4wKSkueHl6O1xubm9ybWFsID0gbm9ybWFsaXplKG1hdDMoZGlzY1R4KSAqIG5vcm1hbCk7XG5gO1xuXG4gIGNvbnN0IGZyYWdtZW50RGVmcyA9IGBcbnVuaWZvcm0gdmVjMyBkYXNoaW5nO1xudmFyeWluZyBmbG9hdCBiZXppZXJUO1xuYDtcblxuICBjb25zdCBmcmFnbWVudE1haW5JbnRybyA9IGBcbmlmIChkYXNoaW5nLnggKyBkYXNoaW5nLnkgPiAwLjApIHtcbiAgZmxvYXQgZGFzaEZyYWMgPSBtb2QoYmV6aWVyVCAtIGRhc2hpbmcueiwgZGFzaGluZy54ICsgZGFzaGluZy55KTtcbiAgaWYgKGRhc2hGcmFjID4gZGFzaGluZy54KSB7XG4gICAgZGlzY2FyZDtcbiAgfVxufVxuYDtcblxuICAvLyBEZWJ1Z2dpbmc6IHNlcGFyYXRlIGNvbG9yIGZvciBlYWNoIG9mIHRoZSA2IHNpZGVzOlxuICAvLyBjb25zdCBmcmFnbWVudENvbG9yVHJhbnNmb3JtID0gYFxuICAvLyBmbG9hdCBzaWRlTnVtID0gZmxvb3IodlVWLnggKiA2LjApO1xuICAvLyB2ZWMzIG1peENvbG9yID0gc2lkZU51bSA8IDEuMCA/IHZlYzMoMS4wLCAwLjAsIDAuMCkgOlxuICAvLyAgIHNpZGVOdW0gPCAyLjAgPyB2ZWMzKDAuMCwgMS4wLCAxLjApIDpcbiAgLy8gICBzaWRlTnVtIDwgMy4wID8gdmVjMygxLjAsIDEuMCwgMC4wKSA6XG4gIC8vICAgc2lkZU51bSA8IDQuMCA/IHZlYzMoMC4wLCAwLjAsIDEuMCkgOlxuICAvLyAgIHNpZGVOdW0gPCA1LjAgPyB2ZWMzKDAuMCwgMS4wLCAwLjApIDpcbiAgLy8gICB2ZWMzKDEuMCwgMC4wLCAxLjApO1xuICAvLyBnbF9GcmFnQ29sb3IueHl6ID0gbWl4KGdsX0ZyYWdDb2xvci54eXosIG1peENvbG9yLCAwLjUpO1xuICAvLyBgXG5cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgYmFzZU1hdGVyaWFsLFxuICAgICAge1xuICAgICAgICBjaGFpbmVkOiB0cnVlLFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHBvaW50QToge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSxcbiAgICAgICAgICBjb250cm9sQToge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSxcbiAgICAgICAgICBjb250cm9sQjoge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSxcbiAgICAgICAgICBwb2ludEI6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoKX0sXG4gICAgICAgICAgcmFkaXVzOiB7dmFsdWU6IDAuMDF9LFxuICAgICAgICAgIGRhc2hpbmc6IHt2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoKX0gLy9vbiwgb2ZmLCBvZmZzZXRcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGV4RGVmcyxcbiAgICAgICAgdmVydGV4VHJhbnNmb3JtLFxuICAgICAgICBmcmFnbWVudERlZnMsXG4gICAgICAgIGZyYWdtZW50TWFpbkludHJvXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbGV0IGdlb21ldHJ5ID0gbnVsbDtcblxuICBjb25zdCBkZWZhdWx0QmFzZU1hdGVyaWFsID0gLyojX19QVVJFX18qL25ldyB0aHJlZS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7Y29sb3I6IDB4ZmZmZmZmLCBzaWRlOiB0aHJlZS5Eb3VibGVTaWRlfSk7XG5cblxuICAvKipcbiAgICogQSBUaHJlZUpTIGBNZXNoYCB0aGF0IGJlbmRzIGEgdHViZSBzaGFwZSBhbG9uZyBhIDNEIGN1YmljIGJlemllciBwYXRoLiBUaGUgYmVuZGluZyBpcyBkb25lXG4gICAqIGJ5IGRlZm9ybWluZyBhIHN0cmFpZ2h0IGN5bGluZHJpY2FsIGdlb21ldHJ5IGluIHRoZSB2ZXJ0ZXggc2hhZGVyIGJhc2VkIG9uIGEgc2V0IG9mIGZvdXJcbiAgICogY29udHJvbCBwb2ludCB1bmlmb3Jtcy4gSXQgcGF0Y2hlcyB0aGUgbmVjZXNzYXJ5IEdMU0wgaW50byB0aGUgbWVzaCdzIGFzc2lnbmVkIGBtYXRlcmlhbGBcbiAgICogYXV0b21hdGljYWxseS5cbiAgICpcbiAgICogVGhlIGN1Yml6IGJlemllciBwYXRoIGlzIGRldGVybWluZWQgYnkgaXRzIGZvdXIgYFZlY3RvcjNgIHByb3BlcnRpZXM6XG4gICAqIC0gYHBvaW50QWBcbiAgICogLSBgY29udHJvbEFgXG4gICAqIC0gYGNvbnRyb2xCYFxuICAgKiAtIGBwb2ludEJgXG4gICAqXG4gICAqIFRoZSB0dWJlJ3MgcmFkaXVzIGlzIGNvbnRyb2xsZWQgYnkgaXRzIGByYWRpdXNgIHByb3BlcnR5LCB3aGljaCBkZWZhdWx0cyB0byBgMC4wMWAuXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBnaXZlIHRoZSB0dWJlIGEgZGFzaGVkIGFwcGVhcmFuY2Ugd2l0aCB0d28gcHJvcGVydGllczpcbiAgICpcbiAgICogLSBgZGFzaEFycmF5YCAtIGFuIGFycmF5IG9mIHR3byBudW1iZXJzLCBkZWZpbmluZyB0aGUgbGVuZ3RoIG9mIFwib25cIiBhbmQgXCJvZmZcIiBwYXJ0cyBvZlxuICAgKiAgIHRoZSBkYXNoLiBFYWNoIGlzIGEgMC0xIHJhdGlvIG9mIHRoZSBlbnRpcmUgcGF0aCdzIGxlbmd0aC4gKEFjdHVhbGx5IHRoaXMgaXMgdGhlIGB0YCBsZW5ndGhcbiAgICogICB1c2VkIGFzIGlucHV0IHRvIHRoZSBjdWJpYyBiZXppZXIgZnVuY3Rpb24sIG5vdCBpdHMgdmlzaWJsZSBsZW5ndGguKVxuICAgKiAtIGBkYXNoT2Zmc2V0YCAtIG9mZnNldCBvZiB3aGVyZSB0aGUgZGFzaCBzdGFydHMuIFlvdSBjYW4gYW5pbWF0ZSB0aGlzIHRvIG1ha2UgdGhlIGRhc2hlcyBtb3ZlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGRhc2hlcyB3aWxsIGFwcGVhciBsaWtlIGEgaG9sbG93IHR1YmUsIG5vdCBzb2xpZC4gVGhpcyB3aWxsIGJlIG1vcmUgYXBwYXJlbnQgb25cbiAgICogdGhpY2tlciB0dWJlcy5cbiAgICpcbiAgICogVE9ETzogcHJvcGVyIGdlb21ldHJ5IGJvdW5kaW5nIHNwaGVyZSBhbmQgcmF5Y2FzdGluZ1xuICAgKiBUT0RPOiBhbGxvdyBjb250cm9sIG9mIHRoZSBnZW9tZXRyeSdzIHNlZ21lbnQgY291bnRzXG4gICAqL1xuICBjbGFzcyBCZXppZXJNZXNoIGV4dGVuZHMgdGhyZWUuTWVzaCB7XG4gICAgc3RhdGljIGdldEdlb21ldHJ5KCkge1xuICAgICAgcmV0dXJuIGdlb21ldHJ5IHx8IChnZW9tZXRyeSA9XG4gICAgICAgIG5ldyB0aHJlZS5DeWxpbmRlckdlb21ldHJ5KDEsIDEsIDEsIDYsIDY0KS50cmFuc2xhdGUoMCwgMC41LCAwKVxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoXG4gICAgICAgIEJlemllck1lc2guZ2V0R2VvbWV0cnkoKSxcbiAgICAgICAgZGVmYXVsdEJhc2VNYXRlcmlhbFxuICAgICAgKTtcblxuICAgICAgdGhpcy5wb2ludEEgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICAgICAgdGhpcy5jb250cm9sQSA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgICB0aGlzLmNvbnRyb2xCID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgICAgIHRoaXMucG9pbnRCID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgICAgIHRoaXMucmFkaXVzID0gMC4wMTtcbiAgICAgIHRoaXMuZGFzaEFycmF5ID0gbmV3IHRocmVlLlZlY3RvcjIoKTtcbiAgICAgIHRoaXMuZGFzaE9mZnNldCA9IDA7XG5cbiAgICAgIC8vIFRPRE8gLSBkaXNhYmxpbmcgZnJ1c3R1bSBjdWxsaW5nIHVudGlsIEkgZmlndXJlIG91dCBob3cgdG8gY3VzdG9taXplIHRoZVxuICAgICAgLy8gIGdlb21ldHJ5J3MgYm91bmRpbmcgc3BoZXJlIHRoYXQgZ2V0cyB1c2VkXG4gICAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGVyIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIHRoZSBiYXNlIG1hdGVyaWFsIHdpdGggb3VyIHVwZ3JhZGVzLiBXZSBkbyB0aGUgd3JhcHBpbmdcbiAgICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gICAgZ2V0IG1hdGVyaWFsKCkge1xuICAgICAgbGV0IGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbDtcbiAgICAgIGNvbnN0IGJhc2VNYXRlcmlhbCA9IHRoaXMuX2Jhc2VNYXRlcmlhbCB8fCB0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgfHwgKHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRCYXNlTWF0ZXJpYWwuY2xvbmUoKSk7XG4gICAgICBpZiAoIWRlcml2ZWRNYXRlcmlhbCB8fCBkZXJpdmVkTWF0ZXJpYWwuYmFzZU1hdGVyaWFsICE9PSBiYXNlTWF0ZXJpYWwpIHtcbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsID0gY3JlYXRlQmV6aWVyTWVzaE1hdGVyaWFsKGJhc2VNYXRlcmlhbCk7XG4gICAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgICAgYmFzZU1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgICAgYmFzZU1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICAgIH1cbiAgICBzZXQgbWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuZCB1cGRhdGUgbWF0ZXJpYWwgZm9yIHNoYWRvd3MgdXBvbiByZXF1ZXN0OlxuICAgIGdldCBjdXN0b21EZXB0aE1hdGVyaWFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwuZ2V0RGVwdGhNYXRlcmlhbCgpXG4gICAgfVxuICAgIGdldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwuZ2V0RGlzdGFuY2VNYXRlcmlhbCgpXG4gICAgfVxuXG4gICAgb25CZWZvcmVSZW5kZXIoKSB7XG4gICAgICBjb25zdCB7dW5pZm9ybXN9ID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgIGNvbnN0IHtwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCByYWRpdXMsIGRhc2hBcnJheSwgZGFzaE9mZnNldH0gPSB0aGlzO1xuICAgICAgdW5pZm9ybXMucG9pbnRBLnZhbHVlLmNvcHkocG9pbnRBKTtcbiAgICAgIHVuaWZvcm1zLmNvbnRyb2xBLnZhbHVlLmNvcHkoY29udHJvbEEpO1xuICAgICAgdW5pZm9ybXMuY29udHJvbEIudmFsdWUuY29weShjb250cm9sQik7XG4gICAgICB1bmlmb3Jtcy5wb2ludEIudmFsdWUuY29weShwb2ludEIpO1xuICAgICAgdW5pZm9ybXMucmFkaXVzLnZhbHVlID0gcmFkaXVzO1xuICAgICAgdW5pZm9ybXMuZGFzaGluZy52YWx1ZS5zZXQoZGFzaEFycmF5LngsIGRhc2hBcnJheS55LCBkYXNoT2Zmc2V0IHx8IDApO1xuICAgIH1cblxuICAgIHJheWNhc3QoLypyYXljYXN0ZXIsIGludGVyc2VjdHMqLykge1xuICAgICAgLy8gVE9ETyAtIGp1c3QgZmFpbCBmb3Igbm93XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5CZXppZXJNZXNoID0gQmV6aWVyTWVzaDtcbiAgZXhwb3J0cy5jcmVhdGVEZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWw7XG4gIGV4cG9ydHMuZXhwYW5kU2hhZGVySW5jbHVkZXMgPSBleHBhbmRTaGFkZXJJbmNsdWRlcztcbiAgZXhwb3J0cy5nZXRTaGFkZXJVbmlmb3JtVHlwZXMgPSBnZXRTaGFkZXJVbmlmb3JtVHlwZXM7XG4gIGV4cG9ydHMuZ2V0U2hhZGVyc0Zvck1hdGVyaWFsID0gZ2V0U2hhZGVyc0Zvck1hdGVyaWFsO1xuICBleHBvcnRzLmludmVydE1hdHJpeDQgPSBpbnZlcnRNYXRyaXg0O1xuICBleHBvcnRzLnZvaWRNYWluUmVnRXhwID0gdm9pZE1haW5SZWdFeHA7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js\n");

/***/ })

};
;