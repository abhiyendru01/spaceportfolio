/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@use-gesture";
exports.ids = ["vendor-chunks/@use-gesture"];
exports.modules = {

/***/ "(ssr)/./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConfigResolverMap: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   EngineMap: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   dragAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   hoverAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   moveAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   pinchAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   registerAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   scrollAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   wheelAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)\n/* harmony export */ });\n/* harmony import */ var _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/actions-fe213e88.esm.js */ \"(ssr)/./node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvYWN0aW9ucy9kaXN0L3VzZS1nZXN0dXJlLWNvcmUtYWN0aW9ucy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE0TjtBQUNsTCIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYWNlcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0B1c2UtZ2VzdHVyZS9jb3JlL2FjdGlvbnMvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLWFjdGlvbnMuZXNtLmpzPzMzOTIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQyBhcyBDb25maWdSZXNvbHZlck1hcCwgRSBhcyBFbmdpbmVNYXAsIGUgYXMgZHJhZ0FjdGlvbiwgaCBhcyBob3ZlckFjdGlvbiwgbSBhcyBtb3ZlQWN0aW9uLCBmIGFzIHBpbmNoQWN0aW9uLCByIGFzIHJlZ2lzdGVyQWN0aW9uLCBzIGFzIHNjcm9sbEFjdGlvbiwgdyBhcyB3aGVlbEFjdGlvbiB9IGZyb20gJy4uLy4uL2Rpc3QvYWN0aW9ucy1mZTIxM2U4OC5lc20uanMnO1xuaW1wb3J0ICcuLi8uLi9kaXN0L21hdGhzLTBhYjM5YWU5LmVzbS5qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ ConfigResolverMap),\n/* harmony export */   E: () => (/* binding */ EngineMap),\n/* harmony export */   S: () => (/* binding */ SUPPORT),\n/* harmony export */   _: () => (/* binding */ _objectSpread2),\n/* harmony export */   a: () => (/* binding */ _defineProperty),\n/* harmony export */   b: () => (/* binding */ touchIds),\n/* harmony export */   c: () => (/* binding */ chain),\n/* harmony export */   d: () => (/* binding */ toHandlerProp),\n/* harmony export */   e: () => (/* binding */ dragAction),\n/* harmony export */   f: () => (/* binding */ pinchAction),\n/* harmony export */   h: () => (/* binding */ hoverAction),\n/* harmony export */   i: () => (/* binding */ isTouch),\n/* harmony export */   m: () => (/* binding */ moveAction),\n/* harmony export */   p: () => (/* binding */ parseProp),\n/* harmony export */   r: () => (/* binding */ registerAction),\n/* harmony export */   s: () => (/* binding */ scrollAction),\n/* harmony export */   t: () => (/* binding */ toDomEventType),\n/* harmony export */   w: () => (/* binding */ wheelAction)\n/* harmony export */ });\n/* harmony import */ var _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./maths-0ab39ae9.esm.js */ \"(ssr)/./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js\");\n\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\nconst actionsWithoutCaptureSupported = ['enter', 'leave'];\nfunction hasCapture(capture = false, actionKey) {\n  return capture && !actionsWithoutCaptureSupported.includes(actionKey);\n}\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? 'Capture' : '');\n}\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event)) return 'touch';\n  if ('pointerType' in event) return event.pointerType;\n  return 'mouse';\n}\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\nfunction distanceAngle(P1, P2) {\n  try {\n    const dx = P2.clientX - P1.clientX;\n    const dy = P2.clientY - P1.clientY;\n    const cx = (P2.clientX + P1.clientX) / 2;\n    const cy = (P2.clientY + P1.clientY) / 2;\n    const distance = Math.hypot(dx, dy);\n    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n    const origin = [cx, cy];\n    return {\n      angle,\n      distance,\n      origin\n    };\n  } catch (_unused) {}\n  return null;\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nconst BEFORE_LAST_KINEMATICS_DELAY = 32;\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = state.timeDelta = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n      state.startTime = state.timeStamp = event.timeStamp;\n    }\n  }\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable) state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._distance, _absoluteDelta);\n    }\n    if (this.axisIntent) this.axisIntent(event);\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n    if (config.hasCustomTransform) {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional) return;\n    const movement = [0, 0];\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = (0,_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(state._bounds, state.offset, rubberband);\n    state.delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state.offset, previousOffset);\n    this.computeMovement();\n    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n      if (!state.first && dt > 0) {\n        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n        state.timeDelta = dt;\n      }\n    }\n  }\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n}\n\nfunction selectAxis([dx, dy], threshold) {\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n  if (absDx > absDy && absDx > threshold) {\n    return 'x';\n  }\n  if (absDy > absDx && absDy > threshold) {\n    return 'y';\n  }\n  return undefined;\n}\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n  computeOffset() {\n    this.state.offset = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.add(this.state.lastOffset, this.state.movement);\n  }\n  computeMovement() {\n    this.state.movement = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(this.state.offset, this.state.lastOffset);\n  }\n  axisIntent(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state.axis && event) {\n      const threshold = typeof config.axisThreshold === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n      state.axis = selectAxis(state._movement, threshold);\n    }\n    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n  }\n  restrictToAxis(v) {\n    if (this.config.axis || this.config.lockDirection) {\n      switch (this.state.axis) {\n        case 'x':\n          v[1] = 0;\n          break;\n        case 'y':\n          v[0] = 0;\n          break;\n      }\n    }\n  }\n}\n\nconst identity = v => v;\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n  eventOptions(value, _k, config) {\n    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);\n  },\n  preventDefault(value = false) {\n    return value;\n  },\n  triggerAllEvents(value = false) {\n    return value;\n  },\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n      case false:\n        return [0, 0];\n      default:\n        return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value);\n    }\n  },\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value);\n  },\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n    if (true) {\n      const originalTransform = transform || identity;\n      return v => {\n        const r = originalTransform(v);\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);\n        }\n        return r;\n      };\n    }\n    return transform || identity;\n  },\n  threshold(value) {\n    return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, 0);\n  }\n};\nif (true) {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n      return NaN;\n    },\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n      return NaN;\n    },\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\n\nconst DEFAULT_AXIS_THRESHOLD = 0;\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {\n    return value;\n  },\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n    if ('current' in value) {\n      return () => value.current;\n    }\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n});\n\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],\n  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],\n  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],\n  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n  setup() {\n    const state = this.state;\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n    const ctrlIds = this.ctrl.setEventIds(event);\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n    if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n      if (config.triggerAllEvents) {\n        this.compute(event);\n        this.emit();\n      }\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    const _values = pointerValues(event);\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    this.compute(event);\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove('dragDelay');\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n    this.emit();\n  }\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (true) {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [_dx, _dy] = state._delta;\n      const [_mx, _my] = state._movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n      if (state.elapsedTime < sdt) {\n        const _vx = Math.abs(_dx / state.timeDelta);\n        const _vy = Math.abs(_dy / state.timeDelta);\n        if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);\n        if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);\n      }\n    }\n    this.emit();\n  }\n  pointerClick(event) {\n    if (!this.state.tap && event.detail > 0) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n    if (true) {\n      try {\n        if (device === 'pointer' && config.preventScrollDelay === undefined) {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n    }\n  }\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n  setupScrollPrevention(event) {\n    this.state._preventScroll = false;\n    persistEvent(event);\n    const remove = this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', remove);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', remove);\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      this.start(event);\n      state._delta = deltaFn(this.config.keyboardDisplacement, factor);\n      state._keyboardActive = true;\n      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n    }\n    if (this.config.keys) {\n      bindFunction('key', 'down', this.keyDown.bind(this));\n      bindFunction('key', 'up', this.keyUp.bind(this));\n    }\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n}\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: supportsTouchEvents(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst DEFAULT_KEYBOARD_DISPLACEMENT = 10;\nconst DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1,\n      keys = true\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    this.keys = keys;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = undefined\n  }) {\n    const threshold = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(velocity)),\n      distance: this.transform(_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(distance)),\n      duration\n    };\n  },\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n      case false:\n        return 0;\n      default:\n        return value;\n    }\n  },\n  axisThreshold(value) {\n    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  },\n  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {\n    return value;\n  }\n});\nif (true) {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n      return NaN;\n    },\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n      return NaN;\n    },\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\n\nfunction clampStateInternalMovementToBounds(state) {\n  const [ox, oy] = state.overflow;\n  const [dx, dy] = state._delta;\n  const [dirx, diry] = state._direction;\n  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n    state._movement[0] = state._movementBound[0];\n  }\n  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n    state._movement[1] = state._movementBound[1];\n  }\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 100;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'pinching');\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n    if (type === 'wheel') {\n      this.state.offset = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n  axisIntent() {\n    const state = this.state;\n    const [_m0, _m1] = state._movement;\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n  }\n  restrictToAxis(v) {\n    if (this.config.lockDirection) {\n      if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    if (!payload) return;\n    this.pinchStart(event, payload);\n  }\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    if (!payload) return;\n    this.pinchStart(event, payload);\n  }\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    if (!payload) return;\n    this.pinchMove(event, payload);\n  }\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    if (!payload) return;\n    this.pinchMove(event, payload);\n  }\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n    if (!state._active) return;\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  wheel(event) {\n    const modifierKey = this.config.modifierKey;\n    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find(k => event[k]) : !event[modifierKey])) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if ( true && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n      bindFunction('lostPointerCapture', '', this[device + 'End'].bind(this));\n    }\n    if (this.config.pinchOnWheel) {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n  modifierKey(value) {\n    if (value === undefined) return 'ctrlKey';\n    return value;\n  },\n  pinchOnWheel(value = true) {\n    return value;\n  }\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC9hY3Rpb25zLWZlMjEzZTg4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBaUI7QUFDcEMsa0JBQWtCLHFEQUFDO0FBQ25CO0FBQ0E7QUFDQSxvQkFBb0IscURBQUM7QUFDckI7QUFDQSxNQUFNLHFEQUFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxxQkFBcUI7QUFDbEc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQUM7QUFDekI7QUFDQTtBQUNBLDBCQUEwQixxREFBQztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwyQ0FBMkM7QUFDM0MsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUM7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixxREFBQztBQUMvQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxLQUFLLEdBQUcsSUFBSTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyxxREFBQztBQUNaO0FBQ0E7QUFDQSxJQUFJLElBQXNDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEdBQThHLGNBQWM7QUFDNUg7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxrRUFBa0UsMkJBQTJCO0FBQzdGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQkFBcUIscURBQUM7QUFDdEI7QUFDQTtBQUNBLElBQUkscURBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxJQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0NBQWdDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLHFEQUFDO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0EsK0JBQStCLHFEQUFDO0FBQ2hDLCtCQUErQixxREFBQztBQUNoQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsSUFBSSxJQUFzQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsV0FBVyxlQUFlO0FBQzNJO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUhBQXVILFNBQVMsaUJBQWlCO0FBQ2pKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVIQUF1SCxTQUFTLGdCQUFnQjtBQUNoSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1SEFBdUgsU0FBUyxpQkFBaUI7QUFDako7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDBCQUEwQixxREFBQztBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQsMkJBQTJCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixxREFBQztBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBQztBQUNwQixJQUFJLHFEQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEyRCxnQ0FBZ0M7QUFDM0Y7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUM7QUFDcEIsSUFBSSxxREFBQztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscURBQUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTRELGdDQUFnQztBQUM1RjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2VSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYWNlcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0B1c2UtZ2VzdHVyZS9jb3JlL2Rpc3QvYWN0aW9ucy1mZTIxM2U4OC5lc20uanM/YTQzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWLCBjIGFzIGNvbXB1dGVSdWJiZXJiYW5kIH0gZnJvbSAnLi9tYXRocy0wYWIzOWFlOS5lc20uanMnO1xuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuY29uc3QgRVZFTlRfVFlQRV9NQVAgPSB7XG4gIHBvaW50ZXI6IHtcbiAgICBzdGFydDogJ2Rvd24nLFxuICAgIGNoYW5nZTogJ21vdmUnLFxuICAgIGVuZDogJ3VwJ1xuICB9LFxuICBtb3VzZToge1xuICAgIHN0YXJ0OiAnZG93bicsXG4gICAgY2hhbmdlOiAnbW92ZScsXG4gICAgZW5kOiAndXAnXG4gIH0sXG4gIHRvdWNoOiB7XG4gICAgc3RhcnQ6ICdzdGFydCcsXG4gICAgY2hhbmdlOiAnbW92ZScsXG4gICAgZW5kOiAnZW5kJ1xuICB9LFxuICBnZXN0dXJlOiB7XG4gICAgc3RhcnQ6ICdzdGFydCcsXG4gICAgY2hhbmdlOiAnY2hhbmdlJyxcbiAgICBlbmQ6ICdlbmQnXG4gIH1cbn07XG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICBpZiAoIXN0cmluZykgcmV0dXJuICcnO1xuICByZXR1cm4gc3RyaW5nWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5jb25zdCBhY3Rpb25zV2l0aG91dENhcHR1cmVTdXBwb3J0ZWQgPSBbJ2VudGVyJywgJ2xlYXZlJ107XG5mdW5jdGlvbiBoYXNDYXB0dXJlKGNhcHR1cmUgPSBmYWxzZSwgYWN0aW9uS2V5KSB7XG4gIHJldHVybiBjYXB0dXJlICYmICFhY3Rpb25zV2l0aG91dENhcHR1cmVTdXBwb3J0ZWQuaW5jbHVkZXMoYWN0aW9uS2V5KTtcbn1cbmZ1bmN0aW9uIHRvSGFuZGxlclByb3AoZGV2aWNlLCBhY3Rpb24gPSAnJywgY2FwdHVyZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGRldmljZVByb3BzID0gRVZFTlRfVFlQRV9NQVBbZGV2aWNlXTtcbiAgY29uc3QgYWN0aW9uS2V5ID0gZGV2aWNlUHJvcHMgPyBkZXZpY2VQcm9wc1thY3Rpb25dIHx8IGFjdGlvbiA6IGFjdGlvbjtcbiAgcmV0dXJuICdvbicgKyBjYXBpdGFsaXplKGRldmljZSkgKyBjYXBpdGFsaXplKGFjdGlvbktleSkgKyAoaGFzQ2FwdHVyZShjYXB0dXJlLCBhY3Rpb25LZXkpID8gJ0NhcHR1cmUnIDogJycpO1xufVxuY29uc3QgcG9pbnRlckNhcHR1cmVFdmVudHMgPSBbJ2dvdHBvaW50ZXJjYXB0dXJlJywgJ2xvc3Rwb2ludGVyY2FwdHVyZSddO1xuZnVuY3Rpb24gcGFyc2VQcm9wKHByb3ApIHtcbiAgbGV0IGV2ZW50S2V5ID0gcHJvcC5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgcGFzc2l2ZSA9ICEhfmV2ZW50S2V5LmluZGV4T2YoJ3Bhc3NpdmUnKTtcbiAgaWYgKHBhc3NpdmUpIGV2ZW50S2V5ID0gZXZlbnRLZXkucmVwbGFjZSgncGFzc2l2ZScsICcnKTtcbiAgY29uc3QgY2FwdHVyZUtleSA9IHBvaW50ZXJDYXB0dXJlRXZlbnRzLmluY2x1ZGVzKGV2ZW50S2V5KSA/ICdjYXB0dXJlY2FwdHVyZScgOiAnY2FwdHVyZSc7XG4gIGNvbnN0IGNhcHR1cmUgPSAhIX5ldmVudEtleS5pbmRleE9mKGNhcHR1cmVLZXkpO1xuICBpZiAoY2FwdHVyZSkgZXZlbnRLZXkgPSBldmVudEtleS5yZXBsYWNlKCdjYXB0dXJlJywgJycpO1xuICByZXR1cm4ge1xuICAgIGRldmljZTogZXZlbnRLZXksXG4gICAgY2FwdHVyZSxcbiAgICBwYXNzaXZlXG4gIH07XG59XG5mdW5jdGlvbiB0b0RvbUV2ZW50VHlwZShkZXZpY2UsIGFjdGlvbiA9ICcnKSB7XG4gIGNvbnN0IGRldmljZVByb3BzID0gRVZFTlRfVFlQRV9NQVBbZGV2aWNlXTtcbiAgY29uc3QgYWN0aW9uS2V5ID0gZGV2aWNlUHJvcHMgPyBkZXZpY2VQcm9wc1thY3Rpb25dIHx8IGFjdGlvbiA6IGFjdGlvbjtcbiAgcmV0dXJuIGRldmljZSArIGFjdGlvbktleTtcbn1cbmZ1bmN0aW9uIGlzVG91Y2goZXZlbnQpIHtcbiAgcmV0dXJuICd0b3VjaGVzJyBpbiBldmVudDtcbn1cbmZ1bmN0aW9uIGdldFBvaW50ZXJUeXBlKGV2ZW50KSB7XG4gIGlmIChpc1RvdWNoKGV2ZW50KSkgcmV0dXJuICd0b3VjaCc7XG4gIGlmICgncG9pbnRlclR5cGUnIGluIGV2ZW50KSByZXR1cm4gZXZlbnQucG9pbnRlclR5cGU7XG4gIHJldHVybiAnbW91c2UnO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRhcmdldFRvdWNoTGlzdChldmVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShldmVudC50b3VjaGVzKS5maWx0ZXIoZSA9PiB7XG4gICAgdmFyIF9ldmVudCRjdXJyZW50VGFyZ2V0LCBfZXZlbnQkY3VycmVudFRhcmdldCQ7XG4gICAgcmV0dXJuIGUudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0IHx8ICgoX2V2ZW50JGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0KSA9PT0gbnVsbCB8fCBfZXZlbnQkY3VycmVudFRhcmdldCA9PT0gdm9pZCAwIHx8IChfZXZlbnQkY3VycmVudFRhcmdldCQgPSBfZXZlbnQkY3VycmVudFRhcmdldC5jb250YWlucykgPT09IG51bGwgfHwgX2V2ZW50JGN1cnJlbnRUYXJnZXQkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXZlbnQkY3VycmVudFRhcmdldCQuY2FsbChfZXZlbnQkY3VycmVudFRhcmdldCwgZS50YXJnZXQpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUb3VjaExpc3QoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICd0b3VjaGVuZCcgfHwgZXZlbnQudHlwZSA9PT0gJ3RvdWNoY2FuY2VsJyA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzIDogZXZlbnQudGFyZ2V0VG91Y2hlcztcbn1cbmZ1bmN0aW9uIGdldFZhbHVlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGlzVG91Y2goZXZlbnQpID8gZ2V0VG91Y2hMaXN0KGV2ZW50KVswXSA6IGV2ZW50O1xufVxuZnVuY3Rpb24gZGlzdGFuY2VBbmdsZShQMSwgUDIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkeCA9IFAyLmNsaWVudFggLSBQMS5jbGllbnRYO1xuICAgIGNvbnN0IGR5ID0gUDIuY2xpZW50WSAtIFAxLmNsaWVudFk7XG4gICAgY29uc3QgY3ggPSAoUDIuY2xpZW50WCArIFAxLmNsaWVudFgpIC8gMjtcbiAgICBjb25zdCBjeSA9IChQMi5jbGllbnRZICsgUDEuY2xpZW50WSkgLyAyO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5oeXBvdChkeCwgZHkpO1xuICAgIGNvbnN0IGFuZ2xlID0gLShNYXRoLmF0YW4yKGR4LCBkeSkgKiAxODApIC8gTWF0aC5QSTtcbiAgICBjb25zdCBvcmlnaW4gPSBbY3gsIGN5XTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5nbGUsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIG9yaWdpblxuICAgIH07XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHt9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdG91Y2hJZHMoZXZlbnQpIHtcbiAgcmV0dXJuIGdldEN1cnJlbnRUYXJnZXRUb3VjaExpc3QoZXZlbnQpLm1hcCh0b3VjaCA9PiB0b3VjaC5pZGVudGlmaWVyKTtcbn1cbmZ1bmN0aW9uIHRvdWNoRGlzdGFuY2VBbmdsZShldmVudCwgaWRzKSB7XG4gIGNvbnN0IFtQMSwgUDJdID0gQXJyYXkuZnJvbShldmVudC50b3VjaGVzKS5maWx0ZXIodG91Y2ggPT4gaWRzLmluY2x1ZGVzKHRvdWNoLmlkZW50aWZpZXIpKTtcbiAgcmV0dXJuIGRpc3RhbmNlQW5nbGUoUDEsIFAyKTtcbn1cbmZ1bmN0aW9uIHBvaW50ZXJJZChldmVudCkge1xuICBjb25zdCB2YWx1ZUV2ZW50ID0gZ2V0VmFsdWVFdmVudChldmVudCk7XG4gIHJldHVybiBpc1RvdWNoKGV2ZW50KSA/IHZhbHVlRXZlbnQuaWRlbnRpZmllciA6IHZhbHVlRXZlbnQucG9pbnRlcklkO1xufVxuZnVuY3Rpb24gcG9pbnRlclZhbHVlcyhldmVudCkge1xuICBjb25zdCB2YWx1ZUV2ZW50ID0gZ2V0VmFsdWVFdmVudChldmVudCk7XG4gIHJldHVybiBbdmFsdWVFdmVudC5jbGllbnRYLCB2YWx1ZUV2ZW50LmNsaWVudFldO1xufVxuY29uc3QgTElORV9IRUlHSFQgPSA0MDtcbmNvbnN0IFBBR0VfSEVJR0hUID0gODAwO1xuZnVuY3Rpb24gd2hlZWxWYWx1ZXMoZXZlbnQpIHtcbiAgbGV0IHtcbiAgICBkZWx0YVgsXG4gICAgZGVsdGFZLFxuICAgIGRlbHRhTW9kZVxuICB9ID0gZXZlbnQ7XG4gIGlmIChkZWx0YU1vZGUgPT09IDEpIHtcbiAgICBkZWx0YVggKj0gTElORV9IRUlHSFQ7XG4gICAgZGVsdGFZICo9IExJTkVfSEVJR0hUO1xuICB9IGVsc2UgaWYgKGRlbHRhTW9kZSA9PT0gMikge1xuICAgIGRlbHRhWCAqPSBQQUdFX0hFSUdIVDtcbiAgICBkZWx0YVkgKj0gUEFHRV9IRUlHSFQ7XG4gIH1cbiAgcmV0dXJuIFtkZWx0YVgsIGRlbHRhWV07XG59XG5mdW5jdGlvbiBzY3JvbGxWYWx1ZXMoZXZlbnQpIHtcbiAgdmFyIF9yZWYsIF9yZWYyO1xuICBjb25zdCB7XG4gICAgc2Nyb2xsWCxcbiAgICBzY3JvbGxZLFxuICAgIHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wXG4gIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICByZXR1cm4gWyhfcmVmID0gc2Nyb2xsWCAhPT0gbnVsbCAmJiBzY3JvbGxYICE9PSB2b2lkIDAgPyBzY3JvbGxYIDogc2Nyb2xsTGVmdCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IDAsIChfcmVmMiA9IHNjcm9sbFkgIT09IG51bGwgJiYgc2Nyb2xsWSAhPT0gdm9pZCAwID8gc2Nyb2xsWSA6IHNjcm9sbFRvcCkgIT09IG51bGwgJiYgX3JlZjIgIT09IHZvaWQgMCA/IF9yZWYyIDogMF07XG59XG5mdW5jdGlvbiBnZXRFdmVudERldGFpbHMoZXZlbnQpIHtcbiAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICBpZiAoJ2J1dHRvbnMnIGluIGV2ZW50KSBwYXlsb2FkLmJ1dHRvbnMgPSBldmVudC5idXR0b25zO1xuICBpZiAoJ3NoaWZ0S2V5JyBpbiBldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNoaWZ0S2V5LFxuICAgICAgYWx0S2V5LFxuICAgICAgbWV0YUtleSxcbiAgICAgIGN0cmxLZXlcbiAgICB9ID0gZXZlbnQ7XG4gICAgT2JqZWN0LmFzc2lnbihwYXlsb2FkLCB7XG4gICAgICBzaGlmdEtleSxcbiAgICAgIGFsdEtleSxcbiAgICAgIG1ldGFLZXksXG4gICAgICBjdHJsS2V5XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBheWxvYWQ7XG59XG5cbmZ1bmN0aW9uIGNhbGwodiwgLi4uYXJncykge1xuICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdiguLi5hcmdzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdjtcbiAgfVxufVxuZnVuY3Rpb24gbm9vcCgpIHt9XG5mdW5jdGlvbiBjaGFpbiguLi5mbnMpIHtcbiAgaWYgKGZucy5sZW5ndGggPT09IDApIHJldHVybiBub29wO1xuICBpZiAoZm5zLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGZuc1swXTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG4gICAgICByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHQodmFsdWUsIGZhbGxiYWNrKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBmYWxsYmFjaywgdmFsdWUgfHwge30pO1xufVxuXG5jb25zdCBCRUZPUkVfTEFTVF9LSU5FTUFUSUNTX0RFTEFZID0gMzI7XG5jbGFzcyBFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihjdHJsLCBhcmdzLCBrZXkpIHtcbiAgICB0aGlzLmN0cmwgPSBjdHJsO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgaWYgKCF0aGlzLnN0YXRlKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICB0aGlzLmNvbXB1dGVWYWx1ZXMoWzAsIDBdKTtcbiAgICAgIHRoaXMuY29tcHV0ZUluaXRpYWwoKTtcbiAgICAgIGlmICh0aGlzLmluaXQpIHRoaXMuaW5pdCgpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgfVxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3RybC5zdGF0ZVt0aGlzLmtleV07XG4gIH1cbiAgc2V0IHN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5jdHJsLnN0YXRlW3RoaXMua2V5XSA9IHN0YXRlO1xuICB9XG4gIGdldCBzaGFyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3RybC5zdGF0ZS5zaGFyZWQ7XG4gIH1cbiAgZ2V0IGV2ZW50U3RvcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3RybC5nZXN0dXJlRXZlbnRTdG9yZXNbdGhpcy5rZXldO1xuICB9XG4gIGdldCB0aW1lb3V0U3RvcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3RybC5nZXN0dXJlVGltZW91dFN0b3Jlc1t0aGlzLmtleV07XG4gIH1cbiAgZ2V0IGNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jdHJsLmNvbmZpZ1t0aGlzLmtleV07XG4gIH1cbiAgZ2V0IHNoYXJlZENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jdHJsLmNvbmZpZy5zaGFyZWQ7XG4gIH1cbiAgZ2V0IGhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3RybC5oYW5kbGVyc1t0aGlzLmtleV07XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhdGUsXG4gICAgICBzaGFyZWQsXG4gICAgICBpbmdLZXksXG4gICAgICBhcmdzXG4gICAgfSA9IHRoaXM7XG4gICAgc2hhcmVkW2luZ0tleV0gPSBzdGF0ZS5fYWN0aXZlID0gc3RhdGUuYWN0aXZlID0gc3RhdGUuX2Jsb2NrZWQgPSBzdGF0ZS5fZm9yY2UgPSBmYWxzZTtcbiAgICBzdGF0ZS5fc3RlcCA9IFtmYWxzZSwgZmFsc2VdO1xuICAgIHN0YXRlLmludGVudGlvbmFsID0gZmFsc2U7XG4gICAgc3RhdGUuX21vdmVtZW50ID0gWzAsIDBdO1xuICAgIHN0YXRlLl9kaXN0YW5jZSA9IFswLCAwXTtcbiAgICBzdGF0ZS5fZGlyZWN0aW9uID0gWzAsIDBdO1xuICAgIHN0YXRlLl9kZWx0YSA9IFswLCAwXTtcbiAgICBzdGF0ZS5fYm91bmRzID0gW1stSW5maW5pdHksIEluZmluaXR5XSwgWy1JbmZpbml0eSwgSW5maW5pdHldXTtcbiAgICBzdGF0ZS5hcmdzID0gYXJncztcbiAgICBzdGF0ZS5heGlzID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLm1lbW8gPSB1bmRlZmluZWQ7XG4gICAgc3RhdGUuZWxhcHNlZFRpbWUgPSBzdGF0ZS50aW1lRGVsdGEgPSAwO1xuICAgIHN0YXRlLmRpcmVjdGlvbiA9IFswLCAwXTtcbiAgICBzdGF0ZS5kaXN0YW5jZSA9IFswLCAwXTtcbiAgICBzdGF0ZS5vdmVyZmxvdyA9IFswLCAwXTtcbiAgICBzdGF0ZS5fbW92ZW1lbnRCb3VuZCA9IFtmYWxzZSwgZmFsc2VdO1xuICAgIHN0YXRlLnZlbG9jaXR5ID0gWzAsIDBdO1xuICAgIHN0YXRlLm1vdmVtZW50ID0gWzAsIDBdO1xuICAgIHN0YXRlLmRlbHRhID0gWzAsIDBdO1xuICAgIHN0YXRlLnRpbWVTdGFtcCA9IDA7XG4gIH1cbiAgc3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCFzdGF0ZS5fYWN0aXZlKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLmNvbXB1dGVJbml0aWFsKCk7XG4gICAgICBzdGF0ZS5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIHN0YXRlLmN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgc3RhdGUubGFzdE9mZnNldCA9IGNvbmZpZy5mcm9tID8gY2FsbChjb25maWcuZnJvbSwgc3RhdGUpIDogc3RhdGUub2Zmc2V0O1xuICAgICAgc3RhdGUub2Zmc2V0ID0gc3RhdGUubGFzdE9mZnNldDtcbiAgICAgIHN0YXRlLnN0YXJ0VGltZSA9IHN0YXRlLnRpbWVTdGFtcCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZVZhbHVlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3RhdGUuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICBzdGF0ZS52YWx1ZXMgPSB0aGlzLmNvbmZpZy50cmFuc2Zvcm0odmFsdWVzKTtcbiAgfVxuICBjb21wdXRlSW5pdGlhbCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3RhdGUuX2luaXRpYWwgPSBzdGF0ZS5fdmFsdWVzO1xuICAgIHN0YXRlLmluaXRpYWwgPSBzdGF0ZS52YWx1ZXM7XG4gIH1cbiAgY29tcHV0ZShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlLFxuICAgICAgY29uZmlnLFxuICAgICAgc2hhcmVkXG4gICAgfSA9IHRoaXM7XG4gICAgc3RhdGUuYXJncyA9IHRoaXMuYXJncztcbiAgICBsZXQgZHQgPSAwO1xuICAgIGlmIChldmVudCkge1xuICAgICAgc3RhdGUuZXZlbnQgPSBldmVudDtcbiAgICAgIGlmIChjb25maWcucHJldmVudERlZmF1bHQgJiYgZXZlbnQuY2FuY2VsYWJsZSkgc3RhdGUuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHN0YXRlLnR5cGUgPSBldmVudC50eXBlO1xuICAgICAgc2hhcmVkLnRvdWNoZXMgPSB0aGlzLmN0cmwucG9pbnRlcklkcy5zaXplIHx8IHRoaXMuY3RybC50b3VjaElkcy5zaXplO1xuICAgICAgc2hhcmVkLmxvY2tlZCA9ICEhZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50O1xuICAgICAgT2JqZWN0LmFzc2lnbihzaGFyZWQsIGdldEV2ZW50RGV0YWlscyhldmVudCkpO1xuICAgICAgc2hhcmVkLmRvd24gPSBzaGFyZWQucHJlc3NlZCA9IHNoYXJlZC5idXR0b25zICUgMiA9PT0gMSB8fCBzaGFyZWQudG91Y2hlcyA+IDA7XG4gICAgICBkdCA9IGV2ZW50LnRpbWVTdGFtcCAtIHN0YXRlLnRpbWVTdGFtcDtcbiAgICAgIHN0YXRlLnRpbWVTdGFtcCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICAgIHN0YXRlLmVsYXBzZWRUaW1lID0gc3RhdGUudGltZVN0YW1wIC0gc3RhdGUuc3RhcnRUaW1lO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuX2FjdGl2ZSkge1xuICAgICAgY29uc3QgX2Fic29sdXRlRGVsdGEgPSBzdGF0ZS5fZGVsdGEubWFwKE1hdGguYWJzKTtcbiAgICAgIFYuYWRkVG8oc3RhdGUuX2Rpc3RhbmNlLCBfYWJzb2x1dGVEZWx0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF4aXNJbnRlbnQpIHRoaXMuYXhpc0ludGVudChldmVudCk7XG4gICAgY29uc3QgW19tMCwgX20xXSA9IHN0YXRlLl9tb3ZlbWVudDtcbiAgICBjb25zdCBbdDAsIHQxXSA9IGNvbmZpZy50aHJlc2hvbGQ7XG4gICAgY29uc3Qge1xuICAgICAgX3N0ZXAsXG4gICAgICB2YWx1ZXNcbiAgICB9ID0gc3RhdGU7XG4gICAgaWYgKGNvbmZpZy5oYXNDdXN0b21UcmFuc2Zvcm0pIHtcbiAgICAgIGlmIChfc3RlcFswXSA9PT0gZmFsc2UpIF9zdGVwWzBdID0gTWF0aC5hYnMoX20wKSA+PSB0MCAmJiB2YWx1ZXNbMF07XG4gICAgICBpZiAoX3N0ZXBbMV0gPT09IGZhbHNlKSBfc3RlcFsxXSA9IE1hdGguYWJzKF9tMSkgPj0gdDEgJiYgdmFsdWVzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoX3N0ZXBbMF0gPT09IGZhbHNlKSBfc3RlcFswXSA9IE1hdGguYWJzKF9tMCkgPj0gdDAgJiYgTWF0aC5zaWduKF9tMCkgKiB0MDtcbiAgICAgIGlmIChfc3RlcFsxXSA9PT0gZmFsc2UpIF9zdGVwWzFdID0gTWF0aC5hYnMoX20xKSA+PSB0MSAmJiBNYXRoLnNpZ24oX20xKSAqIHQxO1xuICAgIH1cbiAgICBzdGF0ZS5pbnRlbnRpb25hbCA9IF9zdGVwWzBdICE9PSBmYWxzZSB8fCBfc3RlcFsxXSAhPT0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5pbnRlbnRpb25hbCkgcmV0dXJuO1xuICAgIGNvbnN0IG1vdmVtZW50ID0gWzAsIDBdO1xuICAgIGlmIChjb25maWcuaGFzQ3VzdG9tVHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCBbdjAsIHYxXSA9IHZhbHVlcztcbiAgICAgIG1vdmVtZW50WzBdID0gX3N0ZXBbMF0gIT09IGZhbHNlID8gdjAgLSBfc3RlcFswXSA6IDA7XG4gICAgICBtb3ZlbWVudFsxXSA9IF9zdGVwWzFdICE9PSBmYWxzZSA/IHYxIC0gX3N0ZXBbMV0gOiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3ZlbWVudFswXSA9IF9zdGVwWzBdICE9PSBmYWxzZSA/IF9tMCAtIF9zdGVwWzBdIDogMDtcbiAgICAgIG1vdmVtZW50WzFdID0gX3N0ZXBbMV0gIT09IGZhbHNlID8gX20xIC0gX3N0ZXBbMV0gOiAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXN0cmljdFRvQXhpcyAmJiAhc3RhdGUuX2Jsb2NrZWQpIHRoaXMucmVzdHJpY3RUb0F4aXMobW92ZW1lbnQpO1xuICAgIGNvbnN0IHByZXZpb3VzT2Zmc2V0ID0gc3RhdGUub2Zmc2V0O1xuICAgIGNvbnN0IGdlc3R1cmVJc0FjdGl2ZSA9IHN0YXRlLl9hY3RpdmUgJiYgIXN0YXRlLl9ibG9ja2VkIHx8IHN0YXRlLmFjdGl2ZTtcbiAgICBpZiAoZ2VzdHVyZUlzQWN0aXZlKSB7XG4gICAgICBzdGF0ZS5maXJzdCA9IHN0YXRlLl9hY3RpdmUgJiYgIXN0YXRlLmFjdGl2ZTtcbiAgICAgIHN0YXRlLmxhc3QgPSAhc3RhdGUuX2FjdGl2ZSAmJiBzdGF0ZS5hY3RpdmU7XG4gICAgICBzdGF0ZS5hY3RpdmUgPSBzaGFyZWRbdGhpcy5pbmdLZXldID0gc3RhdGUuX2FjdGl2ZTtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBpZiAoc3RhdGUuZmlyc3QpIHtcbiAgICAgICAgICBpZiAoJ2JvdW5kcycgaW4gY29uZmlnKSBzdGF0ZS5fYm91bmRzID0gY2FsbChjb25maWcuYm91bmRzLCBzdGF0ZSk7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0dXApIHRoaXMuc2V0dXAoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb3ZlbWVudCA9IG1vdmVtZW50O1xuICAgICAgICB0aGlzLmNvbXB1dGVPZmZzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW294LCBveV0gPSBzdGF0ZS5vZmZzZXQ7XG4gICAgY29uc3QgW1t4MCwgeDFdLCBbeTAsIHkxXV0gPSBzdGF0ZS5fYm91bmRzO1xuICAgIHN0YXRlLm92ZXJmbG93ID0gW294IDwgeDAgPyAtMSA6IG94ID4geDEgPyAxIDogMCwgb3kgPCB5MCA/IC0xIDogb3kgPiB5MSA/IDEgOiAwXTtcbiAgICBzdGF0ZS5fbW92ZW1lbnRCb3VuZFswXSA9IHN0YXRlLm92ZXJmbG93WzBdID8gc3RhdGUuX21vdmVtZW50Qm91bmRbMF0gPT09IGZhbHNlID8gc3RhdGUuX21vdmVtZW50WzBdIDogc3RhdGUuX21vdmVtZW50Qm91bmRbMF0gOiBmYWxzZTtcbiAgICBzdGF0ZS5fbW92ZW1lbnRCb3VuZFsxXSA9IHN0YXRlLm92ZXJmbG93WzFdID8gc3RhdGUuX21vdmVtZW50Qm91bmRbMV0gPT09IGZhbHNlID8gc3RhdGUuX21vdmVtZW50WzFdIDogc3RhdGUuX21vdmVtZW50Qm91bmRbMV0gOiBmYWxzZTtcbiAgICBjb25zdCBydWJiZXJiYW5kID0gc3RhdGUuX2FjdGl2ZSA/IGNvbmZpZy5ydWJiZXJiYW5kIHx8IFswLCAwXSA6IFswLCAwXTtcbiAgICBzdGF0ZS5vZmZzZXQgPSBjb21wdXRlUnViYmVyYmFuZChzdGF0ZS5fYm91bmRzLCBzdGF0ZS5vZmZzZXQsIHJ1YmJlcmJhbmQpO1xuICAgIHN0YXRlLmRlbHRhID0gVi5zdWIoc3RhdGUub2Zmc2V0LCBwcmV2aW91c09mZnNldCk7XG4gICAgdGhpcy5jb21wdXRlTW92ZW1lbnQoKTtcbiAgICBpZiAoZ2VzdHVyZUlzQWN0aXZlICYmICghc3RhdGUubGFzdCB8fCBkdCA+IEJFRk9SRV9MQVNUX0tJTkVNQVRJQ1NfREVMQVkpKSB7XG4gICAgICBzdGF0ZS5kZWx0YSA9IFYuc3ViKHN0YXRlLm9mZnNldCwgcHJldmlvdXNPZmZzZXQpO1xuICAgICAgY29uc3QgYWJzb2x1dGVEZWx0YSA9IHN0YXRlLmRlbHRhLm1hcChNYXRoLmFicyk7XG4gICAgICBWLmFkZFRvKHN0YXRlLmRpc3RhbmNlLCBhYnNvbHV0ZURlbHRhKTtcbiAgICAgIHN0YXRlLmRpcmVjdGlvbiA9IHN0YXRlLmRlbHRhLm1hcChNYXRoLnNpZ24pO1xuICAgICAgc3RhdGUuX2RpcmVjdGlvbiA9IHN0YXRlLl9kZWx0YS5tYXAoTWF0aC5zaWduKTtcbiAgICAgIGlmICghc3RhdGUuZmlyc3QgJiYgZHQgPiAwKSB7XG4gICAgICAgIHN0YXRlLnZlbG9jaXR5ID0gW2Fic29sdXRlRGVsdGFbMF0gLyBkdCwgYWJzb2x1dGVEZWx0YVsxXSAvIGR0XTtcbiAgICAgICAgc3RhdGUudGltZURlbHRhID0gZHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVtaXQoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHNoYXJlZCA9IHRoaXMuc2hhcmVkO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghc3RhdGUuX2FjdGl2ZSkgdGhpcy5jbGVhbigpO1xuICAgIGlmICgoc3RhdGUuX2Jsb2NrZWQgfHwgIXN0YXRlLmludGVudGlvbmFsKSAmJiAhc3RhdGUuX2ZvcmNlICYmICFjb25maWcudHJpZ2dlckFsbEV2ZW50cykgcmV0dXJuO1xuICAgIGNvbnN0IG1lbW8gPSB0aGlzLmhhbmRsZXIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHNoYXJlZCksIHN0YXRlKSwge30sIHtcbiAgICAgIFt0aGlzLmFsaWFzS2V5XTogc3RhdGUudmFsdWVzXG4gICAgfSkpO1xuICAgIGlmIChtZW1vICE9PSB1bmRlZmluZWQpIHN0YXRlLm1lbW8gPSBtZW1vO1xuICB9XG4gIGNsZWFuKCkge1xuICAgIHRoaXMuZXZlbnRTdG9yZS5jbGVhbigpO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmNsZWFuKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VsZWN0QXhpcyhbZHgsIGR5XSwgdGhyZXNob2xkKSB7XG4gIGNvbnN0IGFic0R4ID0gTWF0aC5hYnMoZHgpO1xuICBjb25zdCBhYnNEeSA9IE1hdGguYWJzKGR5KTtcbiAgaWYgKGFic0R4ID4gYWJzRHkgJiYgYWJzRHggPiB0aHJlc2hvbGQpIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9XG4gIGlmIChhYnNEeSA+IGFic0R4ICYmIGFic0R5ID4gdGhyZXNob2xkKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgQ29vcmRpbmF0ZXNFbmdpbmUgZXh0ZW5kcyBFbmdpbmUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxpYXNLZXlcIiwgJ3h5Jyk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgc3VwZXIucmVzZXQoKTtcbiAgICB0aGlzLnN0YXRlLmF4aXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnN0YXRlLm9mZnNldCA9IFswLCAwXTtcbiAgICB0aGlzLnN0YXRlLmxhc3RPZmZzZXQgPSBbMCwgMF07XG4gIH1cbiAgY29tcHV0ZU9mZnNldCgpIHtcbiAgICB0aGlzLnN0YXRlLm9mZnNldCA9IFYuYWRkKHRoaXMuc3RhdGUubGFzdE9mZnNldCwgdGhpcy5zdGF0ZS5tb3ZlbWVudCk7XG4gIH1cbiAgY29tcHV0ZU1vdmVtZW50KCkge1xuICAgIHRoaXMuc3RhdGUubW92ZW1lbnQgPSBWLnN1Yih0aGlzLnN0YXRlLm9mZnNldCwgdGhpcy5zdGF0ZS5sYXN0T2Zmc2V0KTtcbiAgfVxuICBheGlzSW50ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghc3RhdGUuYXhpcyAmJiBldmVudCkge1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gdHlwZW9mIGNvbmZpZy5heGlzVGhyZXNob2xkID09PSAnb2JqZWN0JyA/IGNvbmZpZy5heGlzVGhyZXNob2xkW2dldFBvaW50ZXJUeXBlKGV2ZW50KV0gOiBjb25maWcuYXhpc1RocmVzaG9sZDtcbiAgICAgIHN0YXRlLmF4aXMgPSBzZWxlY3RBeGlzKHN0YXRlLl9tb3ZlbWVudCwgdGhyZXNob2xkKTtcbiAgICB9XG4gICAgc3RhdGUuX2Jsb2NrZWQgPSAoY29uZmlnLmxvY2tEaXJlY3Rpb24gfHwgISFjb25maWcuYXhpcykgJiYgIXN0YXRlLmF4aXMgfHwgISFjb25maWcuYXhpcyAmJiBjb25maWcuYXhpcyAhPT0gc3RhdGUuYXhpcztcbiAgfVxuICByZXN0cmljdFRvQXhpcyh2KSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmF4aXMgfHwgdGhpcy5jb25maWcubG9ja0RpcmVjdGlvbikge1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlLmF4aXMpIHtcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgdlsxXSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgIHZbMF0gPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpZGVudGl0eSA9IHYgPT4gdjtcbmNvbnN0IERFRkFVTFRfUlVCQkVSQkFORCA9IDAuMTU7XG5jb25zdCBjb21tb25Db25maWdSZXNvbHZlciA9IHtcbiAgZW5hYmxlZCh2YWx1ZSA9IHRydWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGV2ZW50T3B0aW9ucyh2YWx1ZSwgX2ssIGNvbmZpZykge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29uZmlnLnNoYXJlZC5ldmVudE9wdGlvbnMpLCB2YWx1ZSk7XG4gIH0sXG4gIHByZXZlbnREZWZhdWx0KHZhbHVlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHRyaWdnZXJBbGxFdmVudHModmFsdWUgPSBmYWxzZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgcnViYmVyYmFuZCh2YWx1ZSA9IDApIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHJldHVybiBbREVGQVVMVF9SVUJCRVJCQU5ELCBERUZBVUxUX1JVQkJFUkJBTkRdO1xuICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBWLnRvVmVjdG9yKHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHJldHVybiBWLnRvVmVjdG9yKHZhbHVlKTtcbiAgfSxcbiAgdHJhbnNmb3JtKHZhbHVlLCBfaywgY29uZmlnKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdmFsdWUgfHwgY29uZmlnLnNoYXJlZC50cmFuc2Zvcm07XG4gICAgdGhpcy5oYXNDdXN0b21UcmFuc2Zvcm0gPSAhIXRyYW5zZm9ybTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsVHJhbnNmb3JtID0gdHJhbnNmb3JtIHx8IGlkZW50aXR5O1xuICAgICAgcmV0dXJuIHYgPT4ge1xuICAgICAgICBjb25zdCByID0gb3JpZ2luYWxUcmFuc2Zvcm0odik7XG4gICAgICAgIGlmICghaXNGaW5pdGUoclswXSkgfHwgIWlzRmluaXRlKHJbMV0pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBbQHVzZS1nZXN0dXJlXTogY29uZmlnLnRyYW5zZm9ybSgpIG11c3QgcHJvZHVjZSBhIHZhbGlkIHJlc3VsdCwgYnV0IGl0IHdhczogWyR7clswXX0sJHtbMV19XWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybSB8fCBpZGVudGl0eTtcbiAgfSxcbiAgdGhyZXNob2xkKHZhbHVlKSB7XG4gICAgcmV0dXJuIFYudG9WZWN0b3IodmFsdWUsIDApO1xuICB9XG59O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gIE9iamVjdC5hc3NpZ24oY29tbW9uQ29uZmlnUmVzb2x2ZXIsIHtcbiAgICBkb21UYXJnZXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgZG9tVGFyZ2V0XFxgIG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYHRhcmdldFxcYC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOYU47XG4gICAgfSxcbiAgICBsb2NrRGlyZWN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYGxvY2tEaXJlY3Rpb25cXGAgb3B0aW9uIGhhcyBiZWVuIG1lcmdlZCB3aXRoIFxcYGF4aXNcXGAuIFVzZSBpdCBhcyBpbiBcXGB7IGF4aXM6ICdsb2NrJyB9XFxgYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0sXG4gICAgaW5pdGlhbCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBpbml0aWFsXFxgIG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYGZyb21cXGAuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IERFRkFVTFRfQVhJU19USFJFU0hPTEQgPSAwO1xuY29uc3QgY29vcmRpbmF0ZXNDb25maWdSZXNvbHZlciA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb21tb25Db25maWdSZXNvbHZlciksIHt9LCB7XG4gIGF4aXMoX3YsIF9rLCB7XG4gICAgYXhpc1xuICB9KSB7XG4gICAgdGhpcy5sb2NrRGlyZWN0aW9uID0gYXhpcyA9PT0gJ2xvY2snO1xuICAgIGlmICghdGhpcy5sb2NrRGlyZWN0aW9uKSByZXR1cm4gYXhpcztcbiAgfSxcbiAgYXhpc1RocmVzaG9sZCh2YWx1ZSA9IERFRkFVTFRfQVhJU19USFJFU0hPTEQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGJvdW5kcyh2YWx1ZSA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHN0YXRlID0+IGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXIuYm91bmRzKHZhbHVlKHN0YXRlKSk7XG4gICAgfVxuICAgIGlmICgnY3VycmVudCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiAoKSA9PiB2YWx1ZS5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCA9IC1JbmZpbml0eSxcbiAgICAgIHJpZ2h0ID0gSW5maW5pdHksXG4gICAgICB0b3AgPSAtSW5maW5pdHksXG4gICAgICBib3R0b20gPSBJbmZpbml0eVxuICAgIH0gPSB2YWx1ZTtcbiAgICByZXR1cm4gW1tsZWZ0LCByaWdodF0sIFt0b3AsIGJvdHRvbV1dO1xuICB9XG59KTtcblxuY29uc3QgS0VZU19ERUxUQV9NQVAgPSB7XG4gIEFycm93UmlnaHQ6IChkaXNwbGFjZW1lbnQsIGZhY3RvciA9IDEpID0+IFtkaXNwbGFjZW1lbnQgKiBmYWN0b3IsIDBdLFxuICBBcnJvd0xlZnQ6IChkaXNwbGFjZW1lbnQsIGZhY3RvciA9IDEpID0+IFstMSAqIGRpc3BsYWNlbWVudCAqIGZhY3RvciwgMF0sXG4gIEFycm93VXA6IChkaXNwbGFjZW1lbnQsIGZhY3RvciA9IDEpID0+IFswLCAtMSAqIGRpc3BsYWNlbWVudCAqIGZhY3Rvcl0sXG4gIEFycm93RG93bjogKGRpc3BsYWNlbWVudCwgZmFjdG9yID0gMSkgPT4gWzAsIGRpc3BsYWNlbWVudCAqIGZhY3Rvcl1cbn07XG5jbGFzcyBEcmFnRW5naW5lIGV4dGVuZHMgQ29vcmRpbmF0ZXNFbmdpbmUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5nS2V5XCIsICdkcmFnZ2luZycpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHN1cGVyLnJlc2V0KCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl9wb2ludGVySWQgPSB1bmRlZmluZWQ7XG4gICAgc3RhdGUuX3BvaW50ZXJBY3RpdmUgPSBmYWxzZTtcbiAgICBzdGF0ZS5fa2V5Ym9hcmRBY3RpdmUgPSBmYWxzZTtcbiAgICBzdGF0ZS5fcHJldmVudFNjcm9sbCA9IGZhbHNlO1xuICAgIHN0YXRlLl9kZWxheWVkID0gZmFsc2U7XG4gICAgc3RhdGUuc3dpcGUgPSBbMCwgMF07XG4gICAgc3RhdGUudGFwID0gZmFsc2U7XG4gICAgc3RhdGUuY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5jYW5jZWwgPSB0aGlzLmNhbmNlbC5iaW5kKHRoaXMpO1xuICB9XG4gIHNldHVwKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuX2JvdW5kcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBjb25zdCBib3VuZFJlY3QgPSBzdGF0ZS5fYm91bmRzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgdGFyZ2V0UmVjdCA9IHN0YXRlLmN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBfYm91bmRzID0ge1xuICAgICAgICBsZWZ0OiBib3VuZFJlY3QubGVmdCAtIHRhcmdldFJlY3QubGVmdCArIHN0YXRlLm9mZnNldFswXSxcbiAgICAgICAgcmlnaHQ6IGJvdW5kUmVjdC5yaWdodCAtIHRhcmdldFJlY3QucmlnaHQgKyBzdGF0ZS5vZmZzZXRbMF0sXG4gICAgICAgIHRvcDogYm91bmRSZWN0LnRvcCAtIHRhcmdldFJlY3QudG9wICsgc3RhdGUub2Zmc2V0WzFdLFxuICAgICAgICBib3R0b206IGJvdW5kUmVjdC5ib3R0b20gLSB0YXJnZXRSZWN0LmJvdHRvbSArIHN0YXRlLm9mZnNldFsxXVxuICAgICAgfTtcbiAgICAgIHN0YXRlLl9ib3VuZHMgPSBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyLmJvdW5kcyhfYm91bmRzKTtcbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuY2FuY2VsZWQpIHJldHVybjtcbiAgICBzdGF0ZS5jYW5jZWxlZCA9IHRydWU7XG4gICAgc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jb21wdXRlKCk7XG4gICAgICB0aGlzLmVtaXQoKTtcbiAgICB9LCAwKTtcbiAgfVxuICBzZXRBY3RpdmUoKSB7XG4gICAgdGhpcy5zdGF0ZS5fYWN0aXZlID0gdGhpcy5zdGF0ZS5fcG9pbnRlckFjdGl2ZSB8fCB0aGlzLnN0YXRlLl9rZXlib2FyZEFjdGl2ZTtcbiAgfVxuICBjbGVhbigpIHtcbiAgICB0aGlzLnBvaW50ZXJDbGVhbigpO1xuICAgIHRoaXMuc3RhdGUuX3BvaW50ZXJBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLl9rZXlib2FyZEFjdGl2ZSA9IGZhbHNlO1xuICAgIHN1cGVyLmNsZWFuKCk7XG4gIH1cbiAgcG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbnMgIT0gbnVsbCAmJiAoQXJyYXkuaXNBcnJheShjb25maWcucG9pbnRlckJ1dHRvbnMpID8gIWNvbmZpZy5wb2ludGVyQnV0dG9ucy5pbmNsdWRlcyhldmVudC5idXR0b25zKSA6IGNvbmZpZy5wb2ludGVyQnV0dG9ucyAhPT0gLTEgJiYgY29uZmlnLnBvaW50ZXJCdXR0b25zICE9PSBldmVudC5idXR0b25zKSkgcmV0dXJuO1xuICAgIGNvbnN0IGN0cmxJZHMgPSB0aGlzLmN0cmwuc2V0RXZlbnRJZHMoZXZlbnQpO1xuICAgIGlmIChjb25maWcucG9pbnRlckNhcHR1cmUpIHtcbiAgICAgIGV2ZW50LnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgIH1cbiAgICBpZiAoY3RybElkcyAmJiBjdHJsSWRzLnNpemUgPiAxICYmIHN0YXRlLl9wb2ludGVyQWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5zdGFydChldmVudCk7XG4gICAgdGhpcy5zZXR1cFBvaW50ZXIoZXZlbnQpO1xuICAgIHN0YXRlLl9wb2ludGVySWQgPSBwb2ludGVySWQoZXZlbnQpO1xuICAgIHN0YXRlLl9wb2ludGVyQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXMocG9pbnRlclZhbHVlcyhldmVudCkpO1xuICAgIHRoaXMuY29tcHV0ZUluaXRpYWwoKTtcbiAgICBpZiAoY29uZmlnLnByZXZlbnRTY3JvbGxBeGlzICYmIGdldFBvaW50ZXJUeXBlKGV2ZW50KSAhPT0gJ21vdXNlJykge1xuICAgICAgc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZXR1cFNjcm9sbFByZXZlbnRpb24oZXZlbnQpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmRlbGF5ID4gMCkge1xuICAgICAgdGhpcy5zZXR1cERlbGF5VHJpZ2dlcihldmVudCk7XG4gICAgICBpZiAoY29uZmlnLnRyaWdnZXJBbGxFdmVudHMpIHtcbiAgICAgICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnRQb2ludGVyRHJhZyhldmVudCk7XG4gICAgfVxuICB9XG4gIHN0YXJ0UG9pbnRlckRyYWcoZXZlbnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3RhdGUuX2FjdGl2ZSA9IHRydWU7XG4gICAgc3RhdGUuX3ByZXZlbnRTY3JvbGwgPSB0cnVlO1xuICAgIHN0YXRlLl9kZWxheWVkID0gZmFsc2U7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBwb2ludGVyTW92ZShldmVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIXN0YXRlLl9wb2ludGVyQWN0aXZlKSByZXR1cm47XG4gICAgY29uc3QgaWQgPSBwb2ludGVySWQoZXZlbnQpO1xuICAgIGlmIChzdGF0ZS5fcG9pbnRlcklkICE9PSB1bmRlZmluZWQgJiYgaWQgIT09IHN0YXRlLl9wb2ludGVySWQpIHJldHVybjtcbiAgICBjb25zdCBfdmFsdWVzID0gcG9pbnRlclZhbHVlcyhldmVudCk7XG4gICAgaWYgKGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICBzdGF0ZS5fZGVsdGEgPSBbZXZlbnQubW92ZW1lbnRYLCBldmVudC5tb3ZlbWVudFldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5fZGVsdGEgPSBWLnN1YihfdmFsdWVzLCBzdGF0ZS5fdmFsdWVzKTtcbiAgICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhfdmFsdWVzKTtcbiAgICB9XG4gICAgVi5hZGRUbyhzdGF0ZS5fbW92ZW1lbnQsIHN0YXRlLl9kZWx0YSk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICBpZiAoc3RhdGUuX2RlbGF5ZWQgJiYgc3RhdGUuaW50ZW50aW9uYWwpIHtcbiAgICAgIHRoaXMudGltZW91dFN0b3JlLnJlbW92ZSgnZHJhZ0RlbGF5Jyk7XG4gICAgICBzdGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhcnRQb2ludGVyRHJhZyhldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb25maWcucHJldmVudFNjcm9sbEF4aXMgJiYgIXN0YXRlLl9wcmV2ZW50U2Nyb2xsKSB7XG4gICAgICBpZiAoc3RhdGUuYXhpcykge1xuICAgICAgICBpZiAoc3RhdGUuYXhpcyA9PT0gY29uZmlnLnByZXZlbnRTY3JvbGxBeGlzIHx8IGNvbmZpZy5wcmV2ZW50U2Nyb2xsQXhpcyA9PT0gJ3h5Jykge1xuICAgICAgICAgIHN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudGltZW91dFN0b3JlLnJlbW92ZSgnc3RhcnRQb2ludGVyRHJhZycpO1xuICAgICAgICAgIHRoaXMuc3RhcnRQb2ludGVyRHJhZyhldmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHBvaW50ZXJVcChldmVudCkge1xuICAgIHRoaXMuY3RybC5zZXRFdmVudElkcyhldmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5wb2ludGVyQ2FwdHVyZSAmJiBldmVudC50YXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICA7XG4gICAgICAgIGV2ZW50LnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbQHVzZS1nZXN0dXJlXTogSWYgeW91IHNlZSB0aGlzIG1lc3NhZ2UsIGl0J3MgbGlrZWx5IHRoYXQgeW91J3JlIHVzaW5nIGFuIG91dGRhdGVkIHZlcnNpb24gb2YgXFxgQHJlYWN0LXRocmVlL2ZpYmVyXFxgLiBcXG5cXG5QbGVhc2UgdXBncmFkZSB0byB0aGUgbGF0ZXN0IHZlcnNpb24uYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIXN0YXRlLl9hY3RpdmUgfHwgIXN0YXRlLl9wb2ludGVyQWN0aXZlKSByZXR1cm47XG4gICAgY29uc3QgaWQgPSBwb2ludGVySWQoZXZlbnQpO1xuICAgIGlmIChzdGF0ZS5fcG9pbnRlcklkICE9PSB1bmRlZmluZWQgJiYgaWQgIT09IHN0YXRlLl9wb2ludGVySWQpIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLl9wb2ludGVyQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5zZXRBY3RpdmUoKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIGNvbnN0IFtkeCwgZHldID0gc3RhdGUuX2Rpc3RhbmNlO1xuICAgIHN0YXRlLnRhcCA9IGR4IDw9IGNvbmZpZy50YXBzVGhyZXNob2xkICYmIGR5IDw9IGNvbmZpZy50YXBzVGhyZXNob2xkO1xuICAgIGlmIChzdGF0ZS50YXAgJiYgY29uZmlnLmZpbHRlclRhcHMpIHtcbiAgICAgIHN0YXRlLl9mb3JjZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtfZHgsIF9keV0gPSBzdGF0ZS5fZGVsdGE7XG4gICAgICBjb25zdCBbX214LCBfbXldID0gc3RhdGUuX21vdmVtZW50O1xuICAgICAgY29uc3QgW3N2eCwgc3Z5XSA9IGNvbmZpZy5zd2lwZS52ZWxvY2l0eTtcbiAgICAgIGNvbnN0IFtzeCwgc3ldID0gY29uZmlnLnN3aXBlLmRpc3RhbmNlO1xuICAgICAgY29uc3Qgc2R0ID0gY29uZmlnLnN3aXBlLmR1cmF0aW9uO1xuICAgICAgaWYgKHN0YXRlLmVsYXBzZWRUaW1lIDwgc2R0KSB7XG4gICAgICAgIGNvbnN0IF92eCA9IE1hdGguYWJzKF9keCAvIHN0YXRlLnRpbWVEZWx0YSk7XG4gICAgICAgIGNvbnN0IF92eSA9IE1hdGguYWJzKF9keSAvIHN0YXRlLnRpbWVEZWx0YSk7XG4gICAgICAgIGlmIChfdnggPiBzdnggJiYgTWF0aC5hYnMoX214KSA+IHN4KSBzdGF0ZS5zd2lwZVswXSA9IE1hdGguc2lnbihfZHgpO1xuICAgICAgICBpZiAoX3Z5ID4gc3Z5ICYmIE1hdGguYWJzKF9teSkgPiBzeSkgc3RhdGUuc3dpcGVbMV0gPSBNYXRoLnNpZ24oX2R5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgcG9pbnRlckNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLnRhcCAmJiBldmVudC5kZXRhaWwgPiAwKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG4gIHNldHVwUG9pbnRlcihldmVudCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGRldmljZSA9IGNvbmZpZy5kZXZpY2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZGV2aWNlID09PSAncG9pbnRlcicgJiYgY29uZmlnLnByZXZlbnRTY3JvbGxEZWxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9ICd1dicgaW4gZXZlbnQgPyBldmVudC5zb3VyY2VFdmVudC5jdXJyZW50VGFyZ2V0IDogZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgIGlmIChzdHlsZS50b3VjaEFjdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtAdXNlLWdlc3R1cmVdOiBUaGUgZHJhZyB0YXJnZXQgaGFzIGl0cyBcXGB0b3VjaC1hY3Rpb25cXGAgc3R5bGUgcHJvcGVydHkgc2V0IHRvIFxcYGF1dG9cXGAuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGFkZCBcXGB0b3VjaC1hY3Rpb246ICdub25lJ1xcYCBzbyB0aGF0IHRoZSBkcmFnIGdlc3R1cmUgYmVoYXZlcyBjb3JyZWN0bHkgb24gdG91Y2gtZW5hYmxlZCBkZXZpY2VzLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiByZWFkIHRoaXM6IGh0dHBzOi8vdXNlLWdlc3R1cmUubmV0bGlmeS5hcHAvZG9jcy9leHRyYXMvI3RvdWNoLWFjdGlvbi5cXG5cXG5UaGlzIG1lc3NhZ2Ugd2lsbCBvbmx5IHNob3cgaW4gZGV2ZWxvcG1lbnQgbW9kZS4gSXQgd29uJ3QgYXBwZWFyIGluIHByb2R1Y3Rpb24uIElmIHRoaXMgaXMgaW50ZW5kZWQsIHlvdSBjYW4gaWdub3JlIGl0LmAsIGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX3VudXNlZDIpIHt9XG4gICAgfVxuICAgIGlmIChjb25maWcucG9pbnRlckxvY2spIHtcbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICAgfVxuICAgIGlmICghY29uZmlnLnBvaW50ZXJDYXB0dXJlKSB7XG4gICAgICB0aGlzLmV2ZW50U3RvcmUuYWRkKHRoaXMuc2hhcmVkQ29uZmlnLndpbmRvdywgZGV2aWNlLCAnY2hhbmdlJywgdGhpcy5wb2ludGVyTW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZXZlbnRTdG9yZS5hZGQodGhpcy5zaGFyZWRDb25maWcud2luZG93LCBkZXZpY2UsICdlbmQnLCB0aGlzLnBvaW50ZXJVcC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZXZlbnRTdG9yZS5hZGQodGhpcy5zaGFyZWRDb25maWcud2luZG93LCBkZXZpY2UsICdjYW5jZWwnLCB0aGlzLnBvaW50ZXJVcC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cbiAgcG9pbnRlckNsZWFuKCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5wb2ludGVyTG9jayAmJiBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgPT09IHRoaXMuc3RhdGUuY3VycmVudFRhcmdldCkge1xuICAgICAgZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKCk7XG4gICAgfVxuICB9XG4gIHByZXZlbnRTY3JvbGwoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5fcHJldmVudFNjcm9sbCAmJiBldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBzZXR1cFNjcm9sbFByZXZlbnRpb24oZXZlbnQpIHtcbiAgICB0aGlzLnN0YXRlLl9wcmV2ZW50U2Nyb2xsID0gZmFsc2U7XG4gICAgcGVyc2lzdEV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCByZW1vdmUgPSB0aGlzLmV2ZW50U3RvcmUuYWRkKHRoaXMuc2hhcmVkQ29uZmlnLndpbmRvdywgJ3RvdWNoJywgJ2NoYW5nZScsIHRoaXMucHJldmVudFNjcm9sbC5iaW5kKHRoaXMpLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRTdG9yZS5hZGQodGhpcy5zaGFyZWRDb25maWcud2luZG93LCAndG91Y2gnLCAnZW5kJywgcmVtb3ZlKTtcbiAgICB0aGlzLmV2ZW50U3RvcmUuYWRkKHRoaXMuc2hhcmVkQ29uZmlnLndpbmRvdywgJ3RvdWNoJywgJ2NhbmNlbCcsIHJlbW92ZSk7XG4gICAgdGhpcy50aW1lb3V0U3RvcmUuYWRkKCdzdGFydFBvaW50ZXJEcmFnJywgdGhpcy5zdGFydFBvaW50ZXJEcmFnLmJpbmQodGhpcyksIHRoaXMuY29uZmlnLnByZXZlbnRTY3JvbGxEZWxheSwgZXZlbnQpO1xuICB9XG4gIHNldHVwRGVsYXlUcmlnZ2VyKGV2ZW50KSB7XG4gICAgdGhpcy5zdGF0ZS5fZGVsYXllZCA9IHRydWU7XG4gICAgdGhpcy50aW1lb3V0U3RvcmUuYWRkKCdkcmFnRGVsYXknLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlLl9zdGVwID0gWzAsIDBdO1xuICAgICAgdGhpcy5zdGFydFBvaW50ZXJEcmFnKGV2ZW50KTtcbiAgICB9LCB0aGlzLmNvbmZpZy5kZWxheSk7XG4gIH1cbiAga2V5RG93bihldmVudCkge1xuICAgIGNvbnN0IGRlbHRhRm4gPSBLRVlTX0RFTFRBX01BUFtldmVudC5rZXldO1xuICAgIGlmIChkZWx0YUZuKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBmYWN0b3IgPSBldmVudC5zaGlmdEtleSA/IDEwIDogZXZlbnQuYWx0S2V5ID8gMC4xIDogMTtcbiAgICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgICAgc3RhdGUuX2RlbHRhID0gZGVsdGFGbih0aGlzLmNvbmZpZy5rZXlib2FyZERpc3BsYWNlbWVudCwgZmFjdG9yKTtcbiAgICAgIHN0YXRlLl9rZXlib2FyZEFjdGl2ZSA9IHRydWU7XG4gICAgICBWLmFkZFRvKHN0YXRlLl9tb3ZlbWVudCwgc3RhdGUuX2RlbHRhKTtcbiAgICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgICB0aGlzLmVtaXQoKTtcbiAgICB9XG4gIH1cbiAga2V5VXAoZXZlbnQpIHtcbiAgICBpZiAoIShldmVudC5rZXkgaW4gS0VZU19ERUxUQV9NQVApKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5fa2V5Ym9hcmRBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnNldEFjdGl2ZSgpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgYmluZChiaW5kRnVuY3Rpb24pIHtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmNvbmZpZy5kZXZpY2U7XG4gICAgYmluZEZ1bmN0aW9uKGRldmljZSwgJ3N0YXJ0JywgdGhpcy5wb2ludGVyRG93bi5iaW5kKHRoaXMpKTtcbiAgICBpZiAodGhpcy5jb25maWcucG9pbnRlckNhcHR1cmUpIHtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdjaGFuZ2UnLCB0aGlzLnBvaW50ZXJNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgYmluZEZ1bmN0aW9uKGRldmljZSwgJ2VuZCcsIHRoaXMucG9pbnRlclVwLmJpbmQodGhpcykpO1xuICAgICAgYmluZEZ1bmN0aW9uKGRldmljZSwgJ2NhbmNlbCcsIHRoaXMucG9pbnRlclVwLmJpbmQodGhpcykpO1xuICAgICAgYmluZEZ1bmN0aW9uKCdsb3N0UG9pbnRlckNhcHR1cmUnLCAnJywgdGhpcy5wb2ludGVyVXAuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5rZXlzKSB7XG4gICAgICBiaW5kRnVuY3Rpb24oJ2tleScsICdkb3duJywgdGhpcy5rZXlEb3duLmJpbmQodGhpcykpO1xuICAgICAgYmluZEZ1bmN0aW9uKCdrZXknLCAndXAnLCB0aGlzLmtleVVwLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcuZmlsdGVyVGFwcykge1xuICAgICAgYmluZEZ1bmN0aW9uKCdjbGljaycsICcnLCB0aGlzLnBvaW50ZXJDbGljay5iaW5kKHRoaXMpLCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBlcnNpc3RFdmVudChldmVudCkge1xuICAncGVyc2lzdCcgaW4gZXZlbnQgJiYgdHlwZW9mIGV2ZW50LnBlcnNpc3QgPT09ICdmdW5jdGlvbicgJiYgZXZlbnQucGVyc2lzdCgpO1xufVxuXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQ7XG5mdW5jdGlvbiBzdXBwb3J0c1RvdWNoRXZlbnRzKCkge1xuICByZXR1cm4gaXNCcm93c2VyICYmICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcbn1cbmZ1bmN0aW9uIGlzVG91Y2hTY3JlZW4oKSB7XG4gIHJldHVybiBzdXBwb3J0c1RvdWNoRXZlbnRzKCkgfHwgaXNCcm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNQb2ludGVyRXZlbnRzKCkge1xuICByZXR1cm4gaXNCcm93c2VyICYmICdvbnBvaW50ZXJkb3duJyBpbiB3aW5kb3c7XG59XG5mdW5jdGlvbiBzdXBwb3J0c1BvaW50ZXJMb2NrKCkge1xuICByZXR1cm4gaXNCcm93c2VyICYmICdleGl0UG9pbnRlckxvY2snIGluIHdpbmRvdy5kb2N1bWVudDtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzR2VzdHVyZUV2ZW50cygpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJ2NvbnN0cnVjdG9yJyBpbiBHZXN0dXJlRXZlbnQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IFNVUFBPUlQgPSB7XG4gIGlzQnJvd3NlcixcbiAgZ2VzdHVyZTogc3VwcG9ydHNHZXN0dXJlRXZlbnRzKCksXG4gIHRvdWNoOiBzdXBwb3J0c1RvdWNoRXZlbnRzKCksXG4gIHRvdWNoc2NyZWVuOiBpc1RvdWNoU2NyZWVuKCksXG4gIHBvaW50ZXI6IHN1cHBvcnRzUG9pbnRlckV2ZW50cygpLFxuICBwb2ludGVyTG9jazogc3VwcG9ydHNQb2ludGVyTG9jaygpXG59O1xuXG5jb25zdCBERUZBVUxUX1BSRVZFTlRfU0NST0xMX0RFTEFZID0gMjUwO1xuY29uc3QgREVGQVVMVF9EUkFHX0RFTEFZID0gMTgwO1xuY29uc3QgREVGQVVMVF9TV0lQRV9WRUxPQ0lUWSA9IDAuNTtcbmNvbnN0IERFRkFVTFRfU1dJUEVfRElTVEFOQ0UgPSA1MDtcbmNvbnN0IERFRkFVTFRfU1dJUEVfRFVSQVRJT04gPSAyNTA7XG5jb25zdCBERUZBVUxUX0tFWUJPQVJEX0RJU1BMQUNFTUVOVCA9IDEwO1xuY29uc3QgREVGQVVMVF9EUkFHX0FYSVNfVEhSRVNIT0xEID0ge1xuICBtb3VzZTogMCxcbiAgdG91Y2g6IDAsXG4gIHBlbjogOFxufTtcbmNvbnN0IGRyYWdDb25maWdSZXNvbHZlciA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyKSwge30sIHtcbiAgZGV2aWNlKF92LCBfaywge1xuICAgIHBvaW50ZXI6IHtcbiAgICAgIHRvdWNoID0gZmFsc2UsXG4gICAgICBsb2NrID0gZmFsc2UsXG4gICAgICBtb3VzZSA9IGZhbHNlXG4gICAgfSA9IHt9XG4gIH0pIHtcbiAgICB0aGlzLnBvaW50ZXJMb2NrID0gbG9jayAmJiBTVVBQT1JULnBvaW50ZXJMb2NrO1xuICAgIGlmIChTVVBQT1JULnRvdWNoICYmIHRvdWNoKSByZXR1cm4gJ3RvdWNoJztcbiAgICBpZiAodGhpcy5wb2ludGVyTG9jaykgcmV0dXJuICdtb3VzZSc7XG4gICAgaWYgKFNVUFBPUlQucG9pbnRlciAmJiAhbW91c2UpIHJldHVybiAncG9pbnRlcic7XG4gICAgaWYgKFNVUFBPUlQudG91Y2gpIHJldHVybiAndG91Y2gnO1xuICAgIHJldHVybiAnbW91c2UnO1xuICB9LFxuICBwcmV2ZW50U2Nyb2xsQXhpcyh2YWx1ZSwgX2ssIHtcbiAgICBwcmV2ZW50U2Nyb2xsXG4gIH0pIHtcbiAgICB0aGlzLnByZXZlbnRTY3JvbGxEZWxheSA9IHR5cGVvZiBwcmV2ZW50U2Nyb2xsID09PSAnbnVtYmVyJyA/IHByZXZlbnRTY3JvbGwgOiBwcmV2ZW50U2Nyb2xsIHx8IHByZXZlbnRTY3JvbGwgPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA/IERFRkFVTFRfUFJFVkVOVF9TQ1JPTExfREVMQVkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFTVVBQT1JULnRvdWNoc2NyZWVuIHx8IHByZXZlbnRTY3JvbGwgPT09IGZhbHNlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlIDogcHJldmVudFNjcm9sbCAhPT0gdW5kZWZpbmVkID8gJ3knIDogdW5kZWZpbmVkO1xuICB9LFxuICBwb2ludGVyQ2FwdHVyZShfdiwgX2ssIHtcbiAgICBwb2ludGVyOiB7XG4gICAgICBjYXB0dXJlID0gdHJ1ZSxcbiAgICAgIGJ1dHRvbnMgPSAxLFxuICAgICAga2V5cyA9IHRydWVcbiAgICB9ID0ge31cbiAgfSkge1xuICAgIHRoaXMucG9pbnRlckJ1dHRvbnMgPSBidXR0b25zO1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgcmV0dXJuICF0aGlzLnBvaW50ZXJMb2NrICYmIHRoaXMuZGV2aWNlID09PSAncG9pbnRlcicgJiYgY2FwdHVyZTtcbiAgfSxcbiAgdGhyZXNob2xkKHZhbHVlLCBfaywge1xuICAgIGZpbHRlclRhcHMgPSBmYWxzZSxcbiAgICB0YXBzVGhyZXNob2xkID0gMyxcbiAgICBheGlzID0gdW5kZWZpbmVkXG4gIH0pIHtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBWLnRvVmVjdG9yKHZhbHVlLCBmaWx0ZXJUYXBzID8gdGFwc1RocmVzaG9sZCA6IGF4aXMgPyAxIDogMCk7XG4gICAgdGhpcy5maWx0ZXJUYXBzID0gZmlsdGVyVGFwcztcbiAgICB0aGlzLnRhcHNUaHJlc2hvbGQgPSB0YXBzVGhyZXNob2xkO1xuICAgIHJldHVybiB0aHJlc2hvbGQ7XG4gIH0sXG4gIHN3aXBlKHtcbiAgICB2ZWxvY2l0eSA9IERFRkFVTFRfU1dJUEVfVkVMT0NJVFksXG4gICAgZGlzdGFuY2UgPSBERUZBVUxUX1NXSVBFX0RJU1RBTkNFLFxuICAgIGR1cmF0aW9uID0gREVGQVVMVF9TV0lQRV9EVVJBVElPTlxuICB9ID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVsb2NpdHk6IHRoaXMudHJhbnNmb3JtKFYudG9WZWN0b3IodmVsb2NpdHkpKSxcbiAgICAgIGRpc3RhbmNlOiB0aGlzLnRyYW5zZm9ybShWLnRvVmVjdG9yKGRpc3RhbmNlKSksXG4gICAgICBkdXJhdGlvblxuICAgIH07XG4gIH0sXG4gIGRlbGF5KHZhbHVlID0gMCkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfRFJBR19ERUxBWTtcbiAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgYXhpc1RocmVzaG9sZCh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHJldHVybiBERUZBVUxUX0RSQUdfQVhJU19USFJFU0hPTEQ7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0RSQUdfQVhJU19USFJFU0hPTEQpLCB2YWx1ZSk7XG4gIH0sXG4gIGtleWJvYXJkRGlzcGxhY2VtZW50KHZhbHVlID0gREVGQVVMVF9LRVlCT0FSRF9ESVNQTEFDRU1FTlQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gIE9iamVjdC5hc3NpZ24oZHJhZ0NvbmZpZ1Jlc29sdmVyLCB7XG4gICAgdXNlVG91Y2godmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgdXNlVG91Y2hcXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgcG9pbnRlci50b3VjaFxcYC4gVXNlIGl0IGFzIGluIFxcYHsgcG9pbnRlcjogeyB0b3VjaDogdHJ1ZSB9IH1cXGAuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0sXG4gICAgZXhwZXJpbWVudGFsX3ByZXZlbnRXaW5kb3dTY3JvbGxZKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYGV4cGVyaW1lbnRhbF9wcmV2ZW50V2luZG93U2Nyb2xsWVxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBwcmV2ZW50U2Nyb2xsXFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9LFxuICAgIHN3aXBlVmVsb2NpdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgc3dpcGVWZWxvY2l0eVxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBzd2lwZS52ZWxvY2l0eVxcYC4gVXNlIGl0IGFzIGluIFxcYHsgc3dpcGU6IHsgdmVsb2NpdHk6IDAuNSB9IH1cXGAuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0sXG4gICAgc3dpcGVEaXN0YW5jZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBzd2lwZURpc3RhbmNlXFxgIG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYHN3aXBlLmRpc3RhbmNlXFxgLiBVc2UgaXQgYXMgaW4gXFxgeyBzd2lwZTogeyBkaXN0YW5jZTogNTAgfSB9XFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9LFxuICAgIHN3aXBlRHVyYXRpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgc3dpcGVEdXJhdGlvblxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBzd2lwZS5kdXJhdGlvblxcYC4gVXNlIGl0IGFzIGluIFxcYHsgc3dpcGU6IHsgZHVyYXRpb246IDI1MCB9IH1cXGAuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wU3RhdGVJbnRlcm5hbE1vdmVtZW50VG9Cb3VuZHMoc3RhdGUpIHtcbiAgY29uc3QgW294LCBveV0gPSBzdGF0ZS5vdmVyZmxvdztcbiAgY29uc3QgW2R4LCBkeV0gPSBzdGF0ZS5fZGVsdGE7XG4gIGNvbnN0IFtkaXJ4LCBkaXJ5XSA9IHN0YXRlLl9kaXJlY3Rpb247XG4gIGlmIChveCA8IDAgJiYgZHggPiAwICYmIGRpcnggPCAwIHx8IG94ID4gMCAmJiBkeCA8IDAgJiYgZGlyeCA+IDApIHtcbiAgICBzdGF0ZS5fbW92ZW1lbnRbMF0gPSBzdGF0ZS5fbW92ZW1lbnRCb3VuZFswXTtcbiAgfVxuICBpZiAob3kgPCAwICYmIGR5ID4gMCAmJiBkaXJ5IDwgMCB8fCBveSA+IDAgJiYgZHkgPCAwICYmIGRpcnkgPiAwKSB7XG4gICAgc3RhdGUuX21vdmVtZW50WzFdID0gc3RhdGUuX21vdmVtZW50Qm91bmRbMV07XG4gIH1cbn1cblxuY29uc3QgU0NBTEVfQU5HTEVfUkFUSU9fSU5URU5UX0RFRyA9IDMwO1xuY29uc3QgUElOQ0hfV0hFRUxfUkFUSU8gPSAxMDA7XG5jbGFzcyBQaW5jaEVuZ2luZSBleHRlbmRzIEVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmdLZXlcIiwgJ3BpbmNoaW5nJyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxpYXNLZXlcIiwgJ2RhJyk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnN0YXRlLm9mZnNldCA9IFsxLCAwXTtcbiAgICB0aGlzLnN0YXRlLmxhc3RPZmZzZXQgPSBbMSwgMF07XG4gICAgdGhpcy5zdGF0ZS5fcG9pbnRlckV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBzdXBlci5yZXNldCgpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5fdG91Y2hJZHMgPSBbXTtcbiAgICBzdGF0ZS5jYW5jZWxlZCA9IGZhbHNlO1xuICAgIHN0YXRlLmNhbmNlbCA9IHRoaXMuY2FuY2VsLmJpbmQodGhpcyk7XG4gICAgc3RhdGUudHVybnMgPSAwO1xuICB9XG4gIGNvbXB1dGVPZmZzZXQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIG1vdmVtZW50LFxuICAgICAgbGFzdE9mZnNldFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICB0aGlzLnN0YXRlLm9mZnNldCA9IFYuYWRkKG1vdmVtZW50LCBsYXN0T2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBbKDEgKyBtb3ZlbWVudFswXSkgKiBsYXN0T2Zmc2V0WzBdLCBtb3ZlbWVudFsxXSArIGxhc3RPZmZzZXRbMV1dO1xuICAgIH1cbiAgfVxuICBjb21wdXRlTW92ZW1lbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0LFxuICAgICAgbGFzdE9mZnNldFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc3RhdGUubW92ZW1lbnQgPSBbb2Zmc2V0WzBdIC8gbGFzdE9mZnNldFswXSwgb2Zmc2V0WzFdIC0gbGFzdE9mZnNldFsxXV07XG4gIH1cbiAgYXhpc0ludGVudCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgW19tMCwgX20xXSA9IHN0YXRlLl9tb3ZlbWVudDtcbiAgICBpZiAoIXN0YXRlLmF4aXMpIHtcbiAgICAgIGNvbnN0IGF4aXNNb3ZlbWVudERpZmZlcmVuY2UgPSBNYXRoLmFicyhfbTApICogU0NBTEVfQU5HTEVfUkFUSU9fSU5URU5UX0RFRyAtIE1hdGguYWJzKF9tMSk7XG4gICAgICBpZiAoYXhpc01vdmVtZW50RGlmZmVyZW5jZSA8IDApIHN0YXRlLmF4aXMgPSAnYW5nbGUnO2Vsc2UgaWYgKGF4aXNNb3ZlbWVudERpZmZlcmVuY2UgPiAwKSBzdGF0ZS5heGlzID0gJ3NjYWxlJztcbiAgICB9XG4gIH1cbiAgcmVzdHJpY3RUb0F4aXModikge1xuICAgIGlmICh0aGlzLmNvbmZpZy5sb2NrRGlyZWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5heGlzID09PSAnc2NhbGUnKSB2WzFdID0gMDtlbHNlIGlmICh0aGlzLnN0YXRlLmF4aXMgPT09ICdhbmdsZScpIHZbMF0gPSAwO1xuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5jYW5jZWxlZCkgcmV0dXJuO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RhdGUuY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21wdXRlKCk7XG4gICAgICB0aGlzLmVtaXQoKTtcbiAgICB9LCAwKTtcbiAgfVxuICB0b3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5jdHJsLnNldEV2ZW50SWRzKGV2ZW50KTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY3RybFRvdWNoSWRzID0gdGhpcy5jdHJsLnRvdWNoSWRzO1xuICAgIGlmIChzdGF0ZS5fYWN0aXZlKSB7XG4gICAgICBpZiAoc3RhdGUuX3RvdWNoSWRzLmV2ZXJ5KGlkID0+IGN0cmxUb3VjaElkcy5oYXMoaWQpKSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3RybFRvdWNoSWRzLnNpemUgPCAyKSByZXR1cm47XG4gICAgdGhpcy5zdGFydChldmVudCk7XG4gICAgc3RhdGUuX3RvdWNoSWRzID0gQXJyYXkuZnJvbShjdHJsVG91Y2hJZHMpLnNsaWNlKDAsIDIpO1xuICAgIGNvbnN0IHBheWxvYWQgPSB0b3VjaERpc3RhbmNlQW5nbGUoZXZlbnQsIHN0YXRlLl90b3VjaElkcyk7XG4gICAgaWYgKCFwYXlsb2FkKSByZXR1cm47XG4gICAgdGhpcy5waW5jaFN0YXJ0KGV2ZW50LCBwYXlsb2FkKTtcbiAgfVxuICBwb2ludGVyU3RhcnQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9ucyAhPSBudWxsICYmIGV2ZW50LmJ1dHRvbnMgJSAyICE9PSAxKSByZXR1cm47XG4gICAgdGhpcy5jdHJsLnNldEV2ZW50SWRzKGV2ZW50KTtcbiAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgX3BvaW50ZXJFdmVudHMgPSBzdGF0ZS5fcG9pbnRlckV2ZW50cztcbiAgICBjb25zdCBjdHJsUG9pbnRlcklkcyA9IHRoaXMuY3RybC5wb2ludGVySWRzO1xuICAgIGlmIChzdGF0ZS5fYWN0aXZlKSB7XG4gICAgICBpZiAoQXJyYXkuZnJvbShfcG9pbnRlckV2ZW50cy5rZXlzKCkpLmV2ZXJ5KGlkID0+IGN0cmxQb2ludGVySWRzLmhhcyhpZCkpKSByZXR1cm47XG4gICAgfVxuICAgIGlmIChfcG9pbnRlckV2ZW50cy5zaXplIDwgMikge1xuICAgICAgX3BvaW50ZXJFdmVudHMuc2V0KGV2ZW50LnBvaW50ZXJJZCwgZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuX3BvaW50ZXJFdmVudHMuc2l6ZSA8IDIpIHJldHVybjtcbiAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICBjb25zdCBwYXlsb2FkID0gZGlzdGFuY2VBbmdsZSguLi5BcnJheS5mcm9tKF9wb2ludGVyRXZlbnRzLnZhbHVlcygpKSk7XG4gICAgaWYgKCFwYXlsb2FkKSByZXR1cm47XG4gICAgdGhpcy5waW5jaFN0YXJ0KGV2ZW50LCBwYXlsb2FkKTtcbiAgfVxuICBwaW5jaFN0YXJ0KGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLm9yaWdpbiA9IHBheWxvYWQub3JpZ2luO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhbcGF5bG9hZC5kaXN0YW5jZSwgcGF5bG9hZC5hbmdsZV0pO1xuICAgIHRoaXMuY29tcHV0ZUluaXRpYWwoKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHRvdWNoTW92ZShldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgY29uc3QgcGF5bG9hZCA9IHRvdWNoRGlzdGFuY2VBbmdsZShldmVudCwgdGhpcy5zdGF0ZS5fdG91Y2hJZHMpO1xuICAgIGlmICghcGF5bG9hZCkgcmV0dXJuO1xuICAgIHRoaXMucGluY2hNb3ZlKGV2ZW50LCBwYXlsb2FkKTtcbiAgfVxuICBwb2ludGVyTW92ZShldmVudCkge1xuICAgIGNvbnN0IF9wb2ludGVyRXZlbnRzID0gdGhpcy5zdGF0ZS5fcG9pbnRlckV2ZW50cztcbiAgICBpZiAoX3BvaW50ZXJFdmVudHMuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIF9wb2ludGVyRXZlbnRzLnNldChldmVudC5wb2ludGVySWQsIGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICBjb25zdCBwYXlsb2FkID0gZGlzdGFuY2VBbmdsZSguLi5BcnJheS5mcm9tKF9wb2ludGVyRXZlbnRzLnZhbHVlcygpKSk7XG4gICAgaWYgKCFwYXlsb2FkKSByZXR1cm47XG4gICAgdGhpcy5waW5jaE1vdmUoZXZlbnQsIHBheWxvYWQpO1xuICB9XG4gIHBpbmNoTW92ZShldmVudCwgcGF5bG9hZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBwcmV2X2EgPSBzdGF0ZS5fdmFsdWVzWzFdO1xuICAgIGNvbnN0IGRlbHRhX2EgPSBwYXlsb2FkLmFuZ2xlIC0gcHJldl9hO1xuICAgIGxldCBkZWx0YV90dXJucyA9IDA7XG4gICAgaWYgKE1hdGguYWJzKGRlbHRhX2EpID4gMjcwKSBkZWx0YV90dXJucyArPSBNYXRoLnNpZ24oZGVsdGFfYSk7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKFtwYXlsb2FkLmRpc3RhbmNlLCBwYXlsb2FkLmFuZ2xlIC0gMzYwICogZGVsdGFfdHVybnNdKTtcbiAgICBzdGF0ZS5vcmlnaW4gPSBwYXlsb2FkLm9yaWdpbjtcbiAgICBzdGF0ZS50dXJucyA9IGRlbHRhX3R1cm5zO1xuICAgIHN0YXRlLl9tb3ZlbWVudCA9IFtzdGF0ZS5fdmFsdWVzWzBdIC8gc3RhdGUuX2luaXRpYWxbMF0gLSAxLCBzdGF0ZS5fdmFsdWVzWzFdIC0gc3RhdGUuX2luaXRpYWxbMV1dO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgdG91Y2hFbmQoZXZlbnQpIHtcbiAgICB0aGlzLmN0cmwuc2V0RXZlbnRJZHMoZXZlbnQpO1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgaWYgKHRoaXMuc3RhdGUuX3RvdWNoSWRzLnNvbWUoaWQgPT4gIXRoaXMuY3RybC50b3VjaElkcy5oYXMoaWQpKSkge1xuICAgICAgdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfVxuICB9XG4gIHBvaW50ZXJFbmQoZXZlbnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5jdHJsLnNldEV2ZW50SWRzKGV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgZXZlbnQudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHt9XG4gICAgaWYgKHN0YXRlLl9wb2ludGVyRXZlbnRzLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICBzdGF0ZS5fcG9pbnRlckV2ZW50cy5kZWxldGUoZXZlbnQucG9pbnRlcklkKTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgaWYgKHN0YXRlLl9wb2ludGVyRXZlbnRzLnNpemUgPCAyKSB7XG4gICAgICBzdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfVxuICB9XG4gIGdlc3R1cmVTdGFydChldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhbZXZlbnQuc2NhbGUsIGV2ZW50LnJvdGF0aW9uXSk7XG4gICAgc3RhdGUub3JpZ2luID0gW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgZ2VzdHVyZU1vdmUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXMoW2V2ZW50LnNjYWxlLCBldmVudC5yb3RhdGlvbl0pO1xuICAgIHN0YXRlLm9yaWdpbiA9IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXTtcbiAgICBjb25zdCBfcHJldmlvdXNNb3ZlbWVudCA9IHN0YXRlLl9tb3ZlbWVudDtcbiAgICBzdGF0ZS5fbW92ZW1lbnQgPSBbZXZlbnQuc2NhbGUgLSAxLCBldmVudC5yb3RhdGlvbl07XG4gICAgc3RhdGUuX2RlbHRhID0gVi5zdWIoc3RhdGUuX21vdmVtZW50LCBfcHJldmlvdXNNb3ZlbWVudCk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBnZXN0dXJlRW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHdoZWVsKGV2ZW50KSB7XG4gICAgY29uc3QgbW9kaWZpZXJLZXkgPSB0aGlzLmNvbmZpZy5tb2RpZmllcktleTtcbiAgICBpZiAobW9kaWZpZXJLZXkgJiYgKEFycmF5LmlzQXJyYXkobW9kaWZpZXJLZXkpID8gIW1vZGlmaWVyS2V5LmZpbmQoayA9PiBldmVudFtrXSkgOiAhZXZlbnRbbW9kaWZpZXJLZXldKSkgcmV0dXJuO1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSB0aGlzLndoZWVsU3RhcnQoZXZlbnQpO2Vsc2UgdGhpcy53aGVlbENoYW5nZShldmVudCk7XG4gICAgdGhpcy50aW1lb3V0U3RvcmUuYWRkKCd3aGVlbEVuZCcsIHRoaXMud2hlZWxFbmQuYmluZCh0aGlzKSk7XG4gIH1cbiAgd2hlZWxTdGFydChldmVudCkge1xuICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHRoaXMud2hlZWxDaGFuZ2UoZXZlbnQpO1xuICB9XG4gIHdoZWVsQ2hhbmdlKGV2ZW50KSB7XG4gICAgY29uc3QgaXNSM2YgPSAoJ3V2JyBpbiBldmVudCk7XG4gICAgaWYgKCFpc1IzZikge1xuICAgICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtAdXNlLWdlc3R1cmVdOiBUbyBwcm9wZXJseSBzdXBwb3J0IHpvb20gb24gdHJhY2twYWRzLCB0cnkgdXNpbmcgdGhlIFxcYHRhcmdldFxcYCBvcHRpb24uXFxuXFxuVGhpcyBtZXNzYWdlIHdpbGwgb25seSBhcHBlYXIgaW4gZGV2ZWxvcG1lbnQgbW9kZS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl9kZWx0YSA9IFstd2hlZWxWYWx1ZXMoZXZlbnQpWzFdIC8gUElOQ0hfV0hFRUxfUkFUSU8gKiBzdGF0ZS5vZmZzZXRbMF0sIDBdO1xuICAgIFYuYWRkVG8oc3RhdGUuX21vdmVtZW50LCBzdGF0ZS5fZGVsdGEpO1xuICAgIGNsYW1wU3RhdGVJbnRlcm5hbE1vdmVtZW50VG9Cb3VuZHMoc3RhdGUpO1xuICAgIHRoaXMuc3RhdGUub3JpZ2luID0gW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgd2hlZWxFbmQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBiaW5kKGJpbmRGdW5jdGlvbikge1xuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuY29uZmlnLmRldmljZTtcbiAgICBpZiAoISFkZXZpY2UpIHtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdzdGFydCcsIHRoaXNbZGV2aWNlICsgJ1N0YXJ0J10uYmluZCh0aGlzKSk7XG4gICAgICBiaW5kRnVuY3Rpb24oZGV2aWNlLCAnY2hhbmdlJywgdGhpc1tkZXZpY2UgKyAnTW92ZSddLmJpbmQodGhpcykpO1xuICAgICAgYmluZEZ1bmN0aW9uKGRldmljZSwgJ2VuZCcsIHRoaXNbZGV2aWNlICsgJ0VuZCddLmJpbmQodGhpcykpO1xuICAgICAgYmluZEZ1bmN0aW9uKGRldmljZSwgJ2NhbmNlbCcsIHRoaXNbZGV2aWNlICsgJ0VuZCddLmJpbmQodGhpcykpO1xuICAgICAgYmluZEZ1bmN0aW9uKCdsb3N0UG9pbnRlckNhcHR1cmUnLCAnJywgdGhpc1tkZXZpY2UgKyAnRW5kJ10uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5waW5jaE9uV2hlZWwpIHtcbiAgICAgIGJpbmRGdW5jdGlvbignd2hlZWwnLCAnJywgdGhpcy53aGVlbC5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcGluY2hDb25maWdSZXNvbHZlciA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb21tb25Db25maWdSZXNvbHZlciksIHt9LCB7XG4gIGRldmljZShfdiwgX2ssIHtcbiAgICBzaGFyZWQsXG4gICAgcG9pbnRlcjoge1xuICAgICAgdG91Y2ggPSBmYWxzZVxuICAgIH0gPSB7fVxuICB9KSB7XG4gICAgY29uc3Qgc2hhcmVkQ29uZmlnID0gc2hhcmVkO1xuICAgIGlmIChzaGFyZWRDb25maWcudGFyZ2V0ICYmICFTVVBQT1JULnRvdWNoICYmIFNVUFBPUlQuZ2VzdHVyZSkgcmV0dXJuICdnZXN0dXJlJztcbiAgICBpZiAoU1VQUE9SVC50b3VjaCAmJiB0b3VjaCkgcmV0dXJuICd0b3VjaCc7XG4gICAgaWYgKFNVUFBPUlQudG91Y2hzY3JlZW4pIHtcbiAgICAgIGlmIChTVVBQT1JULnBvaW50ZXIpIHJldHVybiAncG9pbnRlcic7XG4gICAgICBpZiAoU1VQUE9SVC50b3VjaCkgcmV0dXJuICd0b3VjaCc7XG4gICAgfVxuICB9LFxuICBib3VuZHMoX3YsIF9rLCB7XG4gICAgc2NhbGVCb3VuZHMgPSB7fSxcbiAgICBhbmdsZUJvdW5kcyA9IHt9XG4gIH0pIHtcbiAgICBjb25zdCBfc2NhbGVCb3VuZHMgPSBzdGF0ZSA9PiB7XG4gICAgICBjb25zdCBEID0gYXNzaWduRGVmYXVsdChjYWxsKHNjYWxlQm91bmRzLCBzdGF0ZSksIHtcbiAgICAgICAgbWluOiAtSW5maW5pdHksXG4gICAgICAgIG1heDogSW5maW5pdHlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtELm1pbiwgRC5tYXhdO1xuICAgIH07XG4gICAgY29uc3QgX2FuZ2xlQm91bmRzID0gc3RhdGUgPT4ge1xuICAgICAgY29uc3QgQSA9IGFzc2lnbkRlZmF1bHQoY2FsbChhbmdsZUJvdW5kcywgc3RhdGUpLCB7XG4gICAgICAgIG1pbjogLUluZmluaXR5LFxuICAgICAgICBtYXg6IEluZmluaXR5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbQS5taW4sIEEubWF4XTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2Ygc2NhbGVCb3VuZHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFuZ2xlQm91bmRzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gW19zY2FsZUJvdW5kcygpLCBfYW5nbGVCb3VuZHMoKV07XG4gICAgcmV0dXJuIHN0YXRlID0+IFtfc2NhbGVCb3VuZHMoc3RhdGUpLCBfYW5nbGVCb3VuZHMoc3RhdGUpXTtcbiAgfSxcbiAgdGhyZXNob2xkKHZhbHVlLCBfaywgY29uZmlnKSB7XG4gICAgdGhpcy5sb2NrRGlyZWN0aW9uID0gY29uZmlnLmF4aXMgPT09ICdsb2NrJztcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBWLnRvVmVjdG9yKHZhbHVlLCB0aGlzLmxvY2tEaXJlY3Rpb24gPyBbMC4xLCAzXSA6IDApO1xuICAgIHJldHVybiB0aHJlc2hvbGQ7XG4gIH0sXG4gIG1vZGlmaWVyS2V5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiAnY3RybEtleSc7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBwaW5jaE9uV2hlZWwodmFsdWUgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59KTtcblxuY2xhc3MgTW92ZUVuZ2luZSBleHRlbmRzIENvb3JkaW5hdGVzRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZ0tleVwiLCAnbW92aW5nJyk7XG4gIH1cbiAgbW92ZShldmVudCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5tb3VzZU9ubHkgJiYgZXZlbnQucG9pbnRlclR5cGUgIT09ICdtb3VzZScpIHJldHVybjtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgdGhpcy5tb3ZlU3RhcnQoZXZlbnQpO2Vsc2UgdGhpcy5tb3ZlQ2hhbmdlKGV2ZW50KTtcbiAgICB0aGlzLnRpbWVvdXRTdG9yZS5hZGQoJ21vdmVFbmQnLCB0aGlzLm1vdmVFbmQuYmluZCh0aGlzKSk7XG4gIH1cbiAgbW92ZVN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5zdGFydChldmVudCk7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKHBvaW50ZXJWYWx1ZXMoZXZlbnQpKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuY29tcHV0ZUluaXRpYWwoKTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBtb3ZlQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICBjb25zdCB2YWx1ZXMgPSBwb2ludGVyVmFsdWVzKGV2ZW50KTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3RhdGUuX2RlbHRhID0gVi5zdWIodmFsdWVzLCBzdGF0ZS5fdmFsdWVzKTtcbiAgICBWLmFkZFRvKHN0YXRlLl9tb3ZlbWVudCwgc3RhdGUuX2RlbHRhKTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXModmFsdWVzKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIG1vdmVFbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgYmluZChiaW5kRnVuY3Rpb24pIHtcbiAgICBiaW5kRnVuY3Rpb24oJ3BvaW50ZXInLCAnY2hhbmdlJywgdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICAgIGJpbmRGdW5jdGlvbigncG9pbnRlcicsICdsZWF2ZScsIHRoaXMubW92ZUVuZC5iaW5kKHRoaXMpKTtcbiAgfVxufVxuXG5jb25zdCBtb3ZlQ29uZmlnUmVzb2x2ZXIgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29vcmRpbmF0ZXNDb25maWdSZXNvbHZlciksIHt9LCB7XG4gIG1vdXNlT25seTogKHZhbHVlID0gdHJ1ZSkgPT4gdmFsdWVcbn0pO1xuXG5jbGFzcyBTY3JvbGxFbmdpbmUgZXh0ZW5kcyBDb29yZGluYXRlc0VuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmdLZXlcIiwgJ3Njcm9sbGluZycpO1xuICB9XG4gIHNjcm9sbChldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLnNjcm9sbENoYW5nZShldmVudCk7XG4gICAgdGhpcy50aW1lb3V0U3RvcmUuYWRkKCdzY3JvbGxFbmQnLCB0aGlzLnNjcm9sbEVuZC5iaW5kKHRoaXMpKTtcbiAgfVxuICBzY3JvbGxDaGFuZ2UoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgdmFsdWVzID0gc2Nyb2xsVmFsdWVzKGV2ZW50KTtcbiAgICBzdGF0ZS5fZGVsdGEgPSBWLnN1Yih2YWx1ZXMsIHN0YXRlLl92YWx1ZXMpO1xuICAgIFYuYWRkVG8oc3RhdGUuX21vdmVtZW50LCBzdGF0ZS5fZGVsdGEpO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyh2YWx1ZXMpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgc2Nyb2xsRW5kKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jb21wdXRlKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgYmluZChiaW5kRnVuY3Rpb24pIHtcbiAgICBiaW5kRnVuY3Rpb24oJ3Njcm9sbCcsICcnLCB0aGlzLnNjcm9sbC5iaW5kKHRoaXMpKTtcbiAgfVxufVxuXG5jb25zdCBzY3JvbGxDb25maWdSZXNvbHZlciA9IGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXI7XG5cbmNsYXNzIFdoZWVsRW5naW5lIGV4dGVuZHMgQ29vcmRpbmF0ZXNFbmdpbmUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5nS2V5XCIsICd3aGVlbGluZycpO1xuICB9XG4gIHdoZWVsKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHRoaXMud2hlZWxDaGFuZ2UoZXZlbnQpO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmFkZCgnd2hlZWxFbmQnLCB0aGlzLndoZWVsRW5kLmJpbmQodGhpcykpO1xuICB9XG4gIHdoZWVsQ2hhbmdlKGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl9kZWx0YSA9IHdoZWVsVmFsdWVzKGV2ZW50KTtcbiAgICBWLmFkZFRvKHN0YXRlLl9tb3ZlbWVudCwgc3RhdGUuX2RlbHRhKTtcbiAgICBjbGFtcFN0YXRlSW50ZXJuYWxNb3ZlbWVudFRvQm91bmRzKHN0YXRlKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHdoZWVsRW5kKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jb21wdXRlKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgYmluZChiaW5kRnVuY3Rpb24pIHtcbiAgICBiaW5kRnVuY3Rpb24oJ3doZWVsJywgJycsIHRoaXMud2hlZWwuYmluZCh0aGlzKSk7XG4gIH1cbn1cblxuY29uc3Qgd2hlZWxDb25maWdSZXNvbHZlciA9IGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXI7XG5cbmNsYXNzIEhvdmVyRW5naW5lIGV4dGVuZHMgQ29vcmRpbmF0ZXNFbmdpbmUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5nS2V5XCIsICdob3ZlcmluZycpO1xuICB9XG4gIGVudGVyKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLm1vdXNlT25seSAmJiBldmVudC5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJykgcmV0dXJuO1xuICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhwb2ludGVyVmFsdWVzKGV2ZW50KSk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBsZWF2ZShldmVudCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5tb3VzZU9ubHkgJiYgZXZlbnQucG9pbnRlclR5cGUgIT09ICdtb3VzZScpIHJldHVybjtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHBvaW50ZXJWYWx1ZXMoZXZlbnQpO1xuICAgIHN0YXRlLl9tb3ZlbWVudCA9IHN0YXRlLl9kZWx0YSA9IFYuc3ViKHZhbHVlcywgc3RhdGUuX3ZhbHVlcyk7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKHZhbHVlcyk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICBzdGF0ZS5kZWx0YSA9IHN0YXRlLm1vdmVtZW50O1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGJpbmQoYmluZEZ1bmN0aW9uKSB7XG4gICAgYmluZEZ1bmN0aW9uKCdwb2ludGVyJywgJ2VudGVyJywgdGhpcy5lbnRlci5iaW5kKHRoaXMpKTtcbiAgICBiaW5kRnVuY3Rpb24oJ3BvaW50ZXInLCAnbGVhdmUnLCB0aGlzLmxlYXZlLmJpbmQodGhpcykpO1xuICB9XG59XG5cbmNvbnN0IGhvdmVyQ29uZmlnUmVzb2x2ZXIgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29vcmRpbmF0ZXNDb25maWdSZXNvbHZlciksIHt9LCB7XG4gIG1vdXNlT25seTogKHZhbHVlID0gdHJ1ZSkgPT4gdmFsdWVcbn0pO1xuXG5jb25zdCBFbmdpbmVNYXAgPSBuZXcgTWFwKCk7XG5jb25zdCBDb25maWdSZXNvbHZlck1hcCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyQWN0aW9uKGFjdGlvbikge1xuICBFbmdpbmVNYXAuc2V0KGFjdGlvbi5rZXksIGFjdGlvbi5lbmdpbmUpO1xuICBDb25maWdSZXNvbHZlck1hcC5zZXQoYWN0aW9uLmtleSwgYWN0aW9uLnJlc29sdmVyKTtcbn1cbmNvbnN0IGRyYWdBY3Rpb24gPSB7XG4gIGtleTogJ2RyYWcnLFxuICBlbmdpbmU6IERyYWdFbmdpbmUsXG4gIHJlc29sdmVyOiBkcmFnQ29uZmlnUmVzb2x2ZXJcbn07XG5jb25zdCBob3ZlckFjdGlvbiA9IHtcbiAga2V5OiAnaG92ZXInLFxuICBlbmdpbmU6IEhvdmVyRW5naW5lLFxuICByZXNvbHZlcjogaG92ZXJDb25maWdSZXNvbHZlclxufTtcbmNvbnN0IG1vdmVBY3Rpb24gPSB7XG4gIGtleTogJ21vdmUnLFxuICBlbmdpbmU6IE1vdmVFbmdpbmUsXG4gIHJlc29sdmVyOiBtb3ZlQ29uZmlnUmVzb2x2ZXJcbn07XG5jb25zdCBwaW5jaEFjdGlvbiA9IHtcbiAga2V5OiAncGluY2gnLFxuICBlbmdpbmU6IFBpbmNoRW5naW5lLFxuICByZXNvbHZlcjogcGluY2hDb25maWdSZXNvbHZlclxufTtcbmNvbnN0IHNjcm9sbEFjdGlvbiA9IHtcbiAga2V5OiAnc2Nyb2xsJyxcbiAgZW5naW5lOiBTY3JvbGxFbmdpbmUsXG4gIHJlc29sdmVyOiBzY3JvbGxDb25maWdSZXNvbHZlclxufTtcbmNvbnN0IHdoZWVsQWN0aW9uID0ge1xuICBrZXk6ICd3aGVlbCcsXG4gIGVuZ2luZTogV2hlZWxFbmdpbmUsXG4gIHJlc29sdmVyOiB3aGVlbENvbmZpZ1Jlc29sdmVyXG59O1xuXG5leHBvcnQgeyBDb25maWdSZXNvbHZlck1hcCBhcyBDLCBFbmdpbmVNYXAgYXMgRSwgU1VQUE9SVCBhcyBTLCBfb2JqZWN0U3ByZWFkMiBhcyBfLCBfZGVmaW5lUHJvcGVydHkgYXMgYSwgdG91Y2hJZHMgYXMgYiwgY2hhaW4gYXMgYywgdG9IYW5kbGVyUHJvcCBhcyBkLCBkcmFnQWN0aW9uIGFzIGUsIHBpbmNoQWN0aW9uIGFzIGYsIGhvdmVyQWN0aW9uIGFzIGgsIGlzVG91Y2ggYXMgaSwgbW92ZUFjdGlvbiBhcyBtLCBwYXJzZVByb3AgYXMgcCwgcmVnaXN0ZXJBY3Rpb24gYXMgciwgc2Nyb2xsQWN0aW9uIGFzIHMsIHRvRG9tRXZlbnRUeXBlIGFzIHQsIHdoZWVsQWN0aW9uIGFzIHcgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* binding */ V),\n/* harmony export */   c: () => (/* binding */ computeRubberband),\n/* harmony export */   r: () => (/* binding */ rubberbandIfOutOfBounds)\n/* harmony export */ });\nfunction clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n};\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC9tYXRocy0wYWIzOWFlOS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvY29yZS9kaXN0L21hdGhzLTBhYjM5YWU5LmVzbS5qcz84MTIwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNsYW1wKHYsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHYsIG1heCkpO1xufVxuY29uc3QgViA9IHtcbiAgdG9WZWN0b3IodiwgZmFsbGJhY2spIHtcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB2ID0gZmFsbGJhY2s7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodikgPyB2IDogW3YsIHZdO1xuICB9LFxuICBhZGQodjEsIHYyKSB7XG4gICAgcmV0dXJuIFt2MVswXSArIHYyWzBdLCB2MVsxXSArIHYyWzFdXTtcbiAgfSxcbiAgc3ViKHYxLCB2Mikge1xuICAgIHJldHVybiBbdjFbMF0gLSB2MlswXSwgdjFbMV0gLSB2MlsxXV07XG4gIH0sXG4gIGFkZFRvKHYxLCB2Mikge1xuICAgIHYxWzBdICs9IHYyWzBdO1xuICAgIHYxWzFdICs9IHYyWzFdO1xuICB9LFxuICBzdWJUbyh2MSwgdjIpIHtcbiAgICB2MVswXSAtPSB2MlswXTtcbiAgICB2MVsxXSAtPSB2MlsxXTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJ1YmJlcmJhbmQoZGlzdGFuY2UsIGRpbWVuc2lvbiwgY29uc3RhbnQpIHtcbiAgaWYgKGRpbWVuc2lvbiA9PT0gMCB8fCBNYXRoLmFicyhkaW1lbnNpb24pID09PSBJbmZpbml0eSkgcmV0dXJuIE1hdGgucG93KGRpc3RhbmNlLCBjb25zdGFudCAqIDUpO1xuICByZXR1cm4gZGlzdGFuY2UgKiBkaW1lbnNpb24gKiBjb25zdGFudCAvIChkaW1lbnNpb24gKyBjb25zdGFudCAqIGRpc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHJ1YmJlcmJhbmRJZk91dE9mQm91bmRzKHBvc2l0aW9uLCBtaW4sIG1heCwgY29uc3RhbnQgPSAwLjE1KSB7XG4gIGlmIChjb25zdGFudCA9PT0gMCkgcmV0dXJuIGNsYW1wKHBvc2l0aW9uLCBtaW4sIG1heCk7XG4gIGlmIChwb3NpdGlvbiA8IG1pbikgcmV0dXJuIC1ydWJiZXJiYW5kKG1pbiAtIHBvc2l0aW9uLCBtYXggLSBtaW4sIGNvbnN0YW50KSArIG1pbjtcbiAgaWYgKHBvc2l0aW9uID4gbWF4KSByZXR1cm4gK3J1YmJlcmJhbmQocG9zaXRpb24gLSBtYXgsIG1heCAtIG1pbiwgY29uc3RhbnQpICsgbWF4O1xuICByZXR1cm4gcG9zaXRpb247XG59XG5mdW5jdGlvbiBjb21wdXRlUnViYmVyYmFuZChib3VuZHMsIFtWeCwgVnldLCBbUngsIFJ5XSkge1xuICBjb25zdCBbW1gwLCBYMV0sIFtZMCwgWTFdXSA9IGJvdW5kcztcbiAgcmV0dXJuIFtydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyhWeCwgWDAsIFgxLCBSeCksIHJ1YmJlcmJhbmRJZk91dE9mQm91bmRzKFZ5LCBZMCwgWTEsIFJ5KV07XG59XG5cbmV4cG9ydCB7IFYsIGNvbXB1dGVSdWJiZXJiYW5kIGFzIGMsIHJ1YmJlcmJhbmRJZk91dE9mQm91bmRzIGFzIHIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   parseMergedHandlers: () => (/* binding */ parseMergedHandlers)\n/* harmony export */ });\n/* harmony import */ var _actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions-fe213e88.esm.js */ \"(ssr)/./node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js\");\n\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n    return undefined;\n  },\n  enabled(value = true) {\n    return value;\n  },\n  window(value = _actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.S.isBrowser ? window : undefined) {\n    return value;\n  },\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n  transform(value) {\n    return value;\n  }\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case 'function':\n        if (true) {\n          const r = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r)) result[key] = r;\n        } else {}\n        break;\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n  return result;\n}\nfunction parse(newConfig, gestureKey, _config = {}) {\n  const _ref = newConfig,\n    {\n      target,\n      eventOptions,\n      window,\n      enabled,\n      transform\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  _config.shared = resolveWith({\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  }, sharedConfigResolver);\n  if (gestureKey) {\n    const resolver = _actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.C.get(gestureKey);\n    _config[gestureKey] = resolveWith((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = _actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.C.get(key);\n      if (resolver) {\n        _config[key] = resolveWith((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (true) {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl, gestureKey) {\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"_listeners\", new Set());\n    this._ctrl = ctrl;\n    this._gestureKey = gestureKey;\n  }\n  add(element, device, action, handler, options) {\n    const listeners = this._listeners;\n    const type = (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(device, action);\n    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};\n    const eventOptions = (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, _options), options);\n    element.addEventListener(type, handler, eventOptions);\n    const remove = () => {\n      element.removeEventListener(type, handler, eventOptions);\n      listeners.delete(remove);\n    };\n    listeners.add(remove);\n    return remove;\n  }\n  clean() {\n    this._listeners.forEach(remove => remove());\n    this._listeners.clear();\n  }\n}\n\nclass TimeoutStore {\n  constructor() {\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"_timeouts\", new Map());\n  }\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n    if (timeout) window.clearTimeout(timeout);\n  }\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n    this._timeouts.clear();\n  }\n}\n\nclass Controller {\n  constructor(handlers) {\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"gestures\", new Set());\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"_targetEventStore\", new EventStore(this));\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"gestureEventStores\", {});\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"gestureTimeoutStores\", {});\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"handlers\", {});\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"config\", {});\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"pointerIds\", new Set());\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"touchIds\", new Set());\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n    resolveGestures(this, handlers);\n  }\n  setEventIds(event) {\n    if ((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(event)) {\n      this.touchIds = new Set((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(event));\n      return this.touchIds;\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n      return this.pointerIds;\n    }\n  }\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey, this.config);\n  }\n  clean() {\n    this._targetEventStore.clean();\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const props = {};\n    let target;\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        const gestureConfig = this.config[gestureKey];\n        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);\n        if (gestureConfig.enabled) {\n          const Engine = _actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.E.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);\n      for (const eventKey in this.nativeHandlers) {\n        nativeBindFunction(eventKey, '', event => this.nativeHandlers[eventKey]((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n    for (const handlerProp in props) {\n      props[handlerProp] = (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(...props[handlerProp]);\n    }\n    if (!target) return props;\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(handlerProp);\n      this._targetEventStore.add(target, device, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n}\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n  return [handlers, native, actions];\n}\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n  if (!_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.E.has(key)) {\n    if (true) {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n    return;\n  }\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOE87QUFDN007O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQix1REFBTztBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBc0M7QUFDbEQ7QUFDQTtBQUNBLFVBQVUsS0FBSyxFQUVOO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQix1REFBaUI7QUFDdEMsc0NBQXNDLDJEQUFjO0FBQ3BEO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLHVCQUF1Qix1REFBaUI7QUFDeEM7QUFDQSxtQ0FBbUMsMkRBQWM7QUFDakQ7QUFDQSxTQUFTO0FBQ1QsUUFBUSxTQUFTLElBQXNDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDJEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQWM7QUFDL0I7QUFDQSx5QkFBeUIsMkRBQWMsQ0FBQywyREFBYyxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDJEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksMkRBQWU7QUFDbkIsSUFBSSwyREFBZTtBQUNuQixJQUFJLDJEQUFlLCtCQUErQjtBQUNsRCxJQUFJLDJEQUFlLGlDQUFpQztBQUNwRCxJQUFJLDJEQUFlLHFCQUFxQjtBQUN4QyxJQUFJLDJEQUFlLG1CQUFtQjtBQUN0QyxJQUFJLDJEQUFlO0FBQ25CLElBQUksMkRBQWU7QUFDbkIsSUFBSSwyREFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBTztBQUNmLDhCQUE4QiwyREFBUTtBQUN0QztBQUNBLE1BQU07QUFDTixnSEFBZ0g7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiwyREFBYyxDQUFDLDJEQUFjLEdBQUcsd0JBQXdCO0FBQ3hJO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxFQUFFLDJEQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkRBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1REFBUztBQUNoQixRQUFRLElBQXNDO0FBQzlDLDJGQUEyRixJQUFJLDREQUE0RCxJQUFJO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvY29yZS9kaXN0L3VzZS1nZXN0dXJlLWNvcmUuZXNtLmpzP2NiYjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUyBhcyBTVVBQT1JULCBDIGFzIENvbmZpZ1Jlc29sdmVyTWFwLCBfIGFzIF9vYmplY3RTcHJlYWQyLCBhIGFzIF9kZWZpbmVQcm9wZXJ0eSwgdCBhcyB0b0RvbUV2ZW50VHlwZSwgaSBhcyBpc1RvdWNoLCBiIGFzIHRvdWNoSWRzLCBFIGFzIEVuZ2luZU1hcCwgYyBhcyBjaGFpbiwgcCBhcyBwYXJzZVByb3AsIGQgYXMgdG9IYW5kbGVyUHJvcCB9IGZyb20gJy4vYWN0aW9ucy1mZTIxM2U4OC5lc20uanMnO1xuaW1wb3J0ICcuL21hdGhzLTBhYjM5YWU5LmVzbS5qcyc7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmNvbnN0IHNoYXJlZENvbmZpZ1Jlc29sdmVyID0ge1xuICB0YXJnZXQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiAoKSA9PiAnY3VycmVudCcgaW4gdmFsdWUgPyB2YWx1ZS5jdXJyZW50IDogdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG4gIGVuYWJsZWQodmFsdWUgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB3aW5kb3codmFsdWUgPSBTVVBQT1JULmlzQnJvd3NlciA/IHdpbmRvdyA6IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgZXZlbnRPcHRpb25zKHtcbiAgICBwYXNzaXZlID0gdHJ1ZSxcbiAgICBjYXB0dXJlID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhc3NpdmUsXG4gICAgICBjYXB0dXJlXG4gICAgfTtcbiAgfSxcbiAgdHJhbnNmb3JtKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJ0YXJnZXRcIiwgXCJldmVudE9wdGlvbnNcIiwgXCJ3aW5kb3dcIiwgXCJlbmFibGVkXCIsIFwidHJhbnNmb3JtXCJdO1xuZnVuY3Rpb24gcmVzb2x2ZVdpdGgoY29uZmlnID0ge30sIHJlc29sdmVycykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCByZXNvbHZlcl0gb2YgT2JqZWN0LmVudHJpZXMocmVzb2x2ZXJzKSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHJlc29sdmVyKSB7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGNvbnN0IHIgPSByZXNvbHZlci5jYWxsKHJlc3VsdCwgY29uZmlnW2tleV0sIGtleSwgY29uZmlnKTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihyKSkgcmVzdWx0W2tleV0gPSByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gcmVzb2x2ZXIuY2FsbChyZXN1bHQsIGNvbmZpZ1trZXldLCBrZXksIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXN1bHRba2V5XSA9IHJlc29sdmVXaXRoKGNvbmZpZ1trZXldLCByZXNvbHZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGlmIChyZXNvbHZlcikgcmVzdWx0W2tleV0gPSBjb25maWdba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZShuZXdDb25maWcsIGdlc3R1cmVLZXksIF9jb25maWcgPSB7fSkge1xuICBjb25zdCBfcmVmID0gbmV3Q29uZmlnLFxuICAgIHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGV2ZW50T3B0aW9ucyxcbiAgICAgIHdpbmRvdyxcbiAgICAgIGVuYWJsZWQsXG4gICAgICB0cmFuc2Zvcm1cbiAgICB9ID0gX3JlZixcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIF9jb25maWcuc2hhcmVkID0gcmVzb2x2ZVdpdGgoe1xuICAgIHRhcmdldCxcbiAgICBldmVudE9wdGlvbnMsXG4gICAgd2luZG93LFxuICAgIGVuYWJsZWQsXG4gICAgdHJhbnNmb3JtXG4gIH0sIHNoYXJlZENvbmZpZ1Jlc29sdmVyKTtcbiAgaWYgKGdlc3R1cmVLZXkpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IENvbmZpZ1Jlc29sdmVyTWFwLmdldChnZXN0dXJlS2V5KTtcbiAgICBfY29uZmlnW2dlc3R1cmVLZXldID0gcmVzb2x2ZVdpdGgoX29iamVjdFNwcmVhZDIoe1xuICAgICAgc2hhcmVkOiBfY29uZmlnLnNoYXJlZFxuICAgIH0sIHJlc3QpLCByZXNvbHZlcik7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdCkge1xuICAgICAgY29uc3QgcmVzb2x2ZXIgPSBDb25maWdSZXNvbHZlck1hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICBfY29uZmlnW2tleV0gPSByZXNvbHZlV2l0aChfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgc2hhcmVkOiBfY29uZmlnLnNoYXJlZFxuICAgICAgICB9LCByZXN0W2tleV0pLCByZXNvbHZlcik7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGlmICghWydkcmFnJywgJ3BpbmNoJywgJ3Njcm9sbCcsICd3aGVlbCcsICdtb3ZlJywgJ2hvdmVyJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGlmIChrZXkgPT09ICdkb21UYXJnZXQnKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYGRvbVRhcmdldFxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGB0YXJnZXRcXGAuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUud2FybihgW0B1c2UtZ2VzdHVyZV06IFVua25vd24gY29uZmlnIGtleSBcXGAke2tleX1cXGAgd2FzIHVzZWQuIFBsZWFzZSByZWFkIHRoZSBkb2N1bWVudGF0aW9uIGZvciBmdXJ0aGVyIGluZm9ybWF0aW9uLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBfY29uZmlnO1xufVxuXG5jbGFzcyBFdmVudFN0b3JlIHtcbiAgY29uc3RydWN0b3IoY3RybCwgZ2VzdHVyZUtleSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9saXN0ZW5lcnNcIiwgbmV3IFNldCgpKTtcbiAgICB0aGlzLl9jdHJsID0gY3RybDtcbiAgICB0aGlzLl9nZXN0dXJlS2V5ID0gZ2VzdHVyZUtleTtcbiAgfVxuICBhZGQoZWxlbWVudCwgZGV2aWNlLCBhY3Rpb24sIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgdHlwZSA9IHRvRG9tRXZlbnRUeXBlKGRldmljZSwgYWN0aW9uKTtcbiAgICBjb25zdCBfb3B0aW9ucyA9IHRoaXMuX2dlc3R1cmVLZXkgPyB0aGlzLl9jdHJsLmNvbmZpZ1t0aGlzLl9nZXN0dXJlS2V5XS5ldmVudE9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCBldmVudE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgX29wdGlvbnMpLCBvcHRpb25zKTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZXZlbnRPcHRpb25zKTtcbiAgICBjb25zdCByZW1vdmUgPSAoKSA9PiB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZXZlbnRPcHRpb25zKTtcbiAgICAgIGxpc3RlbmVycy5kZWxldGUocmVtb3ZlKTtcbiAgICB9O1xuICAgIGxpc3RlbmVycy5hZGQocmVtb3ZlKTtcbiAgICByZXR1cm4gcmVtb3ZlO1xuICB9XG4gIGNsZWFuKCkge1xuICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKHJlbW92ZSA9PiByZW1vdmUoKSk7XG4gICAgdGhpcy5fbGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbn1cblxuY2xhc3MgVGltZW91dFN0b3JlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RpbWVvdXRzXCIsIG5ldyBNYXAoKSk7XG4gIH1cbiAgYWRkKGtleSwgY2FsbGJhY2ssIG1zID0gMTQwLCAuLi5hcmdzKSB7XG4gICAgdGhpcy5yZW1vdmUoa2V5KTtcbiAgICB0aGlzLl90aW1lb3V0cy5zZXQoa2V5LCB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpKTtcbiAgfVxuICByZW1vdmUoa2V5KSB7XG4gICAgY29uc3QgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRzLmdldChrZXkpO1xuICAgIGlmICh0aW1lb3V0KSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB9XG4gIGNsZWFuKCkge1xuICAgIHRoaXMuX3RpbWVvdXRzLmZvckVhY2godGltZW91dCA9PiB2b2lkIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCkpO1xuICAgIHRoaXMuX3RpbWVvdXRzLmNsZWFyKCk7XG4gIH1cbn1cblxuY2xhc3MgQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhhbmRsZXJzKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VzdHVyZXNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0RXZlbnRTdG9yZVwiLCBuZXcgRXZlbnRTdG9yZSh0aGlzKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VzdHVyZUV2ZW50U3RvcmVzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXN0dXJlVGltZW91dFN0b3Jlc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlcnNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicG9pbnRlcklkc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoSWRzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgc2hhcmVkOiB7XG4gICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICBhbHRLZXk6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzb2x2ZUdlc3R1cmVzKHRoaXMsIGhhbmRsZXJzKTtcbiAgfVxuICBzZXRFdmVudElkcyhldmVudCkge1xuICAgIGlmIChpc1RvdWNoKGV2ZW50KSkge1xuICAgICAgdGhpcy50b3VjaElkcyA9IG5ldyBTZXQodG91Y2hJZHMoZXZlbnQpKTtcbiAgICAgIHJldHVybiB0aGlzLnRvdWNoSWRzO1xuICAgIH0gZWxzZSBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSAncG9pbnRlcnVwJyB8fCBldmVudC50eXBlID09PSAncG9pbnRlcmNhbmNlbCcpIHRoaXMucG9pbnRlcklkcy5kZWxldGUoZXZlbnQucG9pbnRlcklkKTtlbHNlIGlmIChldmVudC50eXBlID09PSAncG9pbnRlcmRvd24nKSB0aGlzLnBvaW50ZXJJZHMuYWRkKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICByZXR1cm4gdGhpcy5wb2ludGVySWRzO1xuICAgIH1cbiAgfVxuICBhcHBseUhhbmRsZXJzKGhhbmRsZXJzLCBuYXRpdmVIYW5kbGVycykge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICB0aGlzLm5hdGl2ZUhhbmRsZXJzID0gbmF0aXZlSGFuZGxlcnM7XG4gIH1cbiAgYXBwbHlDb25maWcoY29uZmlnLCBnZXN0dXJlS2V5KSB7XG4gICAgdGhpcy5jb25maWcgPSBwYXJzZShjb25maWcsIGdlc3R1cmVLZXksIHRoaXMuY29uZmlnKTtcbiAgfVxuICBjbGVhbigpIHtcbiAgICB0aGlzLl90YXJnZXRFdmVudFN0b3JlLmNsZWFuKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5nZXN0dXJlcykge1xuICAgICAgdGhpcy5nZXN0dXJlRXZlbnRTdG9yZXNba2V5XS5jbGVhbigpO1xuICAgICAgdGhpcy5nZXN0dXJlVGltZW91dFN0b3Jlc1trZXldLmNsZWFuKCk7XG4gICAgfVxuICB9XG4gIGVmZmVjdCgpIHtcbiAgICBpZiAodGhpcy5jb25maWcuc2hhcmVkLnRhcmdldCkgdGhpcy5iaW5kKCk7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuX3RhcmdldEV2ZW50U3RvcmUuY2xlYW4oKTtcbiAgfVxuICBiaW5kKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzaGFyZWRDb25maWcgPSB0aGlzLmNvbmZpZy5zaGFyZWQ7XG4gICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIGlmIChzaGFyZWRDb25maWcudGFyZ2V0KSB7XG4gICAgICB0YXJnZXQgPSBzaGFyZWRDb25maWcudGFyZ2V0KCk7XG4gICAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hhcmVkQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIGZvciAoY29uc3QgZ2VzdHVyZUtleSBvZiB0aGlzLmdlc3R1cmVzKSB7XG4gICAgICAgIGNvbnN0IGdlc3R1cmVDb25maWcgPSB0aGlzLmNvbmZpZ1tnZXN0dXJlS2V5XTtcbiAgICAgICAgY29uc3QgYmluZEZ1bmN0aW9uID0gYmluZFRvUHJvcHMocHJvcHMsIGdlc3R1cmVDb25maWcuZXZlbnRPcHRpb25zLCAhIXRhcmdldCk7XG4gICAgICAgIGlmIChnZXN0dXJlQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgICAgICBjb25zdCBFbmdpbmUgPSBFbmdpbmVNYXAuZ2V0KGdlc3R1cmVLZXkpO1xuICAgICAgICAgIG5ldyBFbmdpbmUodGhpcywgYXJncywgZ2VzdHVyZUtleSkuYmluZChiaW5kRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBuYXRpdmVCaW5kRnVuY3Rpb24gPSBiaW5kVG9Qcm9wcyhwcm9wcywgc2hhcmVkQ29uZmlnLmV2ZW50T3B0aW9ucywgISF0YXJnZXQpO1xuICAgICAgZm9yIChjb25zdCBldmVudEtleSBpbiB0aGlzLm5hdGl2ZUhhbmRsZXJzKSB7XG4gICAgICAgIG5hdGl2ZUJpbmRGdW5jdGlvbihldmVudEtleSwgJycsIGV2ZW50ID0+IHRoaXMubmF0aXZlSGFuZGxlcnNbZXZlbnRLZXldKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnN0YXRlLnNoYXJlZCksIHt9LCB7XG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgYXJnc1xuICAgICAgICB9KSksIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgaGFuZGxlclByb3AgaW4gcHJvcHMpIHtcbiAgICAgIHByb3BzW2hhbmRsZXJQcm9wXSA9IGNoYWluKC4uLnByb3BzW2hhbmRsZXJQcm9wXSk7XG4gICAgfVxuICAgIGlmICghdGFyZ2V0KSByZXR1cm4gcHJvcHM7XG4gICAgZm9yIChjb25zdCBoYW5kbGVyUHJvcCBpbiBwcm9wcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkZXZpY2UsXG4gICAgICAgIGNhcHR1cmUsXG4gICAgICAgIHBhc3NpdmVcbiAgICAgIH0gPSBwYXJzZVByb3AoaGFuZGxlclByb3ApO1xuICAgICAgdGhpcy5fdGFyZ2V0RXZlbnRTdG9yZS5hZGQodGFyZ2V0LCBkZXZpY2UsICcnLCBwcm9wc1toYW5kbGVyUHJvcF0sIHtcbiAgICAgICAgY2FwdHVyZSxcbiAgICAgICAgcGFzc2l2ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXR1cEdlc3R1cmUoY3RybCwgZ2VzdHVyZUtleSkge1xuICBjdHJsLmdlc3R1cmVzLmFkZChnZXN0dXJlS2V5KTtcbiAgY3RybC5nZXN0dXJlRXZlbnRTdG9yZXNbZ2VzdHVyZUtleV0gPSBuZXcgRXZlbnRTdG9yZShjdHJsLCBnZXN0dXJlS2V5KTtcbiAgY3RybC5nZXN0dXJlVGltZW91dFN0b3Jlc1tnZXN0dXJlS2V5XSA9IG5ldyBUaW1lb3V0U3RvcmUoKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVHZXN0dXJlcyhjdHJsLCBpbnRlcm5hbEhhbmRsZXJzKSB7XG4gIGlmIChpbnRlcm5hbEhhbmRsZXJzLmRyYWcpIHNldHVwR2VzdHVyZShjdHJsLCAnZHJhZycpO1xuICBpZiAoaW50ZXJuYWxIYW5kbGVycy53aGVlbCkgc2V0dXBHZXN0dXJlKGN0cmwsICd3aGVlbCcpO1xuICBpZiAoaW50ZXJuYWxIYW5kbGVycy5zY3JvbGwpIHNldHVwR2VzdHVyZShjdHJsLCAnc2Nyb2xsJyk7XG4gIGlmIChpbnRlcm5hbEhhbmRsZXJzLm1vdmUpIHNldHVwR2VzdHVyZShjdHJsLCAnbW92ZScpO1xuICBpZiAoaW50ZXJuYWxIYW5kbGVycy5waW5jaCkgc2V0dXBHZXN0dXJlKGN0cmwsICdwaW5jaCcpO1xuICBpZiAoaW50ZXJuYWxIYW5kbGVycy5ob3Zlcikgc2V0dXBHZXN0dXJlKGN0cmwsICdob3ZlcicpO1xufVxuY29uc3QgYmluZFRvUHJvcHMgPSAocHJvcHMsIGV2ZW50T3B0aW9ucywgd2l0aFBhc3NpdmVPcHRpb24pID0+IChkZXZpY2UsIGFjdGlvbiwgaGFuZGxlciwgb3B0aW9ucyA9IHt9LCBpc05hdGl2ZSA9IGZhbHNlKSA9PiB7XG4gIHZhciBfb3B0aW9ucyRjYXB0dXJlLCBfb3B0aW9ucyRwYXNzaXZlO1xuICBjb25zdCBjYXB0dXJlID0gKF9vcHRpb25zJGNhcHR1cmUgPSBvcHRpb25zLmNhcHR1cmUpICE9PSBudWxsICYmIF9vcHRpb25zJGNhcHR1cmUgIT09IHZvaWQgMCA/IF9vcHRpb25zJGNhcHR1cmUgOiBldmVudE9wdGlvbnMuY2FwdHVyZTtcbiAgY29uc3QgcGFzc2l2ZSA9IChfb3B0aW9ucyRwYXNzaXZlID0gb3B0aW9ucy5wYXNzaXZlKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRwYXNzaXZlICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRwYXNzaXZlIDogZXZlbnRPcHRpb25zLnBhc3NpdmU7XG4gIGxldCBoYW5kbGVyUHJvcCA9IGlzTmF0aXZlID8gZGV2aWNlIDogdG9IYW5kbGVyUHJvcChkZXZpY2UsIGFjdGlvbiwgY2FwdHVyZSk7XG4gIGlmICh3aXRoUGFzc2l2ZU9wdGlvbiAmJiBwYXNzaXZlKSBoYW5kbGVyUHJvcCArPSAnUGFzc2l2ZSc7XG4gIHByb3BzW2hhbmRsZXJQcm9wXSA9IHByb3BzW2hhbmRsZXJQcm9wXSB8fCBbXTtcbiAgcHJvcHNbaGFuZGxlclByb3BdLnB1c2goaGFuZGxlcik7XG59O1xuXG5jb25zdCBSRV9OT1RfTkFUSVZFID0gL15vbihEcmFnfFdoZWVsfFNjcm9sbHxNb3ZlfFBpbmNofEhvdmVyKS87XG5mdW5jdGlvbiBzb3J0SGFuZGxlcnMoX2hhbmRsZXJzKSB7XG4gIGNvbnN0IG5hdGl2ZSA9IHt9O1xuICBjb25zdCBoYW5kbGVycyA9IHt9O1xuICBjb25zdCBhY3Rpb25zID0gbmV3IFNldCgpO1xuICBmb3IgKGxldCBrZXkgaW4gX2hhbmRsZXJzKSB7XG4gICAgaWYgKFJFX05PVF9OQVRJVkUudGVzdChrZXkpKSB7XG4gICAgICBhY3Rpb25zLmFkZChSZWdFeHAubGFzdE1hdGNoKTtcbiAgICAgIGhhbmRsZXJzW2tleV0gPSBfaGFuZGxlcnNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmF0aXZlW2tleV0gPSBfaGFuZGxlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtoYW5kbGVycywgbmF0aXZlLCBhY3Rpb25zXTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgaGFuZGxlcktleSwga2V5LCBpbnRlcm5hbEhhbmRsZXJzLCBjb25maWcpIHtcbiAgaWYgKCFhY3Rpb25zLmhhcyhoYW5kbGVyS2V5KSkgcmV0dXJuO1xuICBpZiAoIUVuZ2luZU1hcC5oYXMoa2V5KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc29sZS53YXJuKGBbQHVzZS1nZXN0dXJlXTogWW91J3ZlIGNyZWF0ZWQgYSBjdXN0b20gaGFuZGxlciB0aGF0IHRoYXQgdXNlcyB0aGUgXFxgJHtrZXl9XFxgIGdlc3R1cmUgYnV0IGlzbid0IHByb3Blcmx5IGNvbmZpZ3VyZWQuXFxuXFxuUGxlYXNlIGFkZCBcXGAke2tleX1BY3Rpb25cXGAgd2hlbiBjcmVhdGluZyB5b3VyIGhhbmRsZXIuYCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGFydEtleSA9IGhhbmRsZXJLZXkgKyAnU3RhcnQnO1xuICBjb25zdCBlbmRLZXkgPSBoYW5kbGVyS2V5ICsgJ0VuZCc7XG4gIGNvbnN0IGZuID0gc3RhdGUgPT4ge1xuICAgIGxldCBtZW1vID0gdW5kZWZpbmVkO1xuICAgIGlmIChzdGF0ZS5maXJzdCAmJiBzdGFydEtleSBpbiBoYW5kbGVycykgaGFuZGxlcnNbc3RhcnRLZXldKHN0YXRlKTtcbiAgICBpZiAoaGFuZGxlcktleSBpbiBoYW5kbGVycykgbWVtbyA9IGhhbmRsZXJzW2hhbmRsZXJLZXldKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUubGFzdCAmJiBlbmRLZXkgaW4gaGFuZGxlcnMpIGhhbmRsZXJzW2VuZEtleV0oc3RhdGUpO1xuICAgIHJldHVybiBtZW1vO1xuICB9O1xuICBpbnRlcm5hbEhhbmRsZXJzW2tleV0gPSBmbjtcbiAgY29uZmlnW2tleV0gPSBjb25maWdba2V5XSB8fCB7fTtcbn1cbmZ1bmN0aW9uIHBhcnNlTWVyZ2VkSGFuZGxlcnMobWVyZ2VkSGFuZGxlcnMsIG1lcmdlZENvbmZpZykge1xuICBjb25zdCBbaGFuZGxlcnMsIG5hdGl2ZUhhbmRsZXJzLCBhY3Rpb25zXSA9IHNvcnRIYW5kbGVycyhtZXJnZWRIYW5kbGVycyk7XG4gIGNvbnN0IGludGVybmFsSGFuZGxlcnMgPSB7fTtcbiAgcmVnaXN0ZXJHZXN0dXJlKGFjdGlvbnMsIGhhbmRsZXJzLCAnb25EcmFnJywgJ2RyYWcnLCBpbnRlcm5hbEhhbmRsZXJzLCBtZXJnZWRDb25maWcpO1xuICByZWdpc3Rlckdlc3R1cmUoYWN0aW9ucywgaGFuZGxlcnMsICdvbldoZWVsJywgJ3doZWVsJywgaW50ZXJuYWxIYW5kbGVycywgbWVyZ2VkQ29uZmlnKTtcbiAgcmVnaXN0ZXJHZXN0dXJlKGFjdGlvbnMsIGhhbmRsZXJzLCAnb25TY3JvbGwnLCAnc2Nyb2xsJywgaW50ZXJuYWxIYW5kbGVycywgbWVyZ2VkQ29uZmlnKTtcbiAgcmVnaXN0ZXJHZXN0dXJlKGFjdGlvbnMsIGhhbmRsZXJzLCAnb25QaW5jaCcsICdwaW5jaCcsIGludGVybmFsSGFuZGxlcnMsIG1lcmdlZENvbmZpZyk7XG4gIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgJ29uTW92ZScsICdtb3ZlJywgaW50ZXJuYWxIYW5kbGVycywgbWVyZ2VkQ29uZmlnKTtcbiAgcmVnaXN0ZXJHZXN0dXJlKGFjdGlvbnMsIGhhbmRsZXJzLCAnb25Ib3ZlcicsICdob3ZlcicsIGludGVybmFsSGFuZGxlcnMsIG1lcmdlZENvbmZpZyk7XG4gIHJldHVybiB7XG4gICAgaGFuZGxlcnM6IGludGVybmFsSGFuZGxlcnMsXG4gICAgY29uZmlnOiBtZXJnZWRDb25maWcsXG4gICAgbmF0aXZlSGFuZGxlcnNcbiAgfTtcbn1cblxuZXhwb3J0IHsgQ29udHJvbGxlciwgcGFyc2VNZXJnZWRIYW5kbGVycyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js ***!
  \*********************************************************************************/
/***/ (() => {




/***/ }),

/***/ "(ssr)/./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rubberbandIfOutOfBounds: () => (/* reexport safe */ _dist_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)\n/* harmony export */ });\n/* harmony import */ var _dist_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/maths-0ab39ae9.esm.js */ \"(ssr)/./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvdXRpbHMvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYWNlcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0B1c2UtZ2VzdHVyZS9jb3JlL3V0aWxzL2Rpc3QvdXNlLWdlc3R1cmUtY29yZS11dGlscy5lc20uanM/M2E0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyByIGFzIHJ1YmJlcmJhbmRJZk91dE9mQm91bmRzIH0gZnJvbSAnLi4vLi4vZGlzdC9tYXRocy0wYWIzOWFlOS5lc20uanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@use-gesture/react/dist/use-gesture-react.cjs.dev.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@use-gesture/react/dist/use-gesture-react.cjs.dev.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar actions = __webpack_require__(/*! @use-gesture/core/actions */ \"(ssr)/./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar core = __webpack_require__(/*! @use-gesture/core */ \"(ssr)/./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js\");\nvar utils = __webpack_require__(/*! @use-gesture/core/utils */ \"(ssr)/./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js\");\nvar types = __webpack_require__(/*! @use-gesture/core/types */ \"(ssr)/./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js\");\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }\n\nvar React__default = /*#__PURE__*/_interopDefault(React);\n\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = React__default[\"default\"].useMemo(() => new core.Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  React__default[\"default\"].useEffect(ctrl.effect.bind(ctrl));\n  React__default[\"default\"].useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n  if (config.target === undefined) {\n    return ctrl.bind.bind(ctrl);\n  }\n  return undefined;\n}\n\nfunction useDrag(handler, config) {\n  actions.registerAction(actions.dragAction);\n  return useRecognizers({\n    drag: handler\n  }, config || {}, 'drag');\n}\n\nfunction usePinch(handler, config) {\n  actions.registerAction(actions.pinchAction);\n  return useRecognizers({\n    pinch: handler\n  }, config || {}, 'pinch');\n}\n\nfunction useWheel(handler, config) {\n  actions.registerAction(actions.wheelAction);\n  return useRecognizers({\n    wheel: handler\n  }, config || {}, 'wheel');\n}\n\nfunction useScroll(handler, config) {\n  actions.registerAction(actions.scrollAction);\n  return useRecognizers({\n    scroll: handler\n  }, config || {}, 'scroll');\n}\n\nfunction useMove(handler, config) {\n  actions.registerAction(actions.moveAction);\n  return useRecognizers({\n    move: handler\n  }, config || {}, 'move');\n}\n\nfunction useHover(handler, config) {\n  actions.registerAction(actions.hoverAction);\n  return useRecognizers({\n    hover: handler\n  }, config || {}, 'hover');\n}\n\nfunction createUseGesture(actions$1) {\n  actions$1.forEach(actions.registerAction);\n  return function useGesture(_handlers, _config) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = core.parseMergedHandlers(_handlers, _config || {});\n    return useRecognizers(handlers, config, undefined, nativeHandlers);\n  };\n}\n\nfunction useGesture(handlers, config) {\n  const hook = createUseGesture([actions.dragAction, actions.pinchAction, actions.scrollAction, actions.wheelAction, actions.moveAction, actions.hoverAction]);\n  return hook(handlers, config || {});\n}\n\nexports.createUseGesture = createUseGesture;\nexports.useDrag = useDrag;\nexports.useGesture = useGesture;\nexports.useHover = useHover;\nexports.useMove = useMove;\nexports.usePinch = usePinch;\nexports.useScroll = useScroll;\nexports.useWheel = useWheel;\nObject.keys(actions).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () { return actions[k]; }\n  });\n});\nObject.keys(utils).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () { return utils[k]; }\n  });\n});\nObject.keys(types).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () { return types[k]; }\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL3JlYWN0L2Rpc3QvdXNlLWdlc3R1cmUtcmVhY3QuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGNBQWMsbUJBQU8sQ0FBQyxzSEFBMkI7QUFDakQsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyw4RkFBbUI7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLGdIQUF5QjtBQUM3QyxZQUFZLG1CQUFPLENBQUMsZ0hBQXlCOztBQUU3QywrQkFBK0IsaUNBQWlDOztBQUVoRTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGNBQWM7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGNBQWM7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGNBQWM7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGNBQWM7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGNBQWM7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGNBQWM7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1EQUFtRDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQSx3QkFBd0I7QUFDeEIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYWNlcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0B1c2UtZ2VzdHVyZS9yZWFjdC9kaXN0L3VzZS1nZXN0dXJlLXJlYWN0LmNqcy5kZXYuanM/NzM4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBhY3Rpb25zID0gcmVxdWlyZSgnQHVzZS1nZXN0dXJlL2NvcmUvYWN0aW9ucycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQHVzZS1nZXN0dXJlL2NvcmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0B1c2UtZ2VzdHVyZS9jb3JlL3V0aWxzJyk7XG52YXIgdHlwZXMgPSByZXF1aXJlKCdAdXNlLWdlc3R1cmUvY29yZS90eXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIFJlYWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChSZWFjdCk7XG5cbmZ1bmN0aW9uIHVzZVJlY29nbml6ZXJzKGhhbmRsZXJzLCBjb25maWcgPSB7fSwgZ2VzdHVyZUtleSwgbmF0aXZlSGFuZGxlcnMpIHtcbiAgY29uc3QgY3RybCA9IFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VNZW1vKCgpID0+IG5ldyBjb3JlLkNvbnRyb2xsZXIoaGFuZGxlcnMpLCBbXSk7XG4gIGN0cmwuYXBwbHlIYW5kbGVycyhoYW5kbGVycywgbmF0aXZlSGFuZGxlcnMpO1xuICBjdHJsLmFwcGx5Q29uZmlnKGNvbmZpZywgZ2VzdHVyZUtleSk7XG4gIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VFZmZlY3QoY3RybC5lZmZlY3QuYmluZChjdHJsKSk7XG4gIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBjdHJsLmNsZWFuLmJpbmQoY3RybCk7XG4gIH0sIFtdKTtcbiAgaWYgKGNvbmZpZy50YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjdHJsLmJpbmQuYmluZChjdHJsKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnKGhhbmRsZXIsIGNvbmZpZykge1xuICBhY3Rpb25zLnJlZ2lzdGVyQWN0aW9uKGFjdGlvbnMuZHJhZ0FjdGlvbik7XG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgZHJhZzogaGFuZGxlclxuICB9LCBjb25maWcgfHwge30sICdkcmFnJyk7XG59XG5cbmZ1bmN0aW9uIHVzZVBpbmNoKGhhbmRsZXIsIGNvbmZpZykge1xuICBhY3Rpb25zLnJlZ2lzdGVyQWN0aW9uKGFjdGlvbnMucGluY2hBY3Rpb24pO1xuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIHBpbmNoOiBoYW5kbGVyXG4gIH0sIGNvbmZpZyB8fCB7fSwgJ3BpbmNoJyk7XG59XG5cbmZ1bmN0aW9uIHVzZVdoZWVsKGhhbmRsZXIsIGNvbmZpZykge1xuICBhY3Rpb25zLnJlZ2lzdGVyQWN0aW9uKGFjdGlvbnMud2hlZWxBY3Rpb24pO1xuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIHdoZWVsOiBoYW5kbGVyXG4gIH0sIGNvbmZpZyB8fCB7fSwgJ3doZWVsJyk7XG59XG5cbmZ1bmN0aW9uIHVzZVNjcm9sbChoYW5kbGVyLCBjb25maWcpIHtcbiAgYWN0aW9ucy5yZWdpc3RlckFjdGlvbihhY3Rpb25zLnNjcm9sbEFjdGlvbik7XG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgc2Nyb2xsOiBoYW5kbGVyXG4gIH0sIGNvbmZpZyB8fCB7fSwgJ3Njcm9sbCcpO1xufVxuXG5mdW5jdGlvbiB1c2VNb3ZlKGhhbmRsZXIsIGNvbmZpZykge1xuICBhY3Rpb25zLnJlZ2lzdGVyQWN0aW9uKGFjdGlvbnMubW92ZUFjdGlvbik7XG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgbW92ZTogaGFuZGxlclxuICB9LCBjb25maWcgfHwge30sICdtb3ZlJyk7XG59XG5cbmZ1bmN0aW9uIHVzZUhvdmVyKGhhbmRsZXIsIGNvbmZpZykge1xuICBhY3Rpb25zLnJlZ2lzdGVyQWN0aW9uKGFjdGlvbnMuaG92ZXJBY3Rpb24pO1xuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIGhvdmVyOiBoYW5kbGVyXG4gIH0sIGNvbmZpZyB8fCB7fSwgJ2hvdmVyJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVzZUdlc3R1cmUoYWN0aW9ucyQxKSB7XG4gIGFjdGlvbnMkMS5mb3JFYWNoKGFjdGlvbnMucmVnaXN0ZXJBY3Rpb24pO1xuICByZXR1cm4gZnVuY3Rpb24gdXNlR2VzdHVyZShfaGFuZGxlcnMsIF9jb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBoYW5kbGVycyxcbiAgICAgIG5hdGl2ZUhhbmRsZXJzLFxuICAgICAgY29uZmlnXG4gICAgfSA9IGNvcmUucGFyc2VNZXJnZWRIYW5kbGVycyhfaGFuZGxlcnMsIF9jb25maWcgfHwge30pO1xuICAgIHJldHVybiB1c2VSZWNvZ25pemVycyhoYW5kbGVycywgY29uZmlnLCB1bmRlZmluZWQsIG5hdGl2ZUhhbmRsZXJzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlR2VzdHVyZShoYW5kbGVycywgY29uZmlnKSB7XG4gIGNvbnN0IGhvb2sgPSBjcmVhdGVVc2VHZXN0dXJlKFthY3Rpb25zLmRyYWdBY3Rpb24sIGFjdGlvbnMucGluY2hBY3Rpb24sIGFjdGlvbnMuc2Nyb2xsQWN0aW9uLCBhY3Rpb25zLndoZWVsQWN0aW9uLCBhY3Rpb25zLm1vdmVBY3Rpb24sIGFjdGlvbnMuaG92ZXJBY3Rpb25dKTtcbiAgcmV0dXJuIGhvb2soaGFuZGxlcnMsIGNvbmZpZyB8fCB7fSk7XG59XG5cbmV4cG9ydHMuY3JlYXRlVXNlR2VzdHVyZSA9IGNyZWF0ZVVzZUdlc3R1cmU7XG5leHBvcnRzLnVzZURyYWcgPSB1c2VEcmFnO1xuZXhwb3J0cy51c2VHZXN0dXJlID0gdXNlR2VzdHVyZTtcbmV4cG9ydHMudXNlSG92ZXIgPSB1c2VIb3ZlcjtcbmV4cG9ydHMudXNlTW92ZSA9IHVzZU1vdmU7XG5leHBvcnRzLnVzZVBpbmNoID0gdXNlUGluY2g7XG5leHBvcnRzLnVzZVNjcm9sbCA9IHVzZVNjcm9sbDtcbmV4cG9ydHMudXNlV2hlZWwgPSB1c2VXaGVlbDtcbk9iamVjdC5rZXlzKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgaWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWN0aW9uc1trXTsgfVxuICB9KTtcbn0pO1xuT2JqZWN0LmtleXModXRpbHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgaWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNba107IH1cbiAgfSk7XG59KTtcbk9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzW2tdOyB9XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@use-gesture/react/dist/use-gesture-react.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@use-gesture/react/dist/use-gesture-react.cjs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@use-gesture/react/dist/use-gesture-react.cjs.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./use-gesture-react.cjs.dev.js */ \"(ssr)/./node_modules/@use-gesture/react/dist/use-gesture-react.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL3JlYWN0L2Rpc3QvdXNlLWdlc3R1cmUtcmVhY3QuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvcmVhY3QvZGlzdC91c2UtZ2VzdHVyZS1yZWFjdC5janMuanM/OWY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi91c2UtZ2VzdHVyZS1yZWFjdC5janMucHJvZC5qc1wiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vdXNlLWdlc3R1cmUtcmVhY3QuY2pzLmRldi5qc1wiKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@use-gesture/react/dist/use-gesture-react.cjs.js\n");

/***/ })

};
;