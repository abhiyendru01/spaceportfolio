/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webgl-sdf-generator";
exports.ids = ["vendor-chunks/webgl-sdf-generator"];
exports.modules = {

/***/ "(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.js ***!
  \**********************************************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  function SDFGenerator() {\n  var exports = (function (exports) {\n\n    /**\n     * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n     */\n    function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {\n      var t2 = 1 - t;\n      pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n      pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n    }\n\n    /**\n     * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n     */\n    function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n      var t2 = 1 - t;\n      pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n      pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n    }\n\n    /**\n     * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n     * @param {function(\n     *   command: 'L'|'Q'|'C',\n     *   startX: number,\n     *   startY: number,\n     *   endX: number,\n     *   endY: number,\n     *   ctrl1X?: number,\n     *   ctrl1Y?: number,\n     *   ctrl2X?: number,\n     *   ctrl2Y?: number\n     * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n     *                      command identifier (only L/Q/C commands) and its numeric arguments.\n     */\n    function forEachPathCommand(pathString, commandCallback) {\n      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n      var match, firstX, firstY, prevX, prevY;\n      while ((match = segmentRE.exec(pathString))) {\n        var args = match[2]\n          .replace(/^\\s*|\\s*$/g, '')\n          .split(/[,\\s]+/)\n          .map(function (v) { return parseFloat(v); });\n        switch (match[1]) {\n          case 'M':\n            prevX = firstX = args[0];\n            prevY = firstY = args[1];\n            break\n          case 'L':\n            if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands\n              commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));\n            }\n            break\n          case 'Q': {\n            commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);\n            break\n          }\n          case 'C': {\n            commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);\n            break\n          }\n          case 'Z':\n            if (prevX !== firstX || prevY !== firstY) {\n              commandCallback('L', prevX, prevY, firstX, firstY);\n            }\n            break\n        }\n      }\n    }\n\n    /**\n     * Convert a path string to a series of straight line segments\n     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n     * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n     *        function that will be called once for every line segment\n     * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n     *        bezier curve in the path. Defaults to 16.\n     */\n    function pathToLineSegments (pathString, segmentCallback, curvePoints) {\n      if ( curvePoints === void 0 ) curvePoints = 16;\n\n      var tempPoint = { x: 0, y: 0 };\n      forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n        switch (command) {\n          case 'L':\n            segmentCallback(startX, startY, endX, endY);\n            break\n          case 'Q': {\n            var prevCurveX = startX;\n            var prevCurveY = startY;\n            for (var i = 1; i < curvePoints; i++) {\n              pointOnQuadraticBezier(\n                startX, startY,\n                ctrl1X, ctrl1Y,\n                endX, endY,\n                i / (curvePoints - 1),\n                tempPoint\n              );\n              segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n              prevCurveX = tempPoint.x;\n              prevCurveY = tempPoint.y;\n            }\n            break\n          }\n          case 'C': {\n            var prevCurveX$1 = startX;\n            var prevCurveY$1 = startY;\n            for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n              pointOnCubicBezier(\n                startX, startY,\n                ctrl1X, ctrl1Y,\n                ctrl2X, ctrl2Y,\n                endX, endY,\n                i$1 / (curvePoints - 1),\n                tempPoint\n              );\n              segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n              prevCurveX$1 = tempPoint.x;\n              prevCurveY$1 = tempPoint.y;\n            }\n            break\n          }\n        }\n      });\n    }\n\n    var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n    var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n\n    var cache = new WeakMap();\n\n    var glContextParams = {\n      premultipliedAlpha: false,\n      preserveDrawingBuffer: true,\n      antialias: false,\n      depth: false,\n    };\n\n    /**\n     * This is a little helper library for WebGL. It assists with state management for a GL context.\n     * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n     *\n     * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n     * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n     */\n    function withWebGLContext (glOrCanvas, callback) {\n      var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n      var wrapper = cache.get(gl);\n      if (!wrapper) {\n        var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n        var extensions = {};\n        var programs = {};\n        var textures = {};\n        var textureUnit = -1;\n        var framebufferStack = [];\n\n        gl.canvas.addEventListener('webglcontextlost', function (e) {\n          handleContextLoss();\n          e.preventDefault();\n        }, false);\n\n        function getExtension (name) {\n          var ext = extensions[name];\n          if (!ext) {\n            ext = extensions[name] = gl.getExtension(name);\n            if (!ext) {\n              throw new Error((name + \" not supported\"))\n            }\n          }\n          return ext\n        }\n\n        function compileShader (src, type) {\n          var shader = gl.createShader(type);\n          gl.shaderSource(shader, src);\n          gl.compileShader(shader);\n          // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n          // if (!status && !gl.isContextLost()) {\n          //   throw new Error(gl.getShaderInfoLog(shader).trim())\n          // }\n          return shader\n        }\n\n        function withProgram (name, vert, frag, func) {\n          if (!programs[name]) {\n            var attributes = {};\n            var uniforms = {};\n            var program = gl.createProgram();\n            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n            gl.linkProgram(program);\n\n            programs[name] = {\n              program: program,\n              transaction: function transaction (func) {\n                gl.useProgram(program);\n                func({\n                  setUniform: function setUniform (type, name) {\n                    var values = [], len = arguments.length - 2;\n                    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n                    var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                    gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));\n                  },\n\n                  setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {\n                    var attr = attributes[name];\n                    if (!attr) {\n                      attr = attributes[name] = {\n                        buf: gl.createBuffer(), // TODO should we destroy our buffers?\n                        loc: gl.getAttribLocation(program, name),\n                        data: null\n                      };\n                    }\n                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                    gl.enableVertexAttribArray(attr.loc);\n                    if (isWebGL2) {\n                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                    } else {\n                      getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                    }\n                    if (data !== attr.data) {\n                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                      attr.data = data;\n                    }\n                  }\n                });\n              }\n            };\n          }\n\n          programs[name].transaction(func);\n        }\n\n        function withTexture (name, func) {\n          textureUnit++;\n          try {\n            gl.activeTexture(gl.TEXTURE0 + textureUnit);\n            var texture = textures[name];\n            if (!texture) {\n              texture = textures[name] = gl.createTexture();\n              gl.bindTexture(gl.TEXTURE_2D, texture);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            }\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            func(texture, textureUnit);\n          } finally {\n            textureUnit--;\n          }\n        }\n\n        function withTextureFramebuffer (texture, textureUnit, func) {\n          var framebuffer = gl.createFramebuffer();\n          framebufferStack.push(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n          try {\n            func(framebuffer);\n          } finally {\n            gl.deleteFramebuffer(framebuffer);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n          }\n        }\n\n        function handleContextLoss () {\n          extensions = {};\n          programs = {};\n          textures = {};\n          textureUnit = -1;\n          framebufferStack.length = 0;\n        }\n\n        cache.set(gl, wrapper = {\n          gl: gl,\n          isWebGL2: isWebGL2,\n          getExtension: getExtension,\n          withProgram: withProgram,\n          withTexture: withTexture,\n          withTextureFramebuffer: withTextureFramebuffer,\n          handleContextLoss: handleContextLoss,\n        });\n      }\n      callback(wrapper);\n    }\n\n\n    function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n      if ( channels === void 0 ) channels = 15;\n      if ( framebuffer === void 0 ) framebuffer = null;\n\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var withProgram = ref.withProgram;\n        var withTexture = ref.withTexture;\n\n        withTexture('copy', function (tex, texUnit) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n          withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n            var setUniform = ref.setUniform;\n            var setAttribute = ref.setAttribute;\n\n            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n            setUniform('1i', 'image', texUnit);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n            gl.disable(gl.BLEND);\n            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n            gl.viewport(x, y, width, height);\n            gl.scissor(x, y, width, height);\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n          });\n        });\n      });\n    }\n\n    /**\n     * Resizing a canvas clears its contents; this utility copies the previous contents over.\n     * @param canvas\n     * @param newWidth\n     * @param newHeight\n     */\n    function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n      var width = canvas.width;\n      var height = canvas.height;\n      withWebGLContext(canvas, function (ref) {\n        var gl = ref.gl;\n\n        var data = new Uint8Array(width * height * 4);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        renderImageData(gl, data, 0, 0, width, height);\n      });\n    }\n\n    var webglUtils = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      withWebGLContext: withWebGLContext,\n      renderImageData: renderImageData,\n      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n    });\n\n    function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n      var textureData = new Uint8Array(sdfWidth * sdfHeight);\n\n      var viewBoxWidth = viewBox[2] - viewBox[0];\n      var viewBoxHeight = viewBox[3] - viewBox[1];\n\n      // Decompose all paths into straight line segments and add them to an index\n      var segments = [];\n      pathToLineSegments(path, function (x1, y1, x2, y2) {\n        segments.push({\n          x1: x1, y1: y1, x2: x2, y2: y2,\n          minX: Math.min(x1, x2),\n          minY: Math.min(y1, y2),\n          maxX: Math.max(x1, x2),\n          maxY: Math.max(y1, y2)\n        });\n      });\n\n      // Sort segments by maxX, this will let us short-circuit some loops below\n      segments.sort(function (a, b) { return a.maxX - b.maxX; });\n\n      // For each target SDF texel, find the distance from its center to its nearest line segment,\n      // map that distance to an alpha value, and write that alpha to the texel\n      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n          var signedDist = findNearestSignedDistance(\n            viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,\n            viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight\n          );\n\n          // Use an exponential scale to ensure the texels very near the glyph path have adequate\n          // precision, while allowing the distance field to cover the entire texture, given that\n          // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n          var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;\n          if (signedDist < 0) {\n            alpha = 1 - alpha;\n          }\n\n          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n          textureData[sdfY * sdfWidth + sdfX] = alpha;\n        }\n      }\n\n      return textureData\n\n      /**\n       * For a given x/y, search the index for the closest line segment and return\n       * its signed distance. Negative = inside, positive = outside, zero = on edge\n       * @param x\n       * @param y\n       * @returns {number}\n       */\n      function findNearestSignedDistance (x, y) {\n        var closestDistSq = Infinity;\n        var closestDist = Infinity;\n\n        for (var i = segments.length; i--;) {\n          var seg = segments[i];\n          if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit\n          if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n            var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n            if (distSq < closestDistSq) {\n              closestDistSq = distSq;\n              closestDist = Math.sqrt(closestDistSq);\n            }\n          }\n        }\n\n        // Flip to negative distance if inside the poly\n        if (isPointInPoly(x, y)) {\n          closestDist = -closestDist;\n        }\n        return closestDist\n      }\n\n      /**\n       * Determine whether the given point lies inside or outside the glyph. Uses a simple\n       * winding-number ray casting algorithm using a ray pointing east from the point.\n       */\n      function isPointInPoly (x, y) {\n        var winding = 0;\n        for (var i = segments.length; i--;) {\n          var seg = segments[i];\n          if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit\n          var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);\n          if (intersects) {\n            winding += seg.y1 < seg.y2 ? 1 : -1;\n          }\n        }\n        return winding !== 0\n      }\n    }\n\n    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( x === void 0 ) x = 0;\n      if ( y === void 0 ) y = 0;\n      if ( channel === void 0 ) channel = 0;\n\n      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n    }\n\n    function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( x === void 0 ) x = 0;\n      if ( y === void 0 ) y = 0;\n      if ( channel === void 0 ) channel = 0;\n\n      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n      // Expand single-channel data to rbga\n      var rgbaData = new Uint8Array(data.length * 4);\n      for (var i = 0; i < data.length; i++) {\n        rgbaData[i * 4 + channel] = data[i];\n      }\n      renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);\n    }\n\n    /**\n     * Find the absolute distance from a point to a line segment at closest approach\n     */\n    function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {\n      var ldx = lineX1 - lineX0;\n      var ldy = lineY1 - lineY0;\n      var lengthSq = ldx * ldx + ldy * ldy;\n      var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n      var dx = x - (lineX0 + t * ldx);\n      var dy = y - (lineY0 + t * ldy);\n      return dx * dx + dy * dy\n    }\n\n    var javascript = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      generate: generate$2,\n      generateIntoCanvas: generateIntoCanvas$2,\n      generateIntoFramebuffer: generateIntoFramebuffer$1\n    });\n\n    var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n    var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n\n    var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n    // Single triangle covering viewport\n    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n\n    var implicitContext = null;\n    var isTestingSupport = false;\n    var NULL_OBJECT = {};\n    var supportByCanvas = new WeakMap(); // canvas -> bool\n\n    function validateSupport (glOrCanvas) {\n      if (!isTestingSupport && !isSupported(glOrCanvas)) {\n        throw new Error('WebGL generation not supported')\n      }\n    }\n\n    function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( glOrCanvas === void 0 ) glOrCanvas = null;\n\n      if (!glOrCanvas) {\n        glOrCanvas = implicitContext;\n        if (!glOrCanvas) {\n          var canvas = typeof OffscreenCanvas === 'function'\n            ? new OffscreenCanvas(1, 1)\n            : typeof document !== 'undefined'\n              ? document.createElement('canvas')\n              : null;\n          if (!canvas) {\n            throw new Error('OffscreenCanvas or DOM canvas not supported')\n          }\n          glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });\n        }\n      }\n\n      validateSupport(glOrCanvas);\n\n      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n      // Render into a background texture framebuffer\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var withTexture = ref.withTexture;\n        var withTextureFramebuffer = ref.withTextureFramebuffer;\n\n        withTexture('readable', function (texture, textureUnit) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n          withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n            generateIntoFramebuffer(\n              sdfWidth,\n              sdfHeight,\n              path,\n              viewBox,\n              maxDistance,\n              sdfExponent,\n              gl,\n              framebuffer,\n              0,\n              0,\n              0 // red channel\n            );\n            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n          });\n        });\n      });\n\n      // Throw away all but the red channel\n      var data = new Uint8Array(sdfWidth * sdfHeight);\n      for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n        data[j++] = rgbaData[i];\n      }\n\n      return data\n    }\n\n    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( x === void 0 ) x = 0;\n      if ( y === void 0 ) y = 0;\n      if ( channel === void 0 ) channel = 0;\n\n      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n    }\n\n    function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( x === void 0 ) x = 0;\n      if ( y === void 0 ) y = 0;\n      if ( channel === void 0 ) channel = 0;\n\n      // Verify support\n      validateSupport(glOrCanvas);\n\n      // Compute path segments\n      var lineSegmentCoords = [];\n      pathToLineSegments(path, function (x1, y1, x2, y2) {\n        lineSegmentCoords.push(x1, y1, x2, y2);\n      });\n      lineSegmentCoords = new Float32Array(lineSegmentCoords);\n\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var isWebGL2 = ref.isWebGL2;\n        var getExtension = ref.getExtension;\n        var withProgram = ref.withProgram;\n        var withTexture = ref.withTexture;\n        var withTextureFramebuffer = ref.withTextureFramebuffer;\n        var handleContextLoss = ref.handleContextLoss;\n\n        withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n            gl.texImage2D(\n              gl.TEXTURE_2D, 0, gl.RGBA,\n              intermediateTexture._lastWidth = sdfWidth,\n              intermediateTexture._lastHeight = sdfHeight,\n              0, gl.RGBA, gl.UNSIGNED_BYTE, null\n            );\n          }\n\n          // Unsigned distance pass\n          withProgram('main', mainVertex, mainFragment, function (ref) {\n            var setAttribute = ref.setAttribute;\n            var setUniform = ref.setUniform;\n\n            // Init extensions\n            var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n            var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n            // Init/update attributes\n            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n            setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n            // Init/update uniforms\n            setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));\n            setUniform('1f', 'uMaxDistance', maxDistance);\n            setUniform('1f', 'uExponent', sdfExponent);\n\n            // Render initial unsigned distance / winding number info to a texture\n            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n              gl.enable(gl.BLEND);\n              gl.colorMask(true, true, true, true);\n              gl.viewport(0, 0, sdfWidth, sdfHeight);\n              gl.scissor(0, 0, sdfWidth, sdfHeight);\n              gl.blendFunc(gl.ONE, gl.ONE);\n              // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n              // Alpha holds the closest (MAX) unsigned distance.\n              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n              gl.clear(gl.COLOR_BUFFER_BIT);\n              if (isWebGL2) {\n                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n              } else {\n                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n              }\n              // Debug\n              // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n              // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n              // console.log('intermediate texture data: ', debug)\n            });\n          });\n\n          // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n          withProgram('post', viewportQuadVertex, postFragment, function (program) {\n            program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n            program.setUniform('1i', 'tex', intermediateTextureUnit);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n            gl.disable(gl.BLEND);\n            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n            gl.viewport(x, y, sdfWidth, sdfHeight);\n            gl.scissor(x, y, sdfWidth, sdfHeight);\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n          });\n        });\n\n        // Handle context loss occurring during any of the above calls\n        if (gl.isContextLost()) {\n          handleContextLoss();\n          throw new Error('webgl context lost')\n        }\n      });\n    }\n\n    function isSupported (glOrCanvas) {\n      var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);\n      var supported = supportByCanvas.get(key);\n      if (supported === undefined) {\n        isTestingSupport = true;\n        var failReason = null;\n        try {\n          // Since we can't detect all failure modes up front, let's just do a trial run of a\n          // simple path and compare what we get back to the correct expected result. This will\n          // also serve to prime the shader compilation.\n          var expectedResult = [\n            97, 106, 97, 61,\n            99, 137, 118, 80,\n            80, 118, 137, 99,\n            61, 97, 106, 97\n          ];\n          var testResult = generate$1(\n            4,\n            4,\n            'M8,8L16,8L24,24L16,24Z',\n            [0, 0, 32, 32],\n            24,\n            1,\n            glOrCanvas\n          );\n          supported = testResult && expectedResult.length === testResult.length &&\n            testResult.every(function (val, i) { return val === expectedResult[i]; });\n          if (!supported) {\n            failReason = 'bad trial run results';\n            console.info(expectedResult, testResult);\n          }\n        } catch (err) {\n          // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n          supported = false;\n          failReason = err.message;\n        }\n        if (failReason) {\n          console.warn('WebGL SDF generation not supported:', failReason);\n        }\n        isTestingSupport = false;\n        supportByCanvas.set(key, supported);\n      }\n      return supported\n    }\n\n    var webgl = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      generate: generate$1,\n      generateIntoCanvas: generateIntoCanvas$1,\n      generateIntoFramebuffer: generateIntoFramebuffer,\n      isSupported: isSupported\n    });\n\n    /**\n     * Generate an SDF texture image for a 2D path.\n     *\n     * @param {number} sdfWidth - width of the SDF output image in pixels.\n     * @param {number} sdfHeight - height of the SDF output image in pixels.\n     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n     *        to half the maximum viewBox dimension.\n     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n     *        will give greater precision nearer the glyph's path.\n     * @return {Uint8Array}\n     */\n    function generate(\n      sdfWidth,\n      sdfHeight,\n      path,\n      viewBox,\n      maxDistance,\n      sdfExponent\n    ) {\n      if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n      try {\n        return generate$1.apply(webgl, arguments)\n      } catch(e) {\n        console.info('WebGL SDF generation failed, falling back to JS', e);\n        return generate$2.apply(javascript, arguments)\n      }\n    }\n\n    /**\n     * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n     * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n     * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n     *\n     * @param {number} sdfWidth - width of the SDF output image in pixels.\n     * @param {number} sdfHeight - height of the SDF output image in pixels.\n     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n     *        to half the maximum viewBox dimension.\n     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n     *        will give greater precision nearer the glyph's path.\n     * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n     *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n     *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n     * @param {number} x - the x position at which to render the SDF.\n     * @param {number} y - the y position at which to render the SDF.\n     * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n     * @return {Uint8Array}\n     */\n    function generateIntoCanvas(\n      sdfWidth,\n      sdfHeight,\n      path,\n      viewBox,\n      maxDistance,\n      sdfExponent,\n      canvas,\n      x,\n      y,\n      channel\n    ) {\n      if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( x === void 0 ) x = 0;\n      if ( y === void 0 ) y = 0;\n      if ( channel === void 0 ) channel = 0;\n\n      try {\n        return generateIntoCanvas$1.apply(webgl, arguments)\n      } catch(e) {\n        console.info('WebGL SDF generation failed, falling back to JS', e);\n        return generateIntoCanvas$2.apply(javascript, arguments)\n      }\n    }\n\n    exports.forEachPathCommand = forEachPathCommand;\n    exports.generate = generate;\n    exports.generateIntoCanvas = generateIntoCanvas;\n    exports.javascript = javascript;\n    exports.pathToLineSegments = pathToLineSegments;\n    exports.webgl = webgl;\n    exports.webglUtils = webglUtils;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n    return exports;\n\n  }({}));\n  return exports\n  }\n\n  return SDFGenerator;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViZ2wtc2RmLWdlbmVyYXRvci9kaXN0L3dlYmdsLXNkZi1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDa0g7QUFDcEgsQ0FBQyxzQkFBc0I7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsK0NBQStDO0FBQ3RFLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUSwrQ0FBK0M7QUFDdEUsZUFBZSxzREFBc0Q7QUFDckU7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxxREFBcUQ7QUFDNUUsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUSwyRkFBMkY7QUFDbEg7QUFDQSxlQUFlLFFBQVEsOEVBQThFO0FBQ3JHO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsYUFBYTs7QUFFaEU7O0FBRUEsR0FBRyxHQUFHO0FBQ047QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvd2ViZ2wtc2RmLWdlbmVyYXRvci9kaXN0L3dlYmdsLXNkZi1nZW5lcmF0b3IuanM/N2Y0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC53ZWJnbF9zZGZfZ2VuZXJhdG9yID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIFNERkdlbmVyYXRvcigpIHtcbiAgdmFyIGV4cG9ydHMgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBhdCB0IHdoZXJlIHQgaXMgaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBvaW50T25RdWFkcmF0aWNCZXppZXIgKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHQsIHBvaW50T3V0KSB7XG4gICAgICB2YXIgdDIgPSAxIC0gdDtcbiAgICAgIHBvaW50T3V0LnggPSB0MiAqIHQyICogeDAgKyAyICogdDIgKiB0ICogeDEgKyB0ICogdCAqIHgyO1xuICAgICAgcG9pbnRPdXQueSA9IHQyICogdDIgKiB5MCArIDIgKiB0MiAqIHQgKiB5MSArIHQgKiB0ICogeTI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgcG9pbnQgb24gYSBjdWJpYyBiZXppZXIgY3VydmUgYXQgdCB3aGVyZSB0IGlzIGluIHRoZSByYW5nZSBbMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb2ludE9uQ3ViaWNCZXppZXIgKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdCwgcG9pbnRPdXQpIHtcbiAgICAgIHZhciB0MiA9IDEgLSB0O1xuICAgICAgcG9pbnRPdXQueCA9IHQyICogdDIgKiB0MiAqIHgwICsgMyAqIHQyICogdDIgKiB0ICogeDEgKyAzICogdDIgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDM7XG4gICAgICBwb2ludE91dC55ID0gdDIgKiB0MiAqIHQyICogeTAgKyAzICogdDIgKiB0MiAqIHQgKiB5MSArIDMgKiB0MiAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIHBhdGggc3RyaW5nIGludG8gaXRzIGNvbnN0aXR1ZW50IGxpbmUvY3VydmUgY29tbWFuZHMsIGludm9raW5nIGEgY2FsbGJhY2sgZm9yIGVhY2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmcgLSBBbiBTVkctbGlrZSBwYXRoIHN0cmluZyB0byBwYXJzZTsgc2hvdWxkIG9ubHkgY29udGFpbiBjb21tYW5kczogTS9ML1EvQy9aXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihcbiAgICAgKiAgIGNvbW1hbmQ6ICdMJ3wnUSd8J0MnLFxuICAgICAqICAgc3RhcnRYOiBudW1iZXIsXG4gICAgICogICBzdGFydFk6IG51bWJlcixcbiAgICAgKiAgIGVuZFg6IG51bWJlcixcbiAgICAgKiAgIGVuZFk6IG51bWJlcixcbiAgICAgKiAgIGN0cmwxWD86IG51bWJlcixcbiAgICAgKiAgIGN0cmwxWT86IG51bWJlcixcbiAgICAgKiAgIGN0cmwyWD86IG51bWJlcixcbiAgICAgKiAgIGN0cmwyWT86IG51bWJlclxuICAgICAqICl9IGNvbW1hbmRDYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIHBhcnNlZCBwYXRoIGNvbW1hbmQsIHBhc3NpbmcgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZCBpZGVudGlmaWVyIChvbmx5IEwvUS9DIGNvbW1hbmRzKSBhbmQgaXRzIG51bWVyaWMgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hQYXRoQ29tbWFuZChwYXRoU3RyaW5nLCBjb21tYW5kQ2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWdtZW50UkUgPSAvKFtNTFFDWl0pKFteTUxRQ1pdKikvZztcbiAgICAgIHZhciBtYXRjaCwgZmlyc3RYLCBmaXJzdFksIHByZXZYLCBwcmV2WTtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBzZWdtZW50UkUuZXhlYyhwYXRoU3RyaW5nKSkpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaFsyXVxuICAgICAgICAgIC5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJylcbiAgICAgICAgICAuc3BsaXQoL1ssXFxzXSsvKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHBhcnNlRmxvYXQodik7IH0pO1xuICAgICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG4gICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICBwcmV2WCA9IGZpcnN0WCA9IGFyZ3NbMF07XG4gICAgICAgICAgICBwcmV2WSA9IGZpcnN0WSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgaWYgKGFyZ3NbMF0gIT09IHByZXZYIHx8IGFyZ3NbMV0gIT09IHByZXZZKSB7IC8vIHl1cCwgc29tZSBmb250cyBoYXZlIHplcm8tbGVuZ3RoIGxpbmUgY29tbWFuZHNcbiAgICAgICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdMJywgcHJldlgsIHByZXZZLCAocHJldlggPSBhcmdzWzBdKSwgKHByZXZZID0gYXJnc1sxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdRJzoge1xuICAgICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdRJywgcHJldlgsIHByZXZZLCAocHJldlggPSBhcmdzWzJdKSwgKHByZXZZID0gYXJnc1szXSksIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQyc6IHtcbiAgICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnQycsIHByZXZYLCBwcmV2WSwgKHByZXZYID0gYXJnc1s0XSksIChwcmV2WSA9IGFyZ3NbNV0pLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgaWYgKHByZXZYICE9PSBmaXJzdFggfHwgcHJldlkgIT09IGZpcnN0WSkge1xuICAgICAgICAgICAgICBjb21tYW5kQ2FsbGJhY2soJ0wnLCBwcmV2WCwgcHJldlksIGZpcnN0WCwgZmlyc3RZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgcGF0aCBzdHJpbmcgdG8gYSBzZXJpZXMgb2Ygc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nIC0gQW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgdG8gcGFyc2U7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oeDE6bnVtYmVyLCB5MTpudW1iZXIsIHgyOm51bWJlciwgeTI6bnVtYmVyKX0gc2VnbWVudENhbGxiYWNrIC0gQSBjYWxsYmFja1xuICAgICAqICAgICAgICBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGV2ZXJ5IGxpbmUgc2VnbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VydmVQb2ludHNdIC0gSG93IG1hbnkgc3RyYWlnaHQgbGluZSBzZWdtZW50cyB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIGFcbiAgICAgKiAgICAgICAgYmV6aWVyIGN1cnZlIGluIHRoZSBwYXRoLiBEZWZhdWx0cyB0byAxNi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXRoVG9MaW5lU2VnbWVudHMgKHBhdGhTdHJpbmcsIHNlZ21lbnRDYWxsYmFjaywgY3VydmVQb2ludHMpIHtcbiAgICAgIGlmICggY3VydmVQb2ludHMgPT09IHZvaWQgMCApIGN1cnZlUG9pbnRzID0gMTY7XG5cbiAgICAgIHZhciB0ZW1wUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgIGZvckVhY2hQYXRoQ29tbWFuZChwYXRoU3RyaW5nLCBmdW5jdGlvbiAoY29tbWFuZCwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGN0cmwxWCwgY3RybDFZLCBjdHJsMlgsIGN0cmwyWSkge1xuICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgIHNlZ21lbnRDYWxsYmFjayhzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ1EnOiB7XG4gICAgICAgICAgICB2YXIgcHJldkN1cnZlWCA9IHN0YXJ0WDtcbiAgICAgICAgICAgIHZhciBwcmV2Q3VydmVZID0gc3RhcnRZO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjdXJ2ZVBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgIHBvaW50T25RdWFkcmF0aWNCZXppZXIoXG4gICAgICAgICAgICAgICAgc3RhcnRYLCBzdGFydFksXG4gICAgICAgICAgICAgICAgY3RybDFYLCBjdHJsMVksXG4gICAgICAgICAgICAgICAgZW5kWCwgZW5kWSxcbiAgICAgICAgICAgICAgICBpIC8gKGN1cnZlUG9pbnRzIC0gMSksXG4gICAgICAgICAgICAgICAgdGVtcFBvaW50XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHNlZ21lbnRDYWxsYmFjayhwcmV2Q3VydmVYLCBwcmV2Q3VydmVZLCB0ZW1wUG9pbnQueCwgdGVtcFBvaW50LnkpO1xuICAgICAgICAgICAgICBwcmV2Q3VydmVYID0gdGVtcFBvaW50Lng7XG4gICAgICAgICAgICAgIHByZXZDdXJ2ZVkgPSB0ZW1wUG9pbnQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0MnOiB7XG4gICAgICAgICAgICB2YXIgcHJldkN1cnZlWCQxID0gc3RhcnRYO1xuICAgICAgICAgICAgdmFyIHByZXZDdXJ2ZVkkMSA9IHN0YXJ0WTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IGN1cnZlUG9pbnRzOyBpJDErKykge1xuICAgICAgICAgICAgICBwb2ludE9uQ3ViaWNCZXppZXIoXG4gICAgICAgICAgICAgICAgc3RhcnRYLCBzdGFydFksXG4gICAgICAgICAgICAgICAgY3RybDFYLCBjdHJsMVksXG4gICAgICAgICAgICAgICAgY3RybDJYLCBjdHJsMlksXG4gICAgICAgICAgICAgICAgZW5kWCwgZW5kWSxcbiAgICAgICAgICAgICAgICBpJDEgLyAoY3VydmVQb2ludHMgLSAxKSxcbiAgICAgICAgICAgICAgICB0ZW1wUG9pbnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgc2VnbWVudENhbGxiYWNrKHByZXZDdXJ2ZVgkMSwgcHJldkN1cnZlWSQxLCB0ZW1wUG9pbnQueCwgdGVtcFBvaW50LnkpO1xuICAgICAgICAgICAgICBwcmV2Q3VydmVYJDEgPSB0ZW1wUG9pbnQueDtcbiAgICAgICAgICAgICAgcHJldkN1cnZlWSQxID0gdGVtcFBvaW50Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHZpZXdwb3J0UXVhZFZlcnRleCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O2F0dHJpYnV0ZSB2ZWMyIGFVVjt2YXJ5aW5nIHZlYzIgdlVWO3ZvaWQgbWFpbigpe3ZVVj1hVVY7Z2xfUG9zaXRpb249dmVjNChtaXgodmVjMigtMS4wKSx2ZWMyKDEuMCksYVVWKSwwLjAsMS4wKTt9XCI7XG5cbiAgICB2YXIgY29weVRleEZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSBzYW1wbGVyMkQgdGV4O3ZhcnlpbmcgdmVjMiB2VVY7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRCh0ZXgsdlVWKTt9XCI7XG5cbiAgICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgdmFyIGdsQ29udGV4dFBhcmFtcyA9IHtcbiAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUsXG4gICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgZGVwdGg6IGZhbHNlLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgbGl0dGxlIGhlbHBlciBsaWJyYXJ5IGZvciBXZWJHTC4gSXQgYXNzaXN0cyB3aXRoIHN0YXRlIG1hbmFnZW1lbnQgZm9yIGEgR0wgY29udGV4dC5cbiAgICAgKiBJdCdzIHByZXR0eSB0aWdodGx5IHdyYXBwZWQgdG8gdGhlIG5lZWRzIG9mIHRoaXMgcGFja2FnZSwgbm90IHZlcnkgZ2VuZXJhbC1wdXJwb3NlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBPZmZzY3JlZW5DYW52YXMgfSBnbE9yQ2FudmFzIC0gdGhlIEdMIGNvbnRleHQgdG8gd3JhcFxuICAgICAqIEBwYXJhbSB7ICh7Z2wsIGdldEV4dGVuc2lvbiwgd2l0aFByb2dyYW0sIHdpdGhUZXh0dXJlLCB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyLCBoYW5kbGVDb250ZXh0TG9zc30pID0+IHZvaWQgfSBjYWxsYmFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdpdGhXZWJHTENvbnRleHQgKGdsT3JDYW52YXMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZ2wgPSBnbE9yQ2FudmFzLmdldENvbnRleHQgPyBnbE9yQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgZ2xDb250ZXh0UGFyYW1zKSA6IGdsT3JDYW52YXM7XG4gICAgICB2YXIgd3JhcHBlciA9IGNhY2hlLmdldChnbCk7XG4gICAgICBpZiAoIXdyYXBwZXIpIHtcbiAgICAgICAgdmFyIGlzV2ViR0wyID0gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgICAgdmFyIGV4dGVuc2lvbnMgPSB7fTtcbiAgICAgICAgdmFyIHByb2dyYW1zID0ge307XG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IHt9O1xuICAgICAgICB2YXIgdGV4dHVyZVVuaXQgPSAtMTtcbiAgICAgICAgdmFyIGZyYW1lYnVmZmVyU3RhY2sgPSBbXTtcblxuICAgICAgICBnbC5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaGFuZGxlQ29udGV4dExvc3MoKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRFeHRlbnNpb24gKG5hbWUpIHtcbiAgICAgICAgICB2YXIgZXh0ID0gZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICAgICAgICBpZiAoIWV4dCkge1xuICAgICAgICAgICAgZXh0ID0gZXh0ZW5zaW9uc1tuYW1lXSA9IGdsLmdldEV4dGVuc2lvbihuYW1lKTtcbiAgICAgICAgICAgIGlmICghZXh0KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigobmFtZSArIFwiIG5vdCBzdXBwb3J0ZWRcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleHRcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIgKHNyYywgdHlwZSkge1xuICAgICAgICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcbiAgICAgICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgICAgLy8gY29uc3Qgc3RhdHVzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpXG4gICAgICAgICAgLy8gaWYgKCFzdGF0dXMgJiYgIWdsLmlzQ29udGV4dExvc3QoKSkge1xuICAgICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKS50cmltKCkpXG4gICAgICAgICAgLy8gfVxuICAgICAgICAgIHJldHVybiBzaGFkZXJcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdpdGhQcm9ncmFtIChuYW1lLCB2ZXJ0LCBmcmFnLCBmdW5jKSB7XG4gICAgICAgICAgaWYgKCFwcm9ncmFtc1tuYW1lXSkge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgY29tcGlsZVNoYWRlcih2ZXJ0LCBnbC5WRVJURVhfU0hBREVSKSk7XG4gICAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgY29tcGlsZVNoYWRlcihmcmFnLCBnbC5GUkFHTUVOVF9TSEFERVIpKTtcbiAgICAgICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgICAgICAgICBwcm9ncmFtc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IGZ1bmN0aW9uIHRyYW5zYWN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgICAgICBmdW5jKHtcbiAgICAgICAgICAgICAgICAgIHNldFVuaWZvcm06IGZ1bmN0aW9uIHNldFVuaWZvcm0gKHR5cGUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSB2YWx1ZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuaWZvcm1Mb2MgPSB1bmlmb3Jtc1tuYW1lXSB8fCAodW5pZm9ybXNbbmFtZV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBnbFsoXCJ1bmlmb3JtXCIgKyB0eXBlKV0uYXBwbHkoZ2wsIFsgdW5pZm9ybUxvYyBdLmNvbmNhdCggdmFsdWVzICkpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5hbWUsIHNpemUsIHVzYWdlLCBpbnN0YW5jaW5nRGl2aXNvciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyaWJ1dGVzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmOiBnbC5jcmVhdGVCdWZmZXIoKSwgLy8gVE9ETyBzaG91bGQgd2UgZGVzdHJveSBvdXIgYnVmZmVycz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYXR0ci5idWYpO1xuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHIubG9jLCBzaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyLmxvYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0ci5sb2MsIGluc3RhbmNpbmdEaXZpc29yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBnZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKS52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoYXR0ci5sb2MsIGluc3RhbmNpbmdEaXZpc29yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gYXR0ci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIHVzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJvZ3JhbXNbbmFtZV0udHJhbnNhY3Rpb24oZnVuYyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3aXRoVGV4dHVyZSAobmFtZSwgZnVuYykge1xuICAgICAgICAgIHRleHR1cmVVbml0Kys7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRleHR1cmVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlc1tuYW1lXSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgICAgICBmdW5jKHRleHR1cmUsIHRleHR1cmVVbml0KTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGV4dHVyZVVuaXQtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyICh0ZXh0dXJlLCB0ZXh0dXJlVW5pdCwgZnVuYykge1xuICAgICAgICAgIHZhciBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgICAgZnJhbWVidWZmZXJTdGFjay5wdXNoKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpO1xuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZ1bmMoZnJhbWVidWZmZXIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyU3RhY2tbLS1mcmFtZWJ1ZmZlclN0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUNvbnRleHRMb3NzICgpIHtcbiAgICAgICAgICBleHRlbnNpb25zID0ge307XG4gICAgICAgICAgcHJvZ3JhbXMgPSB7fTtcbiAgICAgICAgICB0ZXh0dXJlcyA9IHt9O1xuICAgICAgICAgIHRleHR1cmVVbml0ID0gLTE7XG4gICAgICAgICAgZnJhbWVidWZmZXJTdGFjay5sZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGUuc2V0KGdsLCB3cmFwcGVyID0ge1xuICAgICAgICAgIGdsOiBnbCxcbiAgICAgICAgICBpc1dlYkdMMjogaXNXZWJHTDIsXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uOiBnZXRFeHRlbnNpb24sXG4gICAgICAgICAgd2l0aFByb2dyYW06IHdpdGhQcm9ncmFtLFxuICAgICAgICAgIHdpdGhUZXh0dXJlOiB3aXRoVGV4dHVyZSxcbiAgICAgICAgICB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyOiB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyLFxuICAgICAgICAgIGhhbmRsZUNvbnRleHRMb3NzOiBoYW5kbGVDb250ZXh0TG9zcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayh3cmFwcGVyKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHJlbmRlckltYWdlRGF0YShnbE9yQ2FudmFzLCBpbWFnZURhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzLCBmcmFtZWJ1ZmZlcikge1xuICAgICAgaWYgKCBjaGFubmVscyA9PT0gdm9pZCAwICkgY2hhbm5lbHMgPSAxNTtcbiAgICAgIGlmICggZnJhbWVidWZmZXIgPT09IHZvaWQgMCApIGZyYW1lYnVmZmVyID0gbnVsbDtcblxuICAgICAgd2l0aFdlYkdMQ29udGV4dChnbE9yQ2FudmFzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgICAgdmFyIHdpdGhQcm9ncmFtID0gcmVmLndpdGhQcm9ncmFtO1xuICAgICAgICB2YXIgd2l0aFRleHR1cmUgPSByZWYud2l0aFRleHR1cmU7XG5cbiAgICAgICAgd2l0aFRleHR1cmUoJ2NvcHknLCBmdW5jdGlvbiAodGV4LCB0ZXhVbml0KSB7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZURhdGEpO1xuICAgICAgICAgIHdpdGhQcm9ncmFtKCdjb3B5Jywgdmlld3BvcnRRdWFkVmVydGV4LCBjb3B5VGV4RnJhZ21lbnQsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBzZXRVbmlmb3JtID0gcmVmLnNldFVuaWZvcm07XG4gICAgICAgICAgICB2YXIgc2V0QXR0cmlidXRlID0gcmVmLnNldEF0dHJpYnV0ZTtcblxuICAgICAgICAgICAgc2V0QXR0cmlidXRlKCdhVVYnLCAyLCBnbC5TVEFUSUNfRFJBVywgMCwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMiwgMCwgMCwgMl0pKTtcbiAgICAgICAgICAgIHNldFVuaWZvcm0oJzFpJywgJ2ltYWdlJywgdGV4VW5pdCk7XG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyIHx8IG51bGwpO1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5jb2xvck1hc2soY2hhbm5lbHMgJiA4LCBjaGFubmVscyAmIDQsIGNoYW5uZWxzICYgMiwgY2hhbm5lbHMgJiAxKTtcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZ2wuc2Npc3Nvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCAzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemluZyBhIGNhbnZhcyBjbGVhcnMgaXRzIGNvbnRlbnRzOyB0aGlzIHV0aWxpdHkgY29waWVzIHRoZSBwcmV2aW91cyBjb250ZW50cyBvdmVyLlxuICAgICAqIEBwYXJhbSBjYW52YXNcbiAgICAgKiBAcGFyYW0gbmV3V2lkdGhcbiAgICAgKiBAcGFyYW0gbmV3SGVpZ2h0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmcoY2FudmFzLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gICAgICB2YXIgd2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgIHdpdGhXZWJHTENvbnRleHQoY2FudmFzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcblxuICAgICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICByZW5kZXJJbWFnZURhdGEoZ2wsIGRhdGEsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHdlYmdsVXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICB3aXRoV2ViR0xDb250ZXh0OiB3aXRoV2ViR0xDb250ZXh0LFxuICAgICAgcmVuZGVySW1hZ2VEYXRhOiByZW5kZXJJbWFnZURhdGEsXG4gICAgICByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZzogcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmdcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlJDIgKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCkge1xuICAgICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuXG4gICAgICB2YXIgdGV4dHVyZURhdGEgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCk7XG5cbiAgICAgIHZhciB2aWV3Qm94V2lkdGggPSB2aWV3Qm94WzJdIC0gdmlld0JveFswXTtcbiAgICAgIHZhciB2aWV3Qm94SGVpZ2h0ID0gdmlld0JveFszXSAtIHZpZXdCb3hbMV07XG5cbiAgICAgIC8vIERlY29tcG9zZSBhbGwgcGF0aHMgaW50byBzdHJhaWdodCBsaW5lIHNlZ21lbnRzIGFuZCBhZGQgdGhlbSB0byBhbiBpbmRleFxuICAgICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgICBwYXRoVG9MaW5lU2VnbWVudHMocGF0aCwgZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgIHgxOiB4MSwgeTE6IHkxLCB4MjogeDIsIHkyOiB5MixcbiAgICAgICAgICBtaW5YOiBNYXRoLm1pbih4MSwgeDIpLFxuICAgICAgICAgIG1pblk6IE1hdGgubWluKHkxLCB5MiksXG4gICAgICAgICAgbWF4WDogTWF0aC5tYXgoeDEsIHgyKSxcbiAgICAgICAgICBtYXhZOiBNYXRoLm1heCh5MSwgeTIpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNvcnQgc2VnbWVudHMgYnkgbWF4WCwgdGhpcyB3aWxsIGxldCB1cyBzaG9ydC1jaXJjdWl0IHNvbWUgbG9vcHMgYmVsb3dcbiAgICAgIHNlZ21lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubWF4WCAtIGIubWF4WDsgfSk7XG5cbiAgICAgIC8vIEZvciBlYWNoIHRhcmdldCBTREYgdGV4ZWwsIGZpbmQgdGhlIGRpc3RhbmNlIGZyb20gaXRzIGNlbnRlciB0byBpdHMgbmVhcmVzdCBsaW5lIHNlZ21lbnQsXG4gICAgICAvLyBtYXAgdGhhdCBkaXN0YW5jZSB0byBhbiBhbHBoYSB2YWx1ZSwgYW5kIHdyaXRlIHRoYXQgYWxwaGEgdG8gdGhlIHRleGVsXG4gICAgICBmb3IgKHZhciBzZGZYID0gMDsgc2RmWCA8IHNkZldpZHRoOyBzZGZYKyspIHtcbiAgICAgICAgZm9yICh2YXIgc2RmWSA9IDA7IHNkZlkgPCBzZGZIZWlnaHQ7IHNkZlkrKykge1xuICAgICAgICAgIHZhciBzaWduZWREaXN0ID0gZmluZE5lYXJlc3RTaWduZWREaXN0YW5jZShcbiAgICAgICAgICAgIHZpZXdCb3hbMF0gKyB2aWV3Qm94V2lkdGggKiAoc2RmWCArIDAuNSkgLyBzZGZXaWR0aCxcbiAgICAgICAgICAgIHZpZXdCb3hbMV0gKyB2aWV3Qm94SGVpZ2h0ICogKHNkZlkgKyAwLjUpIC8gc2RmSGVpZ2h0XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFVzZSBhbiBleHBvbmVudGlhbCBzY2FsZSB0byBlbnN1cmUgdGhlIHRleGVscyB2ZXJ5IG5lYXIgdGhlIGdseXBoIHBhdGggaGF2ZSBhZGVxdWF0ZVxuICAgICAgICAgIC8vIHByZWNpc2lvbiwgd2hpbGUgYWxsb3dpbmcgdGhlIGRpc3RhbmNlIGZpZWxkIHRvIGNvdmVyIHRoZSBlbnRpcmUgdGV4dHVyZSwgZ2l2ZW4gdGhhdFxuICAgICAgICAgIC8vIHRoZXJlIGFyZSBvbmx5IDggYml0cyBhdmFpbGFibGUuIEZvcm11bGEgdmlzdWFsaXplZDogaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3VpYXE1YXFpYW1cbiAgICAgICAgICB2YXIgYWxwaGEgPSBNYXRoLnBvdygoMSAtIE1hdGguYWJzKHNpZ25lZERpc3QpIC8gbWF4RGlzdGFuY2UpLCBzZGZFeHBvbmVudCkgLyAyO1xuICAgICAgICAgIGlmIChzaWduZWREaXN0IDwgMCkge1xuICAgICAgICAgICAgYWxwaGEgPSAxIC0gYWxwaGE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQoYWxwaGEgKiAyNTUpKSk7IC8vY2xhbXBcbiAgICAgICAgICB0ZXh0dXJlRGF0YVtzZGZZICogc2RmV2lkdGggKyBzZGZYXSA9IGFscGhhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ZXh0dXJlRGF0YVxuXG4gICAgICAvKipcbiAgICAgICAqIEZvciBhIGdpdmVuIHgveSwgc2VhcmNoIHRoZSBpbmRleCBmb3IgdGhlIGNsb3Nlc3QgbGluZSBzZWdtZW50IGFuZCByZXR1cm5cbiAgICAgICAqIGl0cyBzaWduZWQgZGlzdGFuY2UuIE5lZ2F0aXZlID0gaW5zaWRlLCBwb3NpdGl2ZSA9IG91dHNpZGUsIHplcm8gPSBvbiBlZGdlXG4gICAgICAgKiBAcGFyYW0geFxuICAgICAgICogQHBhcmFtIHlcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGZpbmROZWFyZXN0U2lnbmVkRGlzdGFuY2UgKHgsIHkpIHtcbiAgICAgICAgdmFyIGNsb3Nlc3REaXN0U3EgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIGNsb3Nlc3REaXN0ID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHNlZ21lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIHZhciBzZWcgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICBpZiAoc2VnLm1heFggKyBjbG9zZXN0RGlzdCA8PSB4KSB7IGJyZWFrIH0gLy9zb3J0aW5nIGJ5IG1heFggbWVhbnMgbm8gbW9yZSBjYW4gYmUgY2xvc2VyLCBzbyB3ZSBjYW4gc2hvcnQtY2lyY3VpdFxuICAgICAgICAgIGlmICh4ICsgY2xvc2VzdERpc3QgPiBzZWcubWluWCAmJiB5IC0gY2xvc2VzdERpc3QgPCBzZWcubWF4WSAmJiB5ICsgY2xvc2VzdERpc3QgPiBzZWcubWluWSkge1xuICAgICAgICAgICAgdmFyIGRpc3RTcSA9IGFic1NxdWFyZURpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCBzZWcueDEsIHNlZy55MSwgc2VnLngyLCBzZWcueTIpO1xuICAgICAgICAgICAgaWYgKGRpc3RTcSA8IGNsb3Nlc3REaXN0U3EpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdERpc3RTcSA9IGRpc3RTcTtcbiAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBNYXRoLnNxcnQoY2xvc2VzdERpc3RTcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmxpcCB0byBuZWdhdGl2ZSBkaXN0YW5jZSBpZiBpbnNpZGUgdGhlIHBvbHlcbiAgICAgICAgaWYgKGlzUG9pbnRJblBvbHkoeCwgeSkpIHtcbiAgICAgICAgICBjbG9zZXN0RGlzdCA9IC1jbG9zZXN0RGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvc2VzdERpc3RcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgbGllcyBpbnNpZGUgb3Igb3V0c2lkZSB0aGUgZ2x5cGguIFVzZXMgYSBzaW1wbGVcbiAgICAgICAqIHdpbmRpbmctbnVtYmVyIHJheSBjYXN0aW5nIGFsZ29yaXRobSB1c2luZyBhIHJheSBwb2ludGluZyBlYXN0IGZyb20gdGhlIHBvaW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBpc1BvaW50SW5Qb2x5ICh4LCB5KSB7XG4gICAgICAgIHZhciB3aW5kaW5nID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNlZ21lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIHZhciBzZWcgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICBpZiAoc2VnLm1heFggPD0geCkgeyBicmVhayB9IC8vc29ydGluZyBieSBtYXhYIG1lYW5zIG5vIG1vcmUgY2FuIGNyb3NzLCBzbyB3ZSBjYW4gc2hvcnQtY2lyY3VpdFxuICAgICAgICAgIHZhciBpbnRlcnNlY3RzID0gKChzZWcueTEgPiB5KSAhPT0gKHNlZy55MiA+IHkpKSAmJiAoeCA8IChzZWcueDIgLSBzZWcueDEpICogKHkgLSBzZWcueTEpIC8gKHNlZy55MiAtIHNlZy55MSkgKyBzZWcueDEpO1xuICAgICAgICAgIGlmIChpbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICB3aW5kaW5nICs9IHNlZy55MSA8IHNlZy55MiA/IDEgOiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpbmRpbmcgIT09IDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUludG9DYW52YXMkMihzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkge1xuICAgICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgICAgaWYgKCB4ID09PSB2b2lkIDAgKSB4ID0gMDtcbiAgICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgICBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCBudWxsLCB4LCB5LCBjaGFubmVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGdsT3JDYW52YXMsIGZyYW1lYnVmZmVyLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICAgIHZhciBkYXRhID0gZ2VuZXJhdGUkMihzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQpO1xuICAgICAgLy8gRXhwYW5kIHNpbmdsZS1jaGFubmVsIGRhdGEgdG8gcmJnYVxuICAgICAgdmFyIHJnYmFEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKiA0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICByZ2JhRGF0YVtpICogNCArIGNoYW5uZWxdID0gZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIHJlbmRlckltYWdlRGF0YShnbE9yQ2FudmFzLCByZ2JhRGF0YSwgeCwgeSwgc2RmV2lkdGgsIHNkZkhlaWdodCwgMSA8PCAoMyAtIGNoYW5uZWwpLCBmcmFtZWJ1ZmZlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgbGluZSBzZWdtZW50IGF0IGNsb3Nlc3QgYXBwcm9hY2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhYnNTcXVhcmVEaXN0YW5jZVRvTGluZVNlZ21lbnQgKHgsIHksIGxpbmVYMCwgbGluZVkwLCBsaW5lWDEsIGxpbmVZMSkge1xuICAgICAgdmFyIGxkeCA9IGxpbmVYMSAtIGxpbmVYMDtcbiAgICAgIHZhciBsZHkgPSBsaW5lWTEgLSBsaW5lWTA7XG4gICAgICB2YXIgbGVuZ3RoU3EgPSBsZHggKiBsZHggKyBsZHkgKiBsZHk7XG4gICAgICB2YXIgdCA9IGxlbmd0aFNxID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKCh4IC0gbGluZVgwKSAqIGxkeCArICh5IC0gbGluZVkwKSAqIGxkeSkgLyBsZW5ndGhTcSkpIDogMDtcbiAgICAgIHZhciBkeCA9IHggLSAobGluZVgwICsgdCAqIGxkeCk7XG4gICAgICB2YXIgZHkgPSB5IC0gKGxpbmVZMCArIHQgKiBsZHkpO1xuICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5XG4gICAgfVxuXG4gICAgdmFyIGphdmFzY3JpcHQgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICBnZW5lcmF0ZTogZ2VuZXJhdGUkMixcbiAgICAgIGdlbmVyYXRlSW50b0NhbnZhczogZ2VuZXJhdGVJbnRvQ2FudmFzJDIsXG4gICAgICBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlcjogZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIkMVxuICAgIH0pO1xuXG4gICAgdmFyIG1haW5WZXJ0ZXggPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDt1bmlmb3JtIHZlYzQgdUdseXBoQm91bmRzO2F0dHJpYnV0ZSB2ZWMyIGFVVjthdHRyaWJ1dGUgdmVjNCBhTGluZVNlZ21lbnQ7dmFyeWluZyB2ZWM0IHZMaW5lU2VnbWVudDt2YXJ5aW5nIHZlYzIgdkdseXBoWFk7dm9pZCBtYWluKCl7dkxpbmVTZWdtZW50PWFMaW5lU2VnbWVudDt2R2x5cGhYWT1taXgodUdseXBoQm91bmRzLnh5LHVHbHlwaEJvdW5kcy56dyxhVVYpO2dsX1Bvc2l0aW9uPXZlYzQobWl4KHZlYzIoLTEuMCksdmVjMigxLjApLGFVViksMC4wLDEuMCk7fVwiO1xuXG4gICAgdmFyIG1haW5GcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gdmVjNCB1R2x5cGhCb3VuZHM7dW5pZm9ybSBmbG9hdCB1TWF4RGlzdGFuY2U7dW5pZm9ybSBmbG9hdCB1RXhwb25lbnQ7dmFyeWluZyB2ZWM0IHZMaW5lU2VnbWVudDt2YXJ5aW5nIHZlYzIgdkdseXBoWFk7ZmxvYXQgYWJzRGlzdFRvU2VnbWVudCh2ZWMyIHBvaW50LHZlYzIgbGluZUEsdmVjMiBsaW5lQil7dmVjMiBsaW5lRGlyPWxpbmVCLWxpbmVBO2Zsb2F0IGxlblNxPWRvdChsaW5lRGlyLGxpbmVEaXIpO2Zsb2F0IHQ9bGVuU3E9PTAuMCA/IDAuMCA6IGNsYW1wKGRvdChwb2ludC1saW5lQSxsaW5lRGlyKS9sZW5TcSwwLjAsMS4wKTt2ZWMyIGxpbmVQdD1saW5lQSt0KmxpbmVEaXI7cmV0dXJuIGRpc3RhbmNlKHBvaW50LGxpbmVQdCk7fXZvaWQgbWFpbigpe3ZlYzQgc2VnPXZMaW5lU2VnbWVudDt2ZWMyIHA9dkdseXBoWFk7ZmxvYXQgZGlzdD1hYnNEaXN0VG9TZWdtZW50KHAsc2VnLnh5LHNlZy56dyk7ZmxvYXQgdmFsPXBvdygxLjAtY2xhbXAoZGlzdC91TWF4RGlzdGFuY2UsMC4wLDEuMCksdUV4cG9uZW50KSowLjU7Ym9vbCBjcm9zc2luZz0oc2VnLnk+cC55IT1zZWcudz5wLnkpJiYocC54PChzZWcuei1zZWcueCkqKHAueS1zZWcueSkvKHNlZy53LXNlZy55KStzZWcueCk7Ym9vbCBjcm9zc2luZ1VwPWNyb3NzaW5nJiZ2TGluZVNlZ21lbnQueTx2TGluZVNlZ21lbnQudztnbF9GcmFnQ29sb3I9dmVjNChjcm9zc2luZ1VwID8gMS4wLzI1NS4wIDogMC4wLGNyb3NzaW5nJiYhY3Jvc3NpbmdVcCA/IDEuMC8yNTUuMCA6IDAuMCwwLjAsdmFsKTt9XCI7XG5cbiAgICB2YXIgcG9zdEZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSBzYW1wbGVyMkQgdGV4O3ZhcnlpbmcgdmVjMiB2VVY7dm9pZCBtYWluKCl7dmVjNCBjb2xvcj10ZXh0dXJlMkQodGV4LHZVVik7Ym9vbCBpbnNpZGU9Y29sb3IuciE9Y29sb3IuZztmbG9hdCB2YWw9aW5zaWRlID8gMS4wLWNvbG9yLmEgOiBjb2xvci5hO2dsX0ZyYWdDb2xvcj12ZWM0KHZhbCk7fVwiO1xuXG4gICAgLy8gU2luZ2xlIHRyaWFuZ2xlIGNvdmVyaW5nIHZpZXdwb3J0XG4gICAgdmFyIHZpZXdwb3J0VVZzID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMiwgMCwgMCwgMl0pO1xuXG4gICAgdmFyIGltcGxpY2l0Q29udGV4dCA9IG51bGw7XG4gICAgdmFyIGlzVGVzdGluZ1N1cHBvcnQgPSBmYWxzZTtcbiAgICB2YXIgTlVMTF9PQkpFQ1QgPSB7fTtcbiAgICB2YXIgc3VwcG9ydEJ5Q2FudmFzID0gbmV3IFdlYWtNYXAoKTsgLy8gY2FudmFzIC0+IGJvb2xcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3VwcG9ydCAoZ2xPckNhbnZhcykge1xuICAgICAgaWYgKCFpc1Rlc3RpbmdTdXBwb3J0ICYmICFpc1N1cHBvcnRlZChnbE9yQ2FudmFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUkMSAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBnbE9yQ2FudmFzKSB7XG4gICAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgICBpZiAoIGdsT3JDYW52YXMgPT09IHZvaWQgMCApIGdsT3JDYW52YXMgPSBudWxsO1xuXG4gICAgICBpZiAoIWdsT3JDYW52YXMpIHtcbiAgICAgICAgZ2xPckNhbnZhcyA9IGltcGxpY2l0Q29udGV4dDtcbiAgICAgICAgaWYgKCFnbE9yQ2FudmFzKSB7XG4gICAgICAgICAgdmFyIGNhbnZhcyA9IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKVxuICAgICAgICAgICAgOiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09mZnNjcmVlbkNhbnZhcyBvciBET00gY2FudmFzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBnbE9yQ2FudmFzID0gaW1wbGljaXRDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgeyBkZXB0aDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGVTdXBwb3J0KGdsT3JDYW52YXMpO1xuXG4gICAgICB2YXIgcmdiYURhdGEgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCAqIDQpOyAvL25vdCBVaW50OENsYW1wZWRBcnJheSwgY3V6IFNhZmFyaVxuXG4gICAgICAvLyBSZW5kZXIgaW50byBhIGJhY2tncm91bmQgdGV4dHVyZSBmcmFtZWJ1ZmZlclxuICAgICAgd2l0aFdlYkdMQ29udGV4dChnbE9yQ2FudmFzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgICAgdmFyIHdpdGhUZXh0dXJlID0gcmVmLndpdGhUZXh0dXJlO1xuICAgICAgICB2YXIgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlciA9IHJlZi53aXRoVGV4dHVyZUZyYW1lYnVmZmVyO1xuXG4gICAgICAgIHdpdGhUZXh0dXJlKCdyZWFkYWJsZScsIGZ1bmN0aW9uICh0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkge1xuICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2RmV2lkdGgsIHNkZkhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICAgICAgICB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyKHRleHR1cmUsIHRleHR1cmVVbml0LCBmdW5jdGlvbiAoZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyKFxuICAgICAgICAgICAgICBzZGZXaWR0aCxcbiAgICAgICAgICAgICAgc2RmSGVpZ2h0LFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICB2aWV3Qm94LFxuICAgICAgICAgICAgICBtYXhEaXN0YW5jZSxcbiAgICAgICAgICAgICAgc2RmRXhwb25lbnQsXG4gICAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgICBmcmFtZWJ1ZmZlcixcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMCAvLyByZWQgY2hhbm5lbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgc2RmV2lkdGgsIHNkZkhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcmdiYURhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUaHJvdyBhd2F5IGFsbCBidXQgdGhlIHJlZCBjaGFubmVsXG4gICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHNkZldpZHRoICogc2RmSGVpZ2h0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IHJnYmFEYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaisrXSA9IHJnYmFEYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyQxKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCBudWxsLCB4LCB5LCBjaGFubmVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBnbE9yQ2FudmFzLCBmcmFtZWJ1ZmZlciwgeCwgeSwgY2hhbm5lbCkge1xuICAgICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgICAgaWYgKCB4ID09PSB2b2lkIDAgKSB4ID0gMDtcbiAgICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgICAvLyBWZXJpZnkgc3VwcG9ydFxuICAgICAgdmFsaWRhdGVTdXBwb3J0KGdsT3JDYW52YXMpO1xuXG4gICAgICAvLyBDb21wdXRlIHBhdGggc2VnbWVudHNcbiAgICAgIHZhciBsaW5lU2VnbWVudENvb3JkcyA9IFtdO1xuICAgICAgcGF0aFRvTGluZVNlZ21lbnRzKHBhdGgsIGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBsaW5lU2VnbWVudENvb3Jkcy5wdXNoKHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgIH0pO1xuICAgICAgbGluZVNlZ21lbnRDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KGxpbmVTZWdtZW50Q29vcmRzKTtcblxuICAgICAgd2l0aFdlYkdMQ29udGV4dChnbE9yQ2FudmFzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgICAgdmFyIGlzV2ViR0wyID0gcmVmLmlzV2ViR0wyO1xuICAgICAgICB2YXIgZ2V0RXh0ZW5zaW9uID0gcmVmLmdldEV4dGVuc2lvbjtcbiAgICAgICAgdmFyIHdpdGhQcm9ncmFtID0gcmVmLndpdGhQcm9ncmFtO1xuICAgICAgICB2YXIgd2l0aFRleHR1cmUgPSByZWYud2l0aFRleHR1cmU7XG4gICAgICAgIHZhciB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyID0gcmVmLndpdGhUZXh0dXJlRnJhbWVidWZmZXI7XG4gICAgICAgIHZhciBoYW5kbGVDb250ZXh0TG9zcyA9IHJlZi5oYW5kbGVDb250ZXh0TG9zcztcblxuICAgICAgICB3aXRoVGV4dHVyZSgncmF3RGlzdGFuY2VzJywgZnVuY3Rpb24gKGludGVybWVkaWF0ZVRleHR1cmUsIGludGVybWVkaWF0ZVRleHR1cmVVbml0KSB7XG4gICAgICAgICAgaWYgKHNkZldpZHRoICE9PSBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0V2lkdGggfHwgc2RmSGVpZ2h0ICE9PSBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0SGVpZ2h0KSB7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgICAgICBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLFxuICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0V2lkdGggPSBzZGZXaWR0aCxcbiAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlVGV4dHVyZS5fbGFzdEhlaWdodCA9IHNkZkhlaWdodCxcbiAgICAgICAgICAgICAgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVbnNpZ25lZCBkaXN0YW5jZSBwYXNzXG4gICAgICAgICAgd2l0aFByb2dyYW0oJ21haW4nLCBtYWluVmVydGV4LCBtYWluRnJhZ21lbnQsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBzZXRBdHRyaWJ1dGUgPSByZWYuc2V0QXR0cmlidXRlO1xuICAgICAgICAgICAgdmFyIHNldFVuaWZvcm0gPSByZWYuc2V0VW5pZm9ybTtcblxuICAgICAgICAgICAgLy8gSW5pdCBleHRlbnNpb25zXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2luZ0V4dGVuc2lvbiA9ICFpc1dlYkdMMiAmJiBnZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgICAgICAgICAgIHZhciBibGVuZE1pbk1heEV4dGVuc2lvbiA9ICFpc1dlYkdMMiAmJiBnZXRFeHRlbnNpb24oJ0VYVF9ibGVuZF9taW5tYXgnKTtcblxuICAgICAgICAgICAgLy8gSW5pdC91cGRhdGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgc2V0QXR0cmlidXRlKCdhVVYnLCAyLCBnbC5TVEFUSUNfRFJBVywgMCwgdmlld3BvcnRVVnMpO1xuICAgICAgICAgICAgc2V0QXR0cmlidXRlKCdhTGluZVNlZ21lbnQnLCA0LCBnbC5EWU5BTUlDX0RSQVcsIDEsIGxpbmVTZWdtZW50Q29vcmRzKTtcblxuICAgICAgICAgICAgLy8gSW5pdC91cGRhdGUgdW5pZm9ybXNcbiAgICAgICAgICAgIHNldFVuaWZvcm0uYXBwbHkodm9pZCAwLCBbICc0ZicsICd1R2x5cGhCb3VuZHMnIF0uY29uY2F0KCB2aWV3Qm94ICkpO1xuICAgICAgICAgICAgc2V0VW5pZm9ybSgnMWYnLCAndU1heERpc3RhbmNlJywgbWF4RGlzdGFuY2UpO1xuICAgICAgICAgICAgc2V0VW5pZm9ybSgnMWYnLCAndUV4cG9uZW50Jywgc2RmRXhwb25lbnQpO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXIgaW5pdGlhbCB1bnNpZ25lZCBkaXN0YW5jZSAvIHdpbmRpbmcgbnVtYmVyIGluZm8gdG8gYSB0ZXh0dXJlXG4gICAgICAgICAgICB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyKGludGVybWVkaWF0ZVRleHR1cmUsIGludGVybWVkaWF0ZVRleHR1cmVVbml0LCBmdW5jdGlvbiAoZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCBzZGZXaWR0aCwgc2RmSGVpZ2h0KTtcbiAgICAgICAgICAgICAgZ2wuc2Npc3NvcigwLCAwLCBzZGZXaWR0aCwgc2RmSGVpZ2h0KTtcbiAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FKTtcbiAgICAgICAgICAgICAgLy8gUmVkK0dyZWVuIGNoYW5uZWxzIGFyZSBpbmNyZW1lbnRlZCAoRlVOQ19BREQpIGZvciBzZWdtZW50LXJheSBjcm9zc2luZ3MgdG8gZ2l2ZSBhIFwid2luZGluZyBudW1iZXJcIi5cbiAgICAgICAgICAgICAgLy8gQWxwaGEgaG9sZHMgdGhlIGNsb3Nlc3QgKE1BWCkgdW5zaWduZWQgZGlzdGFuY2UuXG4gICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgaXNXZWJHTDIgPyBnbC5NQVggOiBibGVuZE1pbk1heEV4dGVuc2lvbi5NQVhfRVhUKTtcbiAgICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQoZ2wuVFJJQU5HTEVTLCAwLCAzLCBsaW5lU2VnbWVudENvb3Jkcy5sZW5ndGggLyA0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jaW5nRXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShnbC5UUklBTkdMRVMsIDAsIDMsIGxpbmVTZWdtZW50Q29vcmRzLmxlbmd0aCAvIDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIERlYnVnXG4gICAgICAgICAgICAgIC8vIGNvbnN0IGRlYnVnID0gbmV3IFVpbnQ4QXJyYXkoc2RmV2lkdGggKiBzZGZIZWlnaHQgKiA0KVxuICAgICAgICAgICAgICAvLyBnbC5yZWFkUGl4ZWxzKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRlYnVnKVxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaW50ZXJtZWRpYXRlIHRleHR1cmUgZGF0YTogJywgZGVidWcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFVzZSB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIHRleHR1cmUgdG8gYXBwbHkgaW5zaWRlL291dHNpZGUgYW5kIHdyaXRlIHRvIHRoZSBvdXRwdXQgZnJhbWVidWZmZXIgcmVjdCtjaGFubmVsLlxuICAgICAgICAgIHdpdGhQcm9ncmFtKCdwb3N0Jywgdmlld3BvcnRRdWFkVmVydGV4LCBwb3N0RnJhZ21lbnQsIGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgICBwcm9ncmFtLnNldEF0dHJpYnV0ZSgnYVVWJywgMiwgZ2wuU1RBVElDX0RSQVcsIDAsIHZpZXdwb3J0VVZzKTtcbiAgICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybSgnMWknLCAndGV4JywgaW50ZXJtZWRpYXRlVGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIGdsLmNvbG9yTWFzayhjaGFubmVsID09PSAwLCBjaGFubmVsID09PSAxLCBjaGFubmVsID09PSAyLCBjaGFubmVsID09PSAzKTtcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KHgsIHksIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgICAgZ2wuc2Npc3Nvcih4LCB5LCBzZGZXaWR0aCwgc2RmSGVpZ2h0KTtcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCAzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSGFuZGxlIGNvbnRleHQgbG9zcyBvY2N1cnJpbmcgZHVyaW5nIGFueSBvZiB0aGUgYWJvdmUgY2FsbHNcbiAgICAgICAgaWYgKGdsLmlzQ29udGV4dExvc3QoKSkge1xuICAgICAgICAgIGhhbmRsZUNvbnRleHRMb3NzKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3ZWJnbCBjb250ZXh0IGxvc3QnKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1N1cHBvcnRlZCAoZ2xPckNhbnZhcykge1xuICAgICAgdmFyIGtleSA9ICghZ2xPckNhbnZhcyB8fCBnbE9yQ2FudmFzID09PSBpbXBsaWNpdENvbnRleHQpID8gTlVMTF9PQkpFQ1QgOiAoZ2xPckNhbnZhcy5jYW52YXMgfHwgZ2xPckNhbnZhcyk7XG4gICAgICB2YXIgc3VwcG9ydGVkID0gc3VwcG9ydEJ5Q2FudmFzLmdldChrZXkpO1xuICAgICAgaWYgKHN1cHBvcnRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlzVGVzdGluZ1N1cHBvcnQgPSB0cnVlO1xuICAgICAgICB2YXIgZmFpbFJlYXNvbiA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gU2luY2Ugd2UgY2FuJ3QgZGV0ZWN0IGFsbCBmYWlsdXJlIG1vZGVzIHVwIGZyb250LCBsZXQncyBqdXN0IGRvIGEgdHJpYWwgcnVuIG9mIGFcbiAgICAgICAgICAvLyBzaW1wbGUgcGF0aCBhbmQgY29tcGFyZSB3aGF0IHdlIGdldCBiYWNrIHRvIHRoZSBjb3JyZWN0IGV4cGVjdGVkIHJlc3VsdC4gVGhpcyB3aWxsXG4gICAgICAgICAgLy8gYWxzbyBzZXJ2ZSB0byBwcmltZSB0aGUgc2hhZGVyIGNvbXBpbGF0aW9uLlxuICAgICAgICAgIHZhciBleHBlY3RlZFJlc3VsdCA9IFtcbiAgICAgICAgICAgIDk3LCAxMDYsIDk3LCA2MSxcbiAgICAgICAgICAgIDk5LCAxMzcsIDExOCwgODAsXG4gICAgICAgICAgICA4MCwgMTE4LCAxMzcsIDk5LFxuICAgICAgICAgICAgNjEsIDk3LCAxMDYsIDk3XG4gICAgICAgICAgXTtcbiAgICAgICAgICB2YXIgdGVzdFJlc3VsdCA9IGdlbmVyYXRlJDEoXG4gICAgICAgICAgICA0LFxuICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICdNOCw4TDE2LDhMMjQsMjRMMTYsMjRaJyxcbiAgICAgICAgICAgIFswLCAwLCAzMiwgMzJdLFxuICAgICAgICAgICAgMjQsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgZ2xPckNhbnZhc1xuICAgICAgICAgICk7XG4gICAgICAgICAgc3VwcG9ydGVkID0gdGVzdFJlc3VsdCAmJiBleHBlY3RlZFJlc3VsdC5sZW5ndGggPT09IHRlc3RSZXN1bHQubGVuZ3RoICYmXG4gICAgICAgICAgICB0ZXN0UmVzdWx0LmV2ZXJ5KGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIHZhbCA9PT0gZXhwZWN0ZWRSZXN1bHRbaV07IH0pO1xuICAgICAgICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBmYWlsUmVhc29uID0gJ2JhZCB0cmlhbCBydW4gcmVzdWx0cyc7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oZXhwZWN0ZWRSZXN1bHQsIHRlc3RSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gVE9ETyBpZiBpdCB0aHJldyBkdWUgdG8gd2ViZ2wgY29udGV4dCBsb3NzLCBzaG91bGQgd2UgbWF5YmUgbGVhdmUgaXNTdXBwb3J0ZWQgYXMgbnVsbCBhbmQgdHJ5IGFnYWluIGxhdGVyP1xuICAgICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIGZhaWxSZWFzb24gPSBlcnIubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFpbFJlYXNvbikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignV2ViR0wgU0RGIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZDonLCBmYWlsUmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBpc1Rlc3RpbmdTdXBwb3J0ID0gZmFsc2U7XG4gICAgICAgIHN1cHBvcnRCeUNhbnZhcy5zZXQoa2V5LCBzdXBwb3J0ZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cHBvcnRlZFxuICAgIH1cblxuICAgIHZhciB3ZWJnbCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgIGdlbmVyYXRlOiBnZW5lcmF0ZSQxLFxuICAgICAgZ2VuZXJhdGVJbnRvQ2FudmFzOiBnZW5lcmF0ZUludG9DYW52YXMkMSxcbiAgICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyOiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlcixcbiAgICAgIGlzU3VwcG9ydGVkOiBpc1N1cHBvcnRlZFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgMkQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZXaWR0aCAtIHdpZHRoIG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2RmSGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGFuIFNWRy1saWtlIHBhdGggc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGdseXBoOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1ouXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdmlld0JveCAtIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBpbiBmb250IHVuaXRzIGFsaWduaW5nIHdpdGggdGhlIHRleHR1cmUncyBlZGdlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4RGlzdGFuY2UgLSB0aGUgbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBnbHlwaCBwYXRoIGluIGZvbnQgdW5pdHMgdGhhdCB3aWxsIGJlIGVuY29kZWQ7IGRlZmF1bHRzXG4gICAgICogICAgICAgIHRvIGhhbGYgdGhlIG1heGltdW0gdmlld0JveCBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzZGZFeHBvbmVudF0gLSBzcGVjaWZpZXMgYW4gZXhwb25lbnQgZm9yIGVuY29kaW5nIHRoZSBTREYncyBkaXN0YW5jZSB2YWx1ZXM7IGhpZ2hlciBleHBvbmVudHNcbiAgICAgKiAgICAgICAgd2lsbCBnaXZlIGdyZWF0ZXIgcHJlY2lzaW9uIG5lYXJlciB0aGUgZ2x5cGgncyBwYXRoLlxuICAgICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUoXG4gICAgICBzZGZXaWR0aCxcbiAgICAgIHNkZkhlaWdodCxcbiAgICAgIHBhdGgsXG4gICAgICB2aWV3Qm94LFxuICAgICAgbWF4RGlzdGFuY2UsXG4gICAgICBzZGZFeHBvbmVudFxuICAgICkge1xuICAgICAgaWYgKCBtYXhEaXN0YW5jZSA9PT0gdm9pZCAwICkgbWF4RGlzdGFuY2UgPSBNYXRoLm1heCh2aWV3Qm94WzJdIC0gdmlld0JveFswXSwgdmlld0JveFszXSAtIHZpZXdCb3hbMV0pIC8gMjtcbiAgICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlJDEuYXBwbHkod2ViZ2wsIGFyZ3VtZW50cylcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJ1dlYkdMIFNERiBnZW5lcmF0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIEpTJywgZSk7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZSQyLmFwcGx5KGphdmFzY3JpcHQsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBTREYgdGV4dHVyZSBpbWFnZSBmb3IgYSAyRCBwYXRoLCBpbnNlcnRpbmcgdGhlIHJlc3VsdCBpbnRvIGEgV2ViR0wgYGNhbnZhc2AgYXQgYSBnaXZlbiB4L3kgcG9zaXRpb25cbiAgICAgKiBhbmQgY29sb3IgY2hhbm5lbC4gVGhpcyBpcyBnZW5lcmFsbHkgbXVjaCBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBnZW5lcmF0ZWAgYmVjYXVzZSBpdCBkb2VzIG5vdCByZXF1aXJlIHJlYWRpbmcgcGl4ZWxzXG4gICAgICogYmFjayBmcm9tIHRoZSBHUFUtPkNQVSAtLSB0aGUgYGNhbnZhc2AgY2FuIGJlIHVzZWQgZGlyZWN0bHkgYXMgYSBXZWJHTCB0ZXh0dXJlIGltYWdlLCBzbyBpdCBhbGwgc3RheXMgb24gdGhlIEdQVS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZXaWR0aCAtIHdpZHRoIG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2RmSGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGFuIFNWRy1saWtlIHBhdGggc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGdseXBoOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1ouXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdmlld0JveCAtIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBpbiBmb250IHVuaXRzIGFsaWduaW5nIHdpdGggdGhlIHRleHR1cmUncyBlZGdlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4RGlzdGFuY2UgLSB0aGUgbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBnbHlwaCBwYXRoIGluIGZvbnQgdW5pdHMgdGhhdCB3aWxsIGJlIGVuY29kZWQ7IGRlZmF1bHRzXG4gICAgICogICAgICAgIHRvIGhhbGYgdGhlIG1heGltdW0gdmlld0JveCBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzZGZFeHBvbmVudF0gLSBzcGVjaWZpZXMgYW4gZXhwb25lbnQgZm9yIGVuY29kaW5nIHRoZSBTREYncyBkaXN0YW5jZSB2YWx1ZXM7IGhpZ2hlciBleHBvbmVudHNcbiAgICAgKiAgICAgICAgd2lsbCBnaXZlIGdyZWF0ZXIgcHJlY2lzaW9uIG5lYXJlciB0aGUgZ2x5cGgncyBwYXRoLlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR8T2Zmc2NyZWVuQ2FudmFzfSBjYW52YXMgLSBhIFdlYkdMLWVuYWJsZWQgY2FudmFzIGludG8gd2hpY2ggdGhlIFNERiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqICAgICAgICBPbmx5IHRoZSByZWxldmFudCByZWN0L2NoYW5uZWwgd2lsbCBiZSBtb2RpZmllZCwgdGhlIHJlc3Qgd2lsbCBiZSBwcmVzZXJ2ZWQuIFRvIGF2b2lkIHVucHJlZGljdGFibGUgcmVzdWx0c1xuICAgICAqICAgICAgICBkdWUgdG8gc2hhcmVkIEdMIGNvbnRleHQgc3RhdGUsIHRoaXMgY2FudmFzIHNob3VsZCBiZSBkZWRpY2F0ZWQgdG8gdXNlIGJ5IHRoaXMgbGlicmFyeSBhbG9uZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IHBvc2l0aW9uIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgU0RGLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgcG9zaXRpb24gYXQgd2hpY2ggdG8gcmVuZGVyIHRoZSBTREYuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWwgLSB0aGUgY29sb3IgY2hhbm5lbCBpbmRleCAoMC00KSBpbnRvIHdoaWNoIHRoZSBTREYgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyhcbiAgICAgIHNkZldpZHRoLFxuICAgICAgc2RmSGVpZ2h0LFxuICAgICAgcGF0aCxcbiAgICAgIHZpZXdCb3gsXG4gICAgICBtYXhEaXN0YW5jZSxcbiAgICAgIHNkZkV4cG9uZW50LFxuICAgICAgY2FudmFzLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBjaGFubmVsXG4gICAgKSB7XG4gICAgICBpZiAoIG1heERpc3RhbmNlID09PSB2b2lkIDAgKSBtYXhEaXN0YW5jZSA9IE1hdGgubWF4KHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdLCB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgLyAyO1xuICAgICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgICAgaWYgKCB4ID09PSB2b2lkIDAgKSB4ID0gMDtcbiAgICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGVJbnRvQ2FudmFzJDEuYXBwbHkod2ViZ2wsIGFyZ3VtZW50cylcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJ1dlYkdMIFNERiBnZW5lcmF0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIEpTJywgZSk7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUludG9DYW52YXMkMi5hcHBseShqYXZhc2NyaXB0LCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0cy5mb3JFYWNoUGF0aENvbW1hbmQgPSBmb3JFYWNoUGF0aENvbW1hbmQ7XG4gICAgZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuICAgIGV4cG9ydHMuZ2VuZXJhdGVJbnRvQ2FudmFzID0gZ2VuZXJhdGVJbnRvQ2FudmFzO1xuICAgIGV4cG9ydHMuamF2YXNjcmlwdCA9IGphdmFzY3JpcHQ7XG4gICAgZXhwb3J0cy5wYXRoVG9MaW5lU2VnbWVudHMgPSBwYXRoVG9MaW5lU2VnbWVudHM7XG4gICAgZXhwb3J0cy53ZWJnbCA9IHdlYmdsO1xuICAgIGV4cG9ydHMud2ViZ2xVdGlscyA9IHdlYmdsVXRpbHM7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4gICAgcmV0dXJuIGV4cG9ydHM7XG5cbiAgfSh7fSkpO1xuICByZXR1cm4gZXhwb3J0c1xuICB9XG5cbiAgcmV0dXJuIFNERkdlbmVyYXRvcjtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.js\n");

/***/ })

};
;