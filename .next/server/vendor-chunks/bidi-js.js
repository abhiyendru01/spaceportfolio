/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bidi-js";
exports.ids = ["vendor-chunks/bidi-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/bidi-js/dist/bidi.js":
/*!*******************************************!*\
  !*** ./node_modules/bidi-js/dist/bidi.js ***!
  \*******************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  function bidiFactory() {\n  var bidi = (function (exports) {\n\n    // Bidi character types data, auto generated\n    var DATA = {\n      \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n      \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n      \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n      \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n      \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n      \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n      \"B\": \"a,3,f+2,2v,690\",\n      \"S\": \"9,2,k\",\n      \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n      \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n      \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n      \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n      \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n      \"LRO\": \"6ct\",\n      \"RLO\": \"6cu\",\n      \"LRE\": \"6cq\",\n      \"RLE\": \"6cr\",\n      \"PDF\": \"6cs\",\n      \"LRI\": \"6ee\",\n      \"RLI\": \"6ef\",\n      \"FSI\": \"6eg\",\n      \"PDI\": \"6eh\"\n    };\n\n    var TYPES = {};\n    var TYPES_TO_NAMES = {};\n    TYPES.L = 1; //L is the default\n    TYPES_TO_NAMES[1] = 'L';\n    Object.keys(DATA).forEach(function (type, i) {\n      TYPES[type] = 1 << (i + 1);\n      TYPES_TO_NAMES[TYPES[type]] = type;\n    });\n    Object.freeze(TYPES);\n\n    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n\n    var map = null;\n\n    function parseData () {\n      if (!map) {\n        //const start = performance.now()\n        map = new Map();\n        var loop = function ( type ) {\n          if (DATA.hasOwnProperty(type)) {\n            var lastCode = 0;\n            DATA[type].split(',').forEach(function (range) {\n              var ref = range.split('+');\n              var skip = ref[0];\n              var step = ref[1];\n              skip = parseInt(skip, 36);\n              step = step ? parseInt(step, 36) : 0;\n              map.set(lastCode += skip, TYPES[type]);\n              for (var i = 0; i < step; i++) {\n                map.set(++lastCode, TYPES[type]);\n              }\n            });\n          }\n        };\n\n        for (var type in DATA) loop( type );\n        //console.log(`char types parsed in ${performance.now() - start}ms`)\n      }\n    }\n\n    /**\n     * @param {string} char\n     * @return {number}\n     */\n    function getBidiCharType (char) {\n      parseData();\n      return map.get(char.codePointAt(0)) || TYPES.L\n    }\n\n    function getBidiCharTypeName(char) {\n      return TYPES_TO_NAMES[getBidiCharType(char)]\n    }\n\n    // Bidi bracket pairs data, auto generated\n    var data$1 = {\n      \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n      \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n    };\n\n    /**\n     * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n     * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n     * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n     * @param {string} encodedString\n     * @param {boolean} includeReverse - true if you want reverseMap in the output\n     * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n     */\n    function parseCharacterMap (encodedString, includeReverse) {\n      var radix = 36;\n      var lastCode = 0;\n      var map = new Map();\n      var reverseMap = includeReverse && new Map();\n      var prevPair;\n      encodedString.split(',').forEach(function visit(entry) {\n        if (entry.indexOf('+') !== -1) {\n          for (var i = +entry; i--;) {\n            visit(prevPair);\n          }\n        } else {\n          prevPair = entry;\n          var ref = entry.split('>');\n          var a = ref[0];\n          var b = ref[1];\n          a = String.fromCodePoint(lastCode += parseInt(a, radix));\n          b = String.fromCodePoint(lastCode += parseInt(b, radix));\n          map.set(a, b);\n          includeReverse && reverseMap.set(b, a);\n        }\n      });\n      return { map: map, reverseMap: reverseMap }\n    }\n\n    var openToClose, closeToOpen, canonical;\n\n    function parse$1 () {\n      if (!openToClose) {\n        //const start = performance.now()\n        var ref = parseCharacterMap(data$1.pairs, true);\n        var map = ref.map;\n        var reverseMap = ref.reverseMap;\n        openToClose = map;\n        closeToOpen = reverseMap;\n        canonical = parseCharacterMap(data$1.canonical, false).map;\n        //console.log(`brackets parsed in ${performance.now() - start}ms`)\n      }\n    }\n\n    function openingToClosingBracket (char) {\n      parse$1();\n      return openToClose.get(char) || null\n    }\n\n    function closingToOpeningBracket (char) {\n      parse$1();\n      return closeToOpen.get(char) || null\n    }\n\n    function getCanonicalBracket (char) {\n      parse$1();\n      return canonical.get(char) || null\n    }\n\n    // Local type aliases\n    var TYPE_L = TYPES.L;\n    var TYPE_R = TYPES.R;\n    var TYPE_EN = TYPES.EN;\n    var TYPE_ES = TYPES.ES;\n    var TYPE_ET = TYPES.ET;\n    var TYPE_AN = TYPES.AN;\n    var TYPE_CS = TYPES.CS;\n    var TYPE_B = TYPES.B;\n    var TYPE_S = TYPES.S;\n    var TYPE_ON = TYPES.ON;\n    var TYPE_BN = TYPES.BN;\n    var TYPE_NSM = TYPES.NSM;\n    var TYPE_AL = TYPES.AL;\n    var TYPE_LRO = TYPES.LRO;\n    var TYPE_RLO = TYPES.RLO;\n    var TYPE_LRE = TYPES.LRE;\n    var TYPE_RLE = TYPES.RLE;\n    var TYPE_PDF = TYPES.PDF;\n    var TYPE_LRI = TYPES.LRI;\n    var TYPE_RLI = TYPES.RLI;\n    var TYPE_FSI = TYPES.FSI;\n    var TYPE_PDI = TYPES.PDI;\n\n    /**\n     * @typedef {object} GetEmbeddingLevelsResult\n     * @property {{start, end, level}[]} paragraphs\n     * @property {Uint8Array} levels\n     */\n\n    /**\n     * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n     * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n     * base embedding level.\n     *\n     * @param {string} string - The input string\n     * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n     *        otherwise a direction will be chosen automatically from each paragraph's contents.\n     * @return {GetEmbeddingLevelsResult}\n     */\n    function getEmbeddingLevels (string, baseDirection) {\n      var MAX_DEPTH = 125;\n\n      // Start by mapping all characters to their unicode type, as a bitmask integer\n      var charTypes = new Uint32Array(string.length);\n      for (var i = 0; i < string.length; i++) {\n        charTypes[i] = getBidiCharType(string[i]);\n      }\n\n      var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n      function changeCharType(i, type) {\n        var oldType = charTypes[i];\n        charTypes[i] = type;\n        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n        if (oldType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n        }\n        charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n        if (type & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n      }\n\n      var embedLevels = new Uint8Array(string.length);\n      var isolationPairs = new Map(); //init->pdi and pdi->init\n\n      // === 3.3.1 The Paragraph Level ===\n      // 3.3.1 P1: Split the text into paragraphs\n      var paragraphs = []; // [{start, end, level}, ...]\n      var paragraph = null;\n      for (var i$1 = 0; i$1 < string.length; i$1++) {\n        if (!paragraph) {\n          paragraphs.push(paragraph = {\n            start: i$1,\n            end: string.length - 1,\n            // 3.3.1 P2-P3: Determine the paragraph level\n            level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n          });\n        }\n        if (charTypes[i$1] & TYPE_B) {\n          paragraph.end = i$1;\n          paragraph = null;\n        }\n      }\n\n      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n      var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };\n      var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };\n\n      // Everything from here on will operate per paragraph.\n      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n        paragraph = paragraphs[paraIdx];\n        var statusStack = [{\n          _level: paragraph.level,\n          _override: 0, //0=neutral, 1=L, 2=R\n          _isolate: 0 //bool\n        }];\n        var stackTop = (void 0);\n        var overflowIsolateCount = 0;\n        var overflowEmbeddingCount = 0;\n        var validIsolateCount = 0;\n        charTypeCounts.clear();\n\n        // === 3.3.2 Explicit Levels and Directions ===\n        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n          var charType = charTypes[i$2];\n          stackTop = statusStack[statusStack.length - 1];\n\n          // Set initial counts\n          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n          if (charType & NEUTRAL_ISOLATE_TYPES) {\n            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n          }\n\n          // Explicit Embeddings: 3.3.2 X2 - X3\n          if (charType & FORMATTING_TYPES) { //prefilter all formatters\n            if (charType & (TYPE_RLE | TYPE_LRE)) {\n              embedLevels[i$2] = stackTop._level; // 5.2\n              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n                statusStack.push({\n                  _level: level,\n                  _override: 0,\n                  _isolate: 0\n                });\n              } else if (!overflowIsolateCount) {\n                overflowEmbeddingCount++;\n              }\n            }\n\n            // Explicit Overrides: 3.3.2 X4 - X5\n            else if (charType & (TYPE_RLO | TYPE_LRO)) {\n              embedLevels[i$2] = stackTop._level; // 5.2\n              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n                statusStack.push({\n                  _level: level$1,\n                  _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,\n                  _isolate: 0\n                });\n              } else if (!overflowIsolateCount) {\n                overflowEmbeddingCount++;\n              }\n            }\n\n            // Isolates: 3.3.2 X5a - X5c\n            else if (charType & ISOLATE_INIT_TYPES) {\n              // X5c - FSI becomes either RLI or LRI\n              if (charType & TYPE_FSI) {\n                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n              }\n\n              embedLevels[i$2] = stackTop._level;\n              if (stackTop._override) {\n                changeCharType(i$2, stackTop._override);\n              }\n              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n                validIsolateCount++;\n                statusStack.push({\n                  _level: level$2,\n                  _override: 0,\n                  _isolate: 1,\n                  _isolInitIndex: i$2\n                });\n              } else {\n                overflowIsolateCount++;\n              }\n            }\n\n            // Terminating Isolates: 3.3.2 X6a\n            else if (charType & TYPE_PDI) {\n              if (overflowIsolateCount > 0) {\n                overflowIsolateCount--;\n              } else if (validIsolateCount > 0) {\n                overflowEmbeddingCount = 0;\n                while (!statusStack[statusStack.length - 1]._isolate) {\n                  statusStack.pop();\n                }\n                // Add to isolation pairs bidirectional mapping:\n                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n                if (isolInitIndex != null) {\n                  isolationPairs.set(isolInitIndex, i$2);\n                  isolationPairs.set(i$2, isolInitIndex);\n                }\n                statusStack.pop();\n                validIsolateCount--;\n              }\n              stackTop = statusStack[statusStack.length - 1];\n              embedLevels[i$2] = stackTop._level;\n              if (stackTop._override) {\n                changeCharType(i$2, stackTop._override);\n              }\n            }\n\n\n            // Terminating Embeddings and Overrides: 3.3.2 X7\n            else if (charType & TYPE_PDF) {\n              if (overflowIsolateCount === 0) {\n                if (overflowEmbeddingCount > 0) {\n                  overflowEmbeddingCount--;\n                } else if (!stackTop._isolate && statusStack.length > 1) {\n                  statusStack.pop();\n                  stackTop = statusStack[statusStack.length - 1];\n                }\n              }\n              embedLevels[i$2] = stackTop._level; // 5.2\n            }\n\n            // End of Paragraph: 3.3.2 X8\n            else if (charType & TYPE_B) {\n              embedLevels[i$2] = paragraph.level;\n            }\n          }\n\n          // Non-formatting characters: 3.3.2 X6\n          else {\n            embedLevels[i$2] = stackTop._level;\n            // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n            if (stackTop._override && charType !== TYPE_BN) {\n              changeCharType(i$2, stackTop._override);\n            }\n          }\n        }\n\n        // === 3.3.3 Preparations for Implicit Processing ===\n\n        // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n        // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n        // easily ignore them all from here on out.\n\n        // 3.3.3 X10\n        // Compute the set of isolating run sequences as specified by BD13\n        var levelRuns = [];\n        var currentRun = null;\n        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n          var charType$1 = charTypes[i$3];\n          if (!(charType$1 & BN_LIKE_TYPES)) {\n            var lvl = embedLevels[i$3];\n            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n            var isPDI = charType$1 === TYPE_PDI;\n            if (currentRun && lvl === currentRun._level) {\n              currentRun._end = i$3;\n              currentRun._endsWithIsolInit = isIsolInit;\n            } else {\n              levelRuns.push(currentRun = {\n                _start: i$3,\n                _end: i$3,\n                _level: lvl,\n                _startsWithPDI: isPDI,\n                _endsWithIsolInit: isIsolInit\n              });\n            }\n          }\n        }\n        var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n          var run = levelRuns[runIdx];\n          if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {\n            var seqRuns = [currentRun = run];\n            for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n                if (levelRuns[i$4]._start === pdiIndex) {\n                  seqRuns.push(currentRun = levelRuns[i$4]);\n                  break\n                }\n              }\n            }\n            // build flat list of indices across all runs:\n            var seqIndices = [];\n            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n              var run$1 = seqRuns[i$5];\n              for (var j = run$1._start; j <= run$1._end; j++) {\n                seqIndices.push(j);\n              }\n            }\n            // determine the sos/eos types:\n            var firstLevel = embedLevels[seqIndices[0]];\n            var prevLevel = paragraph.level;\n            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n              if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2\n                prevLevel = embedLevels[i$6];\n                break\n              }\n            }\n            var lastIndex = seqIndices[seqIndices.length - 1];\n            var lastLevel = embedLevels[lastIndex];\n            var nextLevel = paragraph.level;\n            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n                if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2\n                  nextLevel = embedLevels[i$7];\n                  break\n                }\n              }\n            }\n            isolatingRunSeqs.push({\n              _seqIndices: seqIndices,\n              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n            });\n          }\n        }\n\n        // The next steps are done per isolating run sequence\n        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n          var ref = isolatingRunSeqs[seqIdx];\n          var seqIndices$1 = ref._seqIndices;\n          var sosType = ref._sosType;\n          var eosType = ref._eosType;\n          /**\n           * All the level runs in an isolating run sequence have the same embedding level.\n           * \n           * DO NOT change any `embedLevels[i]` within the current scope.\n           */\n          var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;\n\n          // === 3.3.4 Resolving Weak Types ===\n\n          // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n          // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n          // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n          if (charTypeCounts.get(TYPE_NSM)) {\n            for (var si = 0; si < seqIndices$1.length; si++) {\n              var i$8 = seqIndices$1[si];\n              if (charTypes[i$8] & TYPE_NSM) {\n                var prevType = sosType;\n                for (var sj = si - 1; sj >= 0; sj--) {\n                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN\n                    prevType = charTypes[seqIndices$1[sj]];\n                    break\n                  }\n                }\n                changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);\n              }\n            }\n          }\n\n          // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n          // is found. If an AL is found, change the type of the European number to Arabic number.\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n              var i$9 = seqIndices$1[si$1];\n              if (charTypes[i$9] & TYPE_EN) {\n                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n                  if (prevCharType & STRONG_TYPES) {\n                    if (prevCharType === TYPE_AL) {\n                      changeCharType(i$9, TYPE_AN);\n                    }\n                    break\n                  }\n                }\n              }\n            }\n          }\n\n          // W3. Change all ALs to R\n          if (charTypeCounts.get(TYPE_AL)) {\n            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n              var i$10 = seqIndices$1[si$2];\n              if (charTypes[i$10] & TYPE_AL) {\n                changeCharType(i$10, TYPE_R);\n              }\n            }\n          }\n\n          // W4. A single European separator between two European numbers changes to a European number. A single common\n          // separator between two numbers of the same type changes to that type.\n          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n              var i$11 = seqIndices$1[si$3];\n              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n                var prevType$1 = 0, nextType = 0;\n                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                  prevType$1 = charTypes[seqIndices$1[sj$2]];\n                  if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2\n                    break\n                  }\n                }\n                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                  nextType = charTypes[seqIndices$1[sj$3]];\n                  if (!(nextType & BN_LIKE_TYPES)) { //5.2\n                    break\n                  }\n                }\n                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {\n                  changeCharType(i$11, prevType$1);\n                }\n              }\n            }\n          }\n\n          // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n              var i$12 = seqIndices$1[si$4];\n              if (charTypes[i$12] & TYPE_EN) {\n                for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {\n                  changeCharType(seqIndices$1[sj$4], TYPE_EN);\n                }\n                for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {\n                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {\n                    changeCharType(seqIndices$1[si$4], TYPE_EN);\n                  }\n                }\n              }\n            }\n          }\n\n          // W6. Otherwise, separators and terminators change to Other Neutral.\n          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n              var i$13 = seqIndices$1[si$5];\n              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n                changeCharType(i$13, TYPE_ON);\n                // 5.2 transform adjacent BNs too:\n                for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {\n                  changeCharType(seqIndices$1[sj$5], TYPE_ON);\n                }\n                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {\n                  changeCharType(seqIndices$1[sj$6], TYPE_ON);\n                }\n              }\n            }\n          }\n\n          // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n          // is found. If an L is found, then change the type of the European number to L.\n          // NOTE: implemented in single forward pass for efficiency\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n              var i$14 = seqIndices$1[si$6];\n              var type = charTypes[i$14];\n              if (type & TYPE_EN) {\n                if (prevStrongType === TYPE_L) {\n                  changeCharType(i$14, TYPE_L);\n                }\n              } else if (type & STRONG_TYPES) {\n                prevStrongType = type;\n              }\n            }\n          }\n\n          // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n            // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n            // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n            // types EN and AN are treated as R.\n            var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);\n            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n            // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n            var bracketPairs = [];\n            {\n              var openerStack = [];\n              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n                // NOTE: for any potential bracket character we also test that it still carries a NI\n                // type, as that may have been changed earlier. This doesn't seem to be explicitly\n                // called out in the spec, but is required for passage of certain tests.\n                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                  var char = string[seqIndices$1[si$7]];\n                  var oppositeBracket = (void 0);\n                  // Opening bracket\n                  if (openingToClosingBracket(char) !== null) {\n                    if (openerStack.length < 63) {\n                      openerStack.push({ char: char, seqIndex: si$7 });\n                    } else {\n                      break\n                    }\n                  }\n                  // Closing bracket\n                  else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                      var stackChar = openerStack[stackIdx].char;\n                      if (stackChar === oppositeBracket ||\n                        stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||\n                        openingToClosingBracket(getCanonicalBracket(stackChar)) === char\n                      ) {\n                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                        openerStack.length = stackIdx; //pop the matching bracket and all following\n                        break\n                      }\n                    }\n                  }\n                }\n              }\n              bracketPairs.sort(function (a, b) { return a[0] - b[0]; });\n            }\n            // * For each bracket-pair element in the list of pairs of text positions\n            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n              var ref$1 = bracketPairs[pairIdx];\n              var openSeqIdx = ref$1[0];\n              var closeSeqIdx = ref$1[1];\n              // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n              // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n              // brackets in the pair to match the embedding direction.\n              var foundStrongType = false;\n              var useStrongType = 0;\n              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n                var i$15 = seqIndices$1[si$8];\n                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                  foundStrongType = true;\n                  var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  if (lr === embedDirection) {\n                    useStrongType = lr;\n                    break\n                  }\n                }\n              }\n              // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n              // for an established context with a preceding strong type by checking backwards before the opening paired\n              // bracket until the first strong type (L, R, or sos) is found.\n              //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n              //    set the type for both brackets in the pair to that direction.\n              //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n              if (foundStrongType && !useStrongType) {\n                useStrongType = sosType;\n                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                  var i$16 = seqIndices$1[si$9];\n                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                    var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                    if (lr$1 !== embedDirection) {\n                      useStrongType = lr$1;\n                    } else {\n                      useStrongType = embedDirection;\n                    }\n                    break\n                  }\n                }\n              }\n              if (useStrongType) {\n                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;\n                // * Any number of characters that had original bidirectional character type NSM prior to the application\n                // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n                // the type of their preceding bracket.\n                if (useStrongType !== embedDirection) {\n                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                        charTypes[seqIndices$1[si$10]] = useStrongType;\n                      }\n                      break\n                    }\n                  }\n                }\n                if (useStrongType !== embedDirection) {\n                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                        charTypes[seqIndices$1[si$11]] = useStrongType;\n                      }\n                      break\n                    }\n                  }\n                }\n              }\n            }\n\n            // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n            // same direction.\n            // N2. Any remaining NIs take the embedding direction.\n            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n                var niRunStart = si$12, niRunEnd = si$12;\n                var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n                for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                    niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                  } else {\n                    prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                    break\n                  }\n                }\n                var nextType$1 = eosType;\n                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                    niRunEnd = si2$1;\n                  } else {\n                    nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                    break\n                  }\n                }\n                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {\n                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;\n                }\n                si$12 = niRunEnd;\n              }\n            }\n          }\n        }\n\n        // === 3.3.6 Resolving Implicit Levels ===\n\n        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n          var level$3 = embedLevels[i$17];\n          var type$1 = charTypes[i$17];\n          // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n          if (level$3 & 1) {\n            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n              embedLevels[i$17]++;\n            }\n          }\n            // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n          // and those of type AN or EN go up two levels.\n          else {\n            if (type$1 & TYPE_R) {\n              embedLevels[i$17]++;\n            } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n              embedLevels[i$17] += 2;\n            }\n          }\n\n          // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n          // and otherwise to the base level.\n          if (type$1 & BN_LIKE_TYPES) {\n            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n          }\n\n          // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n          // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n          // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n            for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {\n              embedLevels[j$1] = paragraph.level;\n            }\n          }\n        }\n      }\n\n      // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n      // according to section 3.4 Reordering Resolved Levels\n      return {\n        levels: embedLevels,\n        paragraphs: paragraphs\n      }\n\n      function determineAutoEmbedLevel (start, isFSI) {\n        // 3.3.1 P2 - P3\n        for (var i = start; i < string.length; i++) {\n          var charType = charTypes[i];\n          if (charType & (TYPE_R | TYPE_AL)) {\n            return 1\n          }\n          if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {\n            return 0\n          }\n          if (charType & ISOLATE_INIT_TYPES) {\n            var pdi = indexOfMatchingPDI(i);\n            i = pdi === -1 ? string.length : pdi;\n          }\n        }\n        return 0\n      }\n\n      function indexOfMatchingPDI (isolateStart) {\n        // 3.1.2 BD9\n        var isolationLevel = 1;\n        for (var i = isolateStart + 1; i < string.length; i++) {\n          var charType = charTypes[i];\n          if (charType & TYPE_B) {\n            break\n          }\n          if (charType & TYPE_PDI) {\n            if (--isolationLevel === 0) {\n              return i\n            }\n          } else if (charType & ISOLATE_INIT_TYPES) {\n            isolationLevel++;\n          }\n        }\n        return -1\n      }\n    }\n\n    // Bidi mirrored chars data, auto generated\n    var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n\n    var mirrorMap;\n\n    function parse () {\n      if (!mirrorMap) {\n        //const start = performance.now()\n        var ref = parseCharacterMap(data, true);\n        var map = ref.map;\n        var reverseMap = ref.reverseMap;\n        // Combine both maps into one\n        reverseMap.forEach(function (value, key) {\n          map.set(key, value);\n        });\n        mirrorMap = map;\n        //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n      }\n    }\n\n    function getMirroredCharacter (char) {\n      parse();\n      return mirrorMap.get(char) || null\n    }\n\n    /**\n     * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n     * for any characters in right-to-left segments that have defined mirrored characters.\n     * @param string\n     * @param embeddingLevels\n     * @param [start]\n     * @param [end]\n     * @return {Map<number, string>}\n     */\n    function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n      var strLen = string.length;\n      start = Math.max(0, start == null ? 0 : +start);\n      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n      var map = new Map();\n      for (var i = start; i <= end; i++) {\n        if (embeddingLevels[i] & 1) { //only odd (rtl) levels\n          var mirror = getMirroredCharacter(string[i]);\n          if (mirror !== null) {\n            map.set(i, mirror);\n          }\n        }\n      }\n      return map\n    }\n\n    /**\n     * Given a start and end denoting a single line within a string, and a set of precalculated\n     * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n     * @param {string} string - the full input string\n     * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n     * @param {number} [start] - first character in a subset of the full string\n     * @param {number} [end] - last character in a subset of the full string\n     * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n     */\n    function getReorderSegments(string, embeddingLevelsResult, start, end) {\n      var strLen = string.length;\n      start = Math.max(0, start == null ? 0 : +start);\n      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n      var segments = [];\n      embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n        var lineStart = Math.max(start, paragraph.start);\n        var lineEnd = Math.min(end, paragraph.end);\n        if (lineStart < lineEnd) {\n          // Local slice for mutation\n          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);\n\n          // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n          // end of the line to the paragraph level.\n          for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {\n            lineLevels[i] = paragraph.level;\n          }\n\n          // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n          // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n          var maxLevel = paragraph.level;\n          var minOddLevel = Infinity;\n          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n            var level = lineLevels[i$1];\n            if (level > maxLevel) { maxLevel = level; }\n            if (level < minOddLevel) { minOddLevel = level | 1; }\n          }\n          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n              if (lineLevels[i$2] >= lvl) {\n                var segStart = i$2;\n                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                  i$2++;\n                }\n                if (i$2 > segStart) {\n                  segments.push([segStart + lineStart, i$2 + lineStart]);\n                }\n              }\n            }\n          }\n        }\n      });\n      return segments\n    }\n\n    /**\n     * @param {string} string\n     * @param {GetEmbeddingLevelsResult} embedLevelsResult\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {string} the new string with bidi segments reordered\n     */\n    function getReorderedString(string, embedLevelsResult, start, end) {\n      var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n      var chars = [].concat( string );\n      indices.forEach(function (charIndex, i) {\n        chars[i] = (\n          (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null\n        ) || string[charIndex];\n      });\n      return chars.join('')\n    }\n\n    /**\n     * @param {string} string\n     * @param {GetEmbeddingLevelsResult} embedLevelsResult\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {number[]} an array with character indices in their new bidi order\n     */\n    function getReorderedIndices(string, embedLevelsResult, start, end) {\n      var segments = getReorderSegments(string, embedLevelsResult, start, end);\n      // Fill an array with indices\n      var indices = [];\n      for (var i = 0; i < string.length; i++) {\n        indices[i] = i;\n      }\n      // Reverse each segment in order\n      segments.forEach(function (ref) {\n        var start = ref[0];\n        var end = ref[1];\n\n        var slice = indices.slice(start, end + 1);\n        for (var i = slice.length; i--;) {\n          indices[end - i] = slice[i];\n        }\n      });\n      return indices\n    }\n\n    exports.closingToOpeningBracket = closingToOpeningBracket;\n    exports.getBidiCharType = getBidiCharType;\n    exports.getBidiCharTypeName = getBidiCharTypeName;\n    exports.getCanonicalBracket = getCanonicalBracket;\n    exports.getEmbeddingLevels = getEmbeddingLevels;\n    exports.getMirroredCharacter = getMirroredCharacter;\n    exports.getMirroredCharactersMap = getMirroredCharactersMap;\n    exports.getReorderSegments = getReorderSegments;\n    exports.getReorderedIndices = getReorderedIndices;\n    exports.getReorderedString = getReorderedString;\n    exports.openingToClosingBracket = openingToClosingBracket;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n    return exports;\n\n  }({}));\n  return bidi}\n\n  return bidiFactory;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmlkaS1qcy9kaXN0L2JpZGkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDc0c7QUFDeEcsQ0FBQyxzQkFBc0I7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxhQUFhOztBQUVoRTs7QUFFQSxHQUFHLEdBQUc7QUFDTjs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2Vwb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvYmlkaS1qcy9kaXN0L2JpZGkuanM/NzZhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5iaWRpX2pzID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIGJpZGlGYWN0b3J5KCkge1xuICB2YXIgYmlkaSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gICAgLy8gQmlkaSBjaGFyYWN0ZXIgdHlwZXMgZGF0YSwgYXV0byBnZW5lcmF0ZWRcbiAgICB2YXIgREFUQSA9IHtcbiAgICAgIFwiUlwiOiBcIjEzaywxYSwyLDMsMywyKzFqLGNoKzE2LGErMSw1KzIsMituLDUsYSw0LDYrMTYsNCszLGgrMWIsNG1vLDE3OXEsMis5LDIrMTEsMmk5Kzd5LDIrNjgsNCwzKzQsNSsxMyw0KzMsMis0aywzKzI5LDgrY2YsMXQrN3osdysxNywzKzNtLDF0KzN6LDE2bzErNXIsOCszMCw4K21jLDI5KzFyLDI5KzR2LDc1KzczXCIsXG4gICAgICBcIkVOXCI6IFwiMWMrOSwzZCsxLDYsMTg3KzksNTEzLDQrNSw3Kzksc2YraiwxNzVoKzkscXcrcSwxNjFmKzFkLDR4dCthLDI1aSs5XCIsXG4gICAgICBcIkVTXCI6IFwiMTcsMiw2ZHArMSxmKzEsYXYsMTZ2cixteCsxLDRvLDJcIixcbiAgICAgIFwiRVRcIjogXCJ6KzIsM2grMyxiKzEseW0sM2UrMSwybyxwNCsxLDgsNnUsN2MsZzYsMXdjLDFuOSs0LDMwKzFiLDJuLDZkLHFoeCsxLGgwbSxhKzEsNDkrMiw2MysxLDQrMSw2YmIrMywxMmpqXCIsXG4gICAgICBcIkFOXCI6IFwiMTZvKzUsMmorOSwyKzEsMzUsZWQsMWZmMis5LDg3K3VcIixcbiAgICAgIFwiQ1NcIjogXCIxOCwyKzEsYiwydSwxMmssNTV2LGwsMTd2MCwyLDMsNTMsMisxLGJcIixcbiAgICAgIFwiQlwiOiBcImEsMyxmKzIsMnYsNjkwXCIsXG4gICAgICBcIlNcIjogXCI5LDIsa1wiLFxuICAgICAgXCJXU1wiOiBcImMsayw0ZjQsMXZrK2EsdSwxaiwzMzVcIixcbiAgICAgIFwiT05cIjogXCJ4KzEsNCs0LGgrNSxyKzUsciszLHosNSszLDIrMSwyKzEsNSwyKzIsMys0LG8sdyxjaSsxLDgrZCwzK2QsNis4LDIrZywzOSsxLDksNisxLDIsMzMsYjgsMysxLDNjKzEsNysxLDVyLGIsN2grMyxzYSs1LDIsM2krNixqZyszLHVyKzksMnYsaWorMSw5Zys5LDcrYSw4bSw0KzEsNDkreCwxNHUsMisyLGMrMixlKzIsZSsyLGUrMSxpK24sZStlLDIrcCx1KzIsZSsyLDM2KzEsMiszLDIrMSxiLDIrMiw2KzUsMiwyLDIsaCsxLDUrNCw2KzMsMytmLDE2KzIsNSszbCwzKzgxLDF5K3AsMis0MCxxK2EsbSsxMywycitjaCwyKzllLDc1K2hmLDMrdiwyKzJ3LDZlKzUsZis2LDc1KzJhLDFhK3AsMisyZyxkKzV4LHIrYiw2KzMsNCtvLGcsNisxLDYrMiwyaysxLDQsMmosNWgreiwxbSsxLDFlK2YsdCsyLDFmK2UsZCszLDRvKzMsMnMrMSx3LDUzNSsxcixoM2wrMWksOTMrMiwycyxiKzEsM2wreCwydiw0ZyszLDIxKzMsa3orMSxnNXYrMSw1YSxqKzksbit2LDIsMywyKzgsMisxLDMrMiwyLDMsNDYrMSw0KzQsaCs1LHIrNSxyK2EsM2grMiw0KzYsYis0LDc4LDFyKzI0LDQrYyw0LDFoYixleSs2LDEwMytqLDE2aitjLDF1eCs3LDUrZyxmc2gsamRxKzF0LDQsNTcrMmUscDEsMW0sMW0sMW0sMW0sNGt0KzEsN2orMTcsNSsycixkK2UsMytlLDIrZSwyKzEwLG0rNCx3LDFuKzUsMXEsNHorNSw0YityYiw5K2MsNCtjLDQrMzcsZCsyZyw4K2IsbCtiLDUrMWosOSs5LDcrMTMsOSt0LDMrMSwyNyszYywyKzI5LDIrM3EsZCtkLDMrNCw0KzIsNis2LGErbyw4KzYsYSsyLGUrNiwxNis0MiwyKzFpXCIsXG4gICAgICBcIkJOXCI6IFwiMCs4LDYrZCwycys1LDIrcCxlLDRtOSwxa3QrMiwyYis1LDUrNSwxN3E5K3YsN2ssNnArOCw2KzEsMTE5ZCszLDQ0MCs3LDk2cysxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZis3NSw2cCsycnosMWJlbisxLDFla2YrMSwxZWtmKzFcIixcbiAgICAgIFwiTlNNXCI6IFwibGMrMzMsN28rNiw3YysxOCwyLDIrMSwyKzEsMiwyMSthLDFkK2ssaCwydSs2LDMrNSwzKzEsMiszLDEwLHYrcSwyaythLDFuKzgsYSxwKzMsMis4LDIrMiwyKzQsMTgrMiwzYytlLDIrdiwxaywyLDUrNyw1LDQrNixiKzEsdSwxbiw1KzMsOSxsKzEsciwzKzEsMW0sNSsxLDUrMSwzKzIsNCx2KzEsNCxjKzEsMW0sNSs0LDIrMSw1LGwrMSxuKzUsMiwxbiwzLDIrMyw5LDgrMSxjKzEsdiwxcSxkLDFmLDQsMW0rMiw2KzIsMiszLDgrMSxjKzEsdSwxbixnKzEsbCsxLHQrMSwxbSsxLDUrMyw5LGwrMSx1LDIxLDgrMiwyLDJqLDMrNixkKzcsMnIsMys4LGMrNSwyMysxLHMsMiwyLDFrK2QsMis0LDIrMSw2K2EsMit6LGEsMnYrMywyKzUsMisxLDMrMSxxKzEsNSsyLGgrMyxlLDMrMSw3LGcsamsrMixxYisyLHUrMix1KzEsdisxLDF0KzEsMis2LDksMythLGEsMWErMiwzYysxLHosM2IrMiw1KzEsYSw3KzIsNjQrMSwzLDFuLDIrNiwyLDIsMys3LDcrOSwzLDFkK2csMXMrMywxZCwyKzQsMiw2LDE1KzgsZCsxLHgrMywzKzEsMisyLDFsLDIrMSw0LDIrMiwxbis3LDMrMSw0OSsyLDIrYywyKzYsNSw3LDQrMSw1aisxbCwyKzQsazErdywyZGIrMiwzeSwycCt2LGZmKzMsMzArMSxuOXgrMywyKzkseCsxLDI5KzEsN2wsNCw1LHErMSw2LDQ4KzEscitoLGUsMTMrNyxxK2EsMWIrMiwxZCwzKzMsMysxLDE0LDF3KzUsMysxLDMrMSxkLDksMWMsMWcsMisyLDMrMSw2KzEsMiwxNysxLDksNm4sMyw1LGZuNSxraStmLGgrZixyMiw2Yiw0Nis0LDFhZisyLDIrMSw2KzMsMTUrMiw1LDRtKzEsZnkrMyxhcysxLDRhK2EsNHgsMWorZSwxbCsyLDFlKzMsMysxLDF5KzIsMTErNCwyKzcsMXIsZCsxLDFoKzgsYiszLDMsMm8rMiwzLDIrMSw3LDRoLDQrNyxtKzEsMW0rMSw0LDEyKzYsNCs0LDVnKzcsMysyLDIsbywyZCs1LDIsNSsxLDIrMSw2biszLDcrMSwyKzEscysxLDJlKzcsMywyKzEsMnosMiwzKzUsMiwydSsyLDMrMywyKzQsNzgrOCwyKzEsNzUrMSwyLDUsNDErMywzKzEsNSx4KzUsMysxLDE1KzUsMyszLDksYSs1LDMrMiwxYitjLDIrMSxiYis2LDIrNSwyZCtsLDMrNiwyKzEsMisxLDNmKzUsNCwyKzEsMis2LDIsMjErMSw0LDIsOW8rMSxmMGMrNCwxbys2LHQ1LDFzKzMsMmEsZjVsKzEsNDN0KzIsaSs3LDMrNix2KzMsNDUrMiwxajArMWksNSsxZCw5LGYsbis0LDIrZSwxMXQrNiwyK2csMys2LDIrMSwyKzQsN2ErNixjNiszLDE1dCs2LDMyKzYsZ3poeSs2blwiLFxuICAgICAgXCJBTFwiOiBcIjE2dywzLDIsZSsxYix6KzIsMisycyxnKzEsOCsxLGIrbSwyK3QscysyaSxjK2UsNGgrZiwxZCsxZSwxYndlK2RwLDMrM3oseCtjLDIrMSwzNSszeSwycm0reiw1KzcsYis1LGR0K2wsYyt1LDE3bmwrMjcsMXQrMjcsNHgrNm4sMytkXCIsXG4gICAgICBcIkxST1wiOiBcIjZjdFwiLFxuICAgICAgXCJSTE9cIjogXCI2Y3VcIixcbiAgICAgIFwiTFJFXCI6IFwiNmNxXCIsXG4gICAgICBcIlJMRVwiOiBcIjZjclwiLFxuICAgICAgXCJQREZcIjogXCI2Y3NcIixcbiAgICAgIFwiTFJJXCI6IFwiNmVlXCIsXG4gICAgICBcIlJMSVwiOiBcIjZlZlwiLFxuICAgICAgXCJGU0lcIjogXCI2ZWdcIixcbiAgICAgIFwiUERJXCI6IFwiNmVoXCJcbiAgICB9O1xuXG4gICAgdmFyIFRZUEVTID0ge307XG4gICAgdmFyIFRZUEVTX1RPX05BTUVTID0ge307XG4gICAgVFlQRVMuTCA9IDE7IC8vTCBpcyB0aGUgZGVmYXVsdFxuICAgIFRZUEVTX1RPX05BTUVTWzFdID0gJ0wnO1xuICAgIE9iamVjdC5rZXlzKERBVEEpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGkpIHtcbiAgICAgIFRZUEVTW3R5cGVdID0gMSA8PCAoaSArIDEpO1xuICAgICAgVFlQRVNfVE9fTkFNRVNbVFlQRVNbdHlwZV1dID0gdHlwZTtcbiAgICB9KTtcbiAgICBPYmplY3QuZnJlZXplKFRZUEVTKTtcblxuICAgIHZhciBJU09MQVRFX0lOSVRfVFlQRVMgPSBUWVBFUy5MUkkgfCBUWVBFUy5STEkgfCBUWVBFUy5GU0k7XG4gICAgdmFyIFNUUk9OR19UWVBFUyA9IFRZUEVTLkwgfCBUWVBFUy5SIHwgVFlQRVMuQUw7XG4gICAgdmFyIE5FVVRSQUxfSVNPTEFURV9UWVBFUyA9IFRZUEVTLkIgfCBUWVBFUy5TIHwgVFlQRVMuV1MgfCBUWVBFUy5PTiB8IFRZUEVTLkZTSSB8IFRZUEVTLkxSSSB8IFRZUEVTLlJMSSB8IFRZUEVTLlBESTtcbiAgICB2YXIgQk5fTElLRV9UWVBFUyA9IFRZUEVTLkJOIHwgVFlQRVMuUkxFIHwgVFlQRVMuTFJFIHwgVFlQRVMuUkxPIHwgVFlQRVMuTFJPIHwgVFlQRVMuUERGO1xuICAgIHZhciBUUkFJTElOR19UWVBFUyA9IFRZUEVTLlMgfCBUWVBFUy5XUyB8IFRZUEVTLkIgfCBJU09MQVRFX0lOSVRfVFlQRVMgfCBUWVBFUy5QREkgfCBCTl9MSUtFX1RZUEVTO1xuXG4gICAgdmFyIG1hcCA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBwYXJzZURhdGEgKCkge1xuICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgLy9jb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIHR5cGUgKSB7XG4gICAgICAgICAgaWYgKERBVEEuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Q29kZSA9IDA7XG4gICAgICAgICAgICBEQVRBW3R5cGVdLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIHJlZiA9IHJhbmdlLnNwbGl0KCcrJyk7XG4gICAgICAgICAgICAgIHZhciBza2lwID0gcmVmWzBdO1xuICAgICAgICAgICAgICB2YXIgc3RlcCA9IHJlZlsxXTtcbiAgICAgICAgICAgICAgc2tpcCA9IHBhcnNlSW50KHNraXAsIDM2KTtcbiAgICAgICAgICAgICAgc3RlcCA9IHN0ZXAgPyBwYXJzZUludChzdGVwLCAzNikgOiAwO1xuICAgICAgICAgICAgICBtYXAuc2V0KGxhc3RDb2RlICs9IHNraXAsIFRZUEVTW3R5cGVdKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KCsrbGFzdENvZGUsIFRZUEVTW3R5cGVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gREFUQSkgbG9vcCggdHlwZSApO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGBjaGFyIHR5cGVzIHBhcnNlZCBpbiAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnR9bXNgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEJpZGlDaGFyVHlwZSAoY2hhcikge1xuICAgICAgcGFyc2VEYXRhKCk7XG4gICAgICByZXR1cm4gbWFwLmdldChjaGFyLmNvZGVQb2ludEF0KDApKSB8fCBUWVBFUy5MXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QmlkaUNoYXJUeXBlTmFtZShjaGFyKSB7XG4gICAgICByZXR1cm4gVFlQRVNfVE9fTkFNRVNbZ2V0QmlkaUNoYXJUeXBlKGNoYXIpXVxuICAgIH1cblxuICAgIC8vIEJpZGkgYnJhY2tldCBwYWlycyBkYXRhLCBhdXRvIGdlbmVyYXRlZFxuICAgIHZhciBkYXRhJDEgPSB7XG4gICAgICBcInBhaXJzXCI6IFwiMTQ+MSwxZT4yLHU+Miwyd3Q+MSwxPjEsMWdlPjEsMXdwPjEsMWo+MSxmPjEsaG0+MSwxPjEsdT4xLHU2PjEsMT4xLCs1LDI4PjEsdz4xLDE+MSwrMyxiOD4xLDE+MSwrMywxPjMsLTE+LTEsMz4xLDE+MSwrMiwxcz4xLDE+MSx4PjEsdGg+MSwxPjEsKzIsZGI+MSwxPjEsKzMsMz4xLDE+MSwrMiwxNHFtPjEsMT4xLCsxLDRxPjEsMWU+Mix1PjIsMj4xLCsxXCIsXG4gICAgICBcImNhbm9uaWNhbFwiOiBcIjZmMT4tNmR4LDZkeT4tNmR4LDZlYz4tNmVkLDZlZT4tNmVkLDZ3dz4yamosLTJqaT4yamosMTRyND4tMWU3bCwxZTdtPi0xZTdsLDFlN20+LTFlNWMsMWU1ZD4tMWU1YiwxZTVjPi0xNHF4LDE0cXk+LTE0cXgsMTR2bj4tMWVjZywxZWNoPi0xZWNnLDFlZHU+LTFlY2csMWVjaT4tMWVjZywxZWRhPi0xZWNnLDFlY2k+LTFlY2csMWVjaT4tMTY4cSwxNjhyPi0xNjhxLDE2OHM+LTE0eWUsMTR5Zj4tMTR5ZVwiXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBzdHJpbmcgdGhhdCBob2xkcyBlbmNvZGVkIGNvZGVwb2ludCBtYXBwaW5ncywgZS5nLiBmb3IgYnJhY2tldCBwYWlycyBvclxuICAgICAqIG1pcnJvcmluZyBjaGFyYWN0ZXJzLCBhcyBlbmNvZGVkIGJ5IHNjcmlwdHMvZ2VuZXJhdGVCaWRpRGF0YS5qcy4gUmV0dXJucyBhbiBvYmplY3RcbiAgICAgKiBob2xkaW5nIHRoZSBgbWFwYCwgYW5kIG9wdGlvbmFsbHkgYSBgcmV2ZXJzZU1hcGAgaWYgYGluY2x1ZGVSZXZlcnNlOnRydWVgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGVkU3RyaW5nXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlUmV2ZXJzZSAtIHRydWUgaWYgeW91IHdhbnQgcmV2ZXJzZU1hcCBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7e21hcDogTWFwPG51bWJlciwgbnVtYmVyPiwgcmV2ZXJzZU1hcD86IE1hcDxudW1iZXIsIG51bWJlcj59fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyTWFwIChlbmNvZGVkU3RyaW5nLCBpbmNsdWRlUmV2ZXJzZSkge1xuICAgICAgdmFyIHJhZGl4ID0gMzY7XG4gICAgICB2YXIgbGFzdENvZGUgPSAwO1xuICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciByZXZlcnNlTWFwID0gaW5jbHVkZVJldmVyc2UgJiYgbmV3IE1hcCgpO1xuICAgICAgdmFyIHByZXZQYWlyO1xuICAgICAgZW5jb2RlZFN0cmluZy5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gdmlzaXQoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmluZGV4T2YoJysnKSAhPT0gLTEpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gK2VudHJ5OyBpLS07KSB7XG4gICAgICAgICAgICB2aXNpdChwcmV2UGFpcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZQYWlyID0gZW50cnk7XG4gICAgICAgICAgdmFyIHJlZiA9IGVudHJ5LnNwbGl0KCc+Jyk7XG4gICAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgICAgdmFyIGIgPSByZWZbMV07XG4gICAgICAgICAgYSA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGxhc3RDb2RlICs9IHBhcnNlSW50KGEsIHJhZGl4KSk7XG4gICAgICAgICAgYiA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGxhc3RDb2RlICs9IHBhcnNlSW50KGIsIHJhZGl4KSk7XG4gICAgICAgICAgbWFwLnNldChhLCBiKTtcbiAgICAgICAgICBpbmNsdWRlUmV2ZXJzZSAmJiByZXZlcnNlTWFwLnNldChiLCBhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBtYXA6IG1hcCwgcmV2ZXJzZU1hcDogcmV2ZXJzZU1hcCB9XG4gICAgfVxuXG4gICAgdmFyIG9wZW5Ub0Nsb3NlLCBjbG9zZVRvT3BlbiwgY2Fub25pY2FsO1xuXG4gICAgZnVuY3Rpb24gcGFyc2UkMSAoKSB7XG4gICAgICBpZiAoIW9wZW5Ub0Nsb3NlKSB7XG4gICAgICAgIC8vY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICB2YXIgcmVmID0gcGFyc2VDaGFyYWN0ZXJNYXAoZGF0YSQxLnBhaXJzLCB0cnVlKTtcbiAgICAgICAgdmFyIG1hcCA9IHJlZi5tYXA7XG4gICAgICAgIHZhciByZXZlcnNlTWFwID0gcmVmLnJldmVyc2VNYXA7XG4gICAgICAgIG9wZW5Ub0Nsb3NlID0gbWFwO1xuICAgICAgICBjbG9zZVRvT3BlbiA9IHJldmVyc2VNYXA7XG4gICAgICAgIGNhbm9uaWNhbCA9IHBhcnNlQ2hhcmFjdGVyTWFwKGRhdGEkMS5jYW5vbmljYWwsIGZhbHNlKS5tYXA7XG4gICAgICAgIC8vY29uc29sZS5sb2coYGJyYWNrZXRzIHBhcnNlZCBpbiAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnR9bXNgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0IChjaGFyKSB7XG4gICAgICBwYXJzZSQxKCk7XG4gICAgICByZXR1cm4gb3BlblRvQ2xvc2UuZ2V0KGNoYXIpIHx8IG51bGxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldCAoY2hhcikge1xuICAgICAgcGFyc2UkMSgpO1xuICAgICAgcmV0dXJuIGNsb3NlVG9PcGVuLmdldChjaGFyKSB8fCBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2Fub25pY2FsQnJhY2tldCAoY2hhcikge1xuICAgICAgcGFyc2UkMSgpO1xuICAgICAgcmV0dXJuIGNhbm9uaWNhbC5nZXQoY2hhcikgfHwgbnVsbFxuICAgIH1cblxuICAgIC8vIExvY2FsIHR5cGUgYWxpYXNlc1xuICAgIHZhciBUWVBFX0wgPSBUWVBFUy5MO1xuICAgIHZhciBUWVBFX1IgPSBUWVBFUy5SO1xuICAgIHZhciBUWVBFX0VOID0gVFlQRVMuRU47XG4gICAgdmFyIFRZUEVfRVMgPSBUWVBFUy5FUztcbiAgICB2YXIgVFlQRV9FVCA9IFRZUEVTLkVUO1xuICAgIHZhciBUWVBFX0FOID0gVFlQRVMuQU47XG4gICAgdmFyIFRZUEVfQ1MgPSBUWVBFUy5DUztcbiAgICB2YXIgVFlQRV9CID0gVFlQRVMuQjtcbiAgICB2YXIgVFlQRV9TID0gVFlQRVMuUztcbiAgICB2YXIgVFlQRV9PTiA9IFRZUEVTLk9OO1xuICAgIHZhciBUWVBFX0JOID0gVFlQRVMuQk47XG4gICAgdmFyIFRZUEVfTlNNID0gVFlQRVMuTlNNO1xuICAgIHZhciBUWVBFX0FMID0gVFlQRVMuQUw7XG4gICAgdmFyIFRZUEVfTFJPID0gVFlQRVMuTFJPO1xuICAgIHZhciBUWVBFX1JMTyA9IFRZUEVTLlJMTztcbiAgICB2YXIgVFlQRV9MUkUgPSBUWVBFUy5MUkU7XG4gICAgdmFyIFRZUEVfUkxFID0gVFlQRVMuUkxFO1xuICAgIHZhciBUWVBFX1BERiA9IFRZUEVTLlBERjtcbiAgICB2YXIgVFlQRV9MUkkgPSBUWVBFUy5MUkk7XG4gICAgdmFyIFRZUEVfUkxJID0gVFlQRVMuUkxJO1xuICAgIHZhciBUWVBFX0ZTSSA9IFRZUEVTLkZTSTtcbiAgICB2YXIgVFlQRV9QREkgPSBUWVBFUy5QREk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHRcbiAgICAgKiBAcHJvcGVydHkge3tzdGFydCwgZW5kLCBsZXZlbH1bXX0gcGFyYWdyYXBoc1xuICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gbGV2ZWxzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgdGhlIEJpZGlyZWN0aW9uYWwgQWxnb3JpdGhtIHRvIGEgc3RyaW5nLCByZXR1cm5pbmcgdGhlIHJlc29sdmVkIGVtYmVkZGluZyBsZXZlbHNcbiAgICAgKiBpbiBhIHNpbmdsZSBVaW50OEFycmF5IHBsdXMgYSBsaXN0IG9mIG9iamVjdHMgaG9sZGluZyBlYWNoIHBhcmFncmFwaCdzIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBhbmQgcmVzb2x2ZWRcbiAgICAgKiBiYXNlIGVtYmVkZGluZyBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgaW5wdXQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtcImx0clwifFwicnRsXCJ8XCJhdXRvXCJ9IFtiYXNlRGlyZWN0aW9uXSAtIFVzZSBcImx0clwiIG9yIFwicnRsXCIgdG8gZm9yY2UgYSBiYXNlIHBhcmFncmFwaCBkaXJlY3Rpb24sXG4gICAgICogICAgICAgIG90aGVyd2lzZSBhIGRpcmVjdGlvbiB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5IGZyb20gZWFjaCBwYXJhZ3JhcGgncyBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIHtHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RW1iZWRkaW5nTGV2ZWxzIChzdHJpbmcsIGJhc2VEaXJlY3Rpb24pIHtcbiAgICAgIHZhciBNQVhfREVQVEggPSAxMjU7XG5cbiAgICAgIC8vIFN0YXJ0IGJ5IG1hcHBpbmcgYWxsIGNoYXJhY3RlcnMgdG8gdGhlaXIgdW5pY29kZSB0eXBlLCBhcyBhIGJpdG1hc2sgaW50ZWdlclxuICAgICAgdmFyIGNoYXJUeXBlcyA9IG5ldyBVaW50MzJBcnJheShzdHJpbmcubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoYXJUeXBlc1tpXSA9IGdldEJpZGlDaGFyVHlwZShzdHJpbmdbaV0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhclR5cGVDb3VudHMgPSBuZXcgTWFwKCk7IC8vd2lsbCBiZSBjbGVhcmVkIGF0IHN0YXJ0IG9mIGVhY2ggcGFyYWdyYXBoXG4gICAgICBmdW5jdGlvbiBjaGFuZ2VDaGFyVHlwZShpLCB0eXBlKSB7XG4gICAgICAgIHZhciBvbGRUeXBlID0gY2hhclR5cGVzW2ldO1xuICAgICAgICBjaGFyVHlwZXNbaV0gPSB0eXBlO1xuICAgICAgICBjaGFyVHlwZUNvdW50cy5zZXQob2xkVHlwZSwgY2hhclR5cGVDb3VudHMuZ2V0KG9sZFR5cGUpIC0gMSk7XG4gICAgICAgIGlmIChvbGRUeXBlICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUywgY2hhclR5cGVDb3VudHMuZ2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUykgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBjaGFyVHlwZUNvdW50cy5zZXQodHlwZSwgKGNoYXJUeXBlQ291bnRzLmdldCh0eXBlKSB8fCAwKSArIDEpO1xuICAgICAgICBpZiAodHlwZSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICAgIGNoYXJUeXBlQ291bnRzLnNldChORVVUUkFMX0lTT0xBVEVfVFlQRVMsIChjaGFyVHlwZUNvdW50cy5nZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB8fCAwKSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlbWJlZExldmVscyA9IG5ldyBVaW50OEFycmF5KHN0cmluZy5sZW5ndGgpO1xuICAgICAgdmFyIGlzb2xhdGlvblBhaXJzID0gbmV3IE1hcCgpOyAvL2luaXQtPnBkaSBhbmQgcGRpLT5pbml0XG5cbiAgICAgIC8vID09PSAzLjMuMSBUaGUgUGFyYWdyYXBoIExldmVsID09PVxuICAgICAgLy8gMy4zLjEgUDE6IFNwbGl0IHRoZSB0ZXh0IGludG8gcGFyYWdyYXBoc1xuICAgICAgdmFyIHBhcmFncmFwaHMgPSBbXTsgLy8gW3tzdGFydCwgZW5kLCBsZXZlbH0sIC4uLl1cbiAgICAgIHZhciBwYXJhZ3JhcGggPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc3RyaW5nLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgaWYgKCFwYXJhZ3JhcGgpIHtcbiAgICAgICAgICBwYXJhZ3JhcGhzLnB1c2gocGFyYWdyYXBoID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGkkMSxcbiAgICAgICAgICAgIGVuZDogc3RyaW5nLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAvLyAzLjMuMSBQMi1QMzogRGV0ZXJtaW5lIHRoZSBwYXJhZ3JhcGggbGV2ZWxcbiAgICAgICAgICAgIGxldmVsOiBiYXNlRGlyZWN0aW9uID09PSAncnRsJyA/IDEgOiBiYXNlRGlyZWN0aW9uID09PSAnbHRyJyA/IDAgOiBkZXRlcm1pbmVBdXRvRW1iZWRMZXZlbChpJDEsIGZhbHNlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyVHlwZXNbaSQxXSAmIFRZUEVfQikge1xuICAgICAgICAgIHBhcmFncmFwaC5lbmQgPSBpJDE7XG4gICAgICAgICAgcGFyYWdyYXBoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgRk9STUFUVElOR19UWVBFUyA9IFRZUEVfUkxFIHwgVFlQRV9MUkUgfCBUWVBFX1JMTyB8IFRZUEVfTFJPIHwgSVNPTEFURV9JTklUX1RZUEVTIHwgVFlQRV9QREkgfCBUWVBFX1BERiB8IFRZUEVfQjtcbiAgICAgIHZhciBuZXh0RXZlbiA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuICsgKChuICYgMSkgPyAxIDogMik7IH07XG4gICAgICB2YXIgbmV4dE9kZCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuICsgKChuICYgMSkgPyAyIDogMSk7IH07XG5cbiAgICAgIC8vIEV2ZXJ5dGhpbmcgZnJvbSBoZXJlIG9uIHdpbGwgb3BlcmF0ZSBwZXIgcGFyYWdyYXBoLlxuICAgICAgZm9yICh2YXIgcGFyYUlkeCA9IDA7IHBhcmFJZHggPCBwYXJhZ3JhcGhzLmxlbmd0aDsgcGFyYUlkeCsrKSB7XG4gICAgICAgIHBhcmFncmFwaCA9IHBhcmFncmFwaHNbcGFyYUlkeF07XG4gICAgICAgIHZhciBzdGF0dXNTdGFjayA9IFt7XG4gICAgICAgICAgX2xldmVsOiBwYXJhZ3JhcGgubGV2ZWwsXG4gICAgICAgICAgX292ZXJyaWRlOiAwLCAvLzA9bmV1dHJhbCwgMT1MLCAyPVJcbiAgICAgICAgICBfaXNvbGF0ZTogMCAvL2Jvb2xcbiAgICAgICAgfV07XG4gICAgICAgIHZhciBzdGFja1RvcCA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgb3ZlcmZsb3dJc29sYXRlQ291bnQgPSAwO1xuICAgICAgICB2YXIgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA9IDA7XG4gICAgICAgIHZhciB2YWxpZElzb2xhdGVDb3VudCA9IDA7XG4gICAgICAgIGNoYXJUeXBlQ291bnRzLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gPT09IDMuMy4yIEV4cGxpY2l0IExldmVscyBhbmQgRGlyZWN0aW9ucyA9PT1cbiAgICAgICAgZm9yICh2YXIgaSQyID0gcGFyYWdyYXBoLnN0YXJ0OyBpJDIgPD0gcGFyYWdyYXBoLmVuZDsgaSQyKyspIHtcbiAgICAgICAgICB2YXIgY2hhclR5cGUgPSBjaGFyVHlwZXNbaSQyXTtcbiAgICAgICAgICBzdGFja1RvcCA9IHN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgLy8gU2V0IGluaXRpYWwgY291bnRzXG4gICAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KGNoYXJUeXBlLCAoY2hhclR5cGVDb3VudHMuZ2V0KGNoYXJUeXBlKSB8fCAwKSArIDEpO1xuICAgICAgICAgIGlmIChjaGFyVHlwZSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUywgKGNoYXJUeXBlQ291bnRzLmdldChORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHx8IDApICsgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXhwbGljaXQgRW1iZWRkaW5nczogMy4zLjIgWDIgLSBYM1xuICAgICAgICAgIGlmIChjaGFyVHlwZSAmIEZPUk1BVFRJTkdfVFlQRVMpIHsgLy9wcmVmaWx0ZXIgYWxsIGZvcm1hdHRlcnNcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZSAmIChUWVBFX1JMRSB8IFRZUEVfTFJFKSkge1xuICAgICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsOyAvLyA1LjJcbiAgICAgICAgICAgICAgdmFyIGxldmVsID0gKGNoYXJUeXBlID09PSBUWVBFX1JMRSA/IG5leHRPZGQgOiBuZXh0RXZlbikoc3RhY2tUb3AuX2xldmVsKTtcbiAgICAgICAgICAgICAgaWYgKGxldmVsIDw9IE1BWF9ERVBUSCAmJiAhb3ZlcmZsb3dJc29sYXRlQ291bnQgJiYgIW92ZXJmbG93RW1iZWRkaW5nQ291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIF9sZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgICBfb3ZlcnJpZGU6IDAsXG4gICAgICAgICAgICAgICAgICBfaXNvbGF0ZTogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFvdmVyZmxvd0lzb2xhdGVDb3VudCkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93RW1iZWRkaW5nQ291bnQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBPdmVycmlkZXM6IDMuMy4yIFg0IC0gWDVcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgKFRZUEVfUkxPIHwgVFlQRV9MUk8pKSB7XG4gICAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7IC8vIDUuMlxuICAgICAgICAgICAgICB2YXIgbGV2ZWwkMSA9IChjaGFyVHlwZSA9PT0gVFlQRV9STE8gPyBuZXh0T2RkIDogbmV4dEV2ZW4pKHN0YWNrVG9wLl9sZXZlbCk7XG4gICAgICAgICAgICAgIGlmIChsZXZlbCQxIDw9IE1BWF9ERVBUSCAmJiAhb3ZlcmZsb3dJc29sYXRlQ291bnQgJiYgIW92ZXJmbG93RW1iZWRkaW5nQ291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIF9sZXZlbDogbGV2ZWwkMSxcbiAgICAgICAgICAgICAgICAgIF9vdmVycmlkZTogKGNoYXJUeXBlICYgVFlQRV9STE8pID8gVFlQRV9SIDogVFlQRV9MLFxuICAgICAgICAgICAgICAgICAgX2lzb2xhdGU6IDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghb3ZlcmZsb3dJc29sYXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd0VtYmVkZGluZ0NvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSXNvbGF0ZXM6IDMuMy4yIFg1YSAtIFg1Y1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBJU09MQVRFX0lOSVRfVFlQRVMpIHtcbiAgICAgICAgICAgICAgLy8gWDVjIC0gRlNJIGJlY29tZXMgZWl0aGVyIFJMSSBvciBMUklcbiAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlICYgVFlQRV9GU0kpIHtcbiAgICAgICAgICAgICAgICBjaGFyVHlwZSA9IGRldGVybWluZUF1dG9FbWJlZExldmVsKGkkMiArIDEsIHRydWUpID09PSAxID8gVFlQRV9STEkgOiBUWVBFX0xSSTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChzdGFja1RvcC5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDIsIHN0YWNrVG9wLl9vdmVycmlkZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGxldmVsJDIgPSAoY2hhclR5cGUgPT09IFRZUEVfUkxJID8gbmV4dE9kZCA6IG5leHRFdmVuKShzdGFja1RvcC5fbGV2ZWwpO1xuICAgICAgICAgICAgICBpZiAobGV2ZWwkMiA8PSBNQVhfREVQVEggJiYgb3ZlcmZsb3dJc29sYXRlQ291bnQgPT09IDAgJiYgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbGlkSXNvbGF0ZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICBfbGV2ZWw6IGxldmVsJDIsXG4gICAgICAgICAgICAgICAgICBfb3ZlcnJpZGU6IDAsXG4gICAgICAgICAgICAgICAgICBfaXNvbGF0ZTogMSxcbiAgICAgICAgICAgICAgICAgIF9pc29sSW5pdEluZGV4OiBpJDJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd0lzb2xhdGVDb3VudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRlcm1pbmF0aW5nIElzb2xhdGVzOiAzLjMuMiBYNmFcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgVFlQRV9QREkpIHtcbiAgICAgICAgICAgICAgaWYgKG92ZXJmbG93SXNvbGF0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93SXNvbGF0ZUNvdW50LS07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsaWRJc29sYXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXS5faXNvbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBpc29sYXRpb24gcGFpcnMgYmlkaXJlY3Rpb25hbCBtYXBwaW5nOlxuICAgICAgICAgICAgICAgIHZhciBpc29sSW5pdEluZGV4ID0gc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV0uX2lzb2xJbml0SW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGlzb2xJbml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaXNvbGF0aW9uUGFpcnMuc2V0KGlzb2xJbml0SW5kZXgsIGkkMik7XG4gICAgICAgICAgICAgICAgICBpc29sYXRpb25QYWlycy5zZXQoaSQyLCBpc29sSW5pdEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdmFsaWRJc29sYXRlQ291bnQtLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGFja1RvcCA9IHN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsO1xuICAgICAgICAgICAgICBpZiAoc3RhY2tUb3AuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQyLCBzdGFja1RvcC5fb3ZlcnJpZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gVGVybWluYXRpbmcgRW1iZWRkaW5ncyBhbmQgT3ZlcnJpZGVzOiAzLjMuMiBYN1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBUWVBFX1BERikge1xuICAgICAgICAgICAgICBpZiAob3ZlcmZsb3dJc29sYXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG92ZXJmbG93RW1iZWRkaW5nQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFzdGFja1RvcC5faXNvbGF0ZSAmJiBzdGF0dXNTdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIHN0YWNrVG9wID0gc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7IC8vIDUuMlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbmQgb2YgUGFyYWdyYXBoOiAzLjMuMiBYOFxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBUWVBFX0IpIHtcbiAgICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOb24tZm9ybWF0dGluZyBjaGFyYWN0ZXJzOiAzLjMuMiBYNlxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDtcbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgZXhjbHVzaW9uIG9mIEJOIHNlZW1zIHRvIGdvIGFnYWluc3Qgd2hhdCBzZWN0aW9uIDUuMiBzYXlzLCBidXQgaXMgcmVxdWlyZWQgZm9yIHRlc3QgcGFzc2FnZVxuICAgICAgICAgICAgaWYgKHN0YWNrVG9wLl9vdmVycmlkZSAmJiBjaGFyVHlwZSAhPT0gVFlQRV9CTikge1xuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDIsIHN0YWNrVG9wLl9vdmVycmlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gPT09IDMuMy4zIFByZXBhcmF0aW9ucyBmb3IgSW1wbGljaXQgUHJvY2Vzc2luZyA9PT1cblxuICAgICAgICAvLyBSZW1vdmUgYWxsIFJMRSwgTFJFLCBSTE8sIExSTywgUERGLCBhbmQgQk4gY2hhcmFjdGVyczogMy4zLjMgWDlcbiAgICAgICAgLy8gTm90ZTogRHVlIHRvIHNlY3Rpb24gNS4yLCB3ZSB3b24ndCByZW1vdmUgdGhlbSwgYnV0IHdlJ2xsIHVzZSB0aGUgQk5fTElLRV9UWVBFUyBiaXRzZXQgdG9cbiAgICAgICAgLy8gZWFzaWx5IGlnbm9yZSB0aGVtIGFsbCBmcm9tIGhlcmUgb24gb3V0LlxuXG4gICAgICAgIC8vIDMuMy4zIFgxMFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBzZXQgb2YgaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZXMgYXMgc3BlY2lmaWVkIGJ5IEJEMTNcbiAgICAgICAgdmFyIGxldmVsUnVucyA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudFJ1biA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkkMyA9IHBhcmFncmFwaC5zdGFydDsgaSQzIDw9IHBhcmFncmFwaC5lbmQ7IGkkMysrKSB7XG4gICAgICAgICAgdmFyIGNoYXJUeXBlJDEgPSBjaGFyVHlwZXNbaSQzXTtcbiAgICAgICAgICBpZiAoIShjaGFyVHlwZSQxICYgQk5fTElLRV9UWVBFUykpIHtcbiAgICAgICAgICAgIHZhciBsdmwgPSBlbWJlZExldmVsc1tpJDNdO1xuICAgICAgICAgICAgdmFyIGlzSXNvbEluaXQgPSBjaGFyVHlwZSQxICYgSVNPTEFURV9JTklUX1RZUEVTO1xuICAgICAgICAgICAgdmFyIGlzUERJID0gY2hhclR5cGUkMSA9PT0gVFlQRV9QREk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFJ1biAmJiBsdmwgPT09IGN1cnJlbnRSdW4uX2xldmVsKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRSdW4uX2VuZCA9IGkkMztcbiAgICAgICAgICAgICAgY3VycmVudFJ1bi5fZW5kc1dpdGhJc29sSW5pdCA9IGlzSXNvbEluaXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXZlbFJ1bnMucHVzaChjdXJyZW50UnVuID0ge1xuICAgICAgICAgICAgICAgIF9zdGFydDogaSQzLFxuICAgICAgICAgICAgICAgIF9lbmQ6IGkkMyxcbiAgICAgICAgICAgICAgICBfbGV2ZWw6IGx2bCxcbiAgICAgICAgICAgICAgICBfc3RhcnRzV2l0aFBESTogaXNQREksXG4gICAgICAgICAgICAgICAgX2VuZHNXaXRoSXNvbEluaXQ6IGlzSXNvbEluaXRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpc29sYXRpbmdSdW5TZXFzID0gW107IC8vIFt7c2VxSW5kaWNlczogW10sIHNvc1R5cGU6IEx8UiwgZW9zVHlwZTogTHxSfV1cbiAgICAgICAgZm9yICh2YXIgcnVuSWR4ID0gMDsgcnVuSWR4IDwgbGV2ZWxSdW5zLmxlbmd0aDsgcnVuSWR4KyspIHtcbiAgICAgICAgICB2YXIgcnVuID0gbGV2ZWxSdW5zW3J1bklkeF07XG4gICAgICAgICAgaWYgKCFydW4uX3N0YXJ0c1dpdGhQREkgfHwgKHJ1bi5fc3RhcnRzV2l0aFBESSAmJiAhaXNvbGF0aW9uUGFpcnMuaGFzKHJ1bi5fc3RhcnQpKSkge1xuICAgICAgICAgICAgdmFyIHNlcVJ1bnMgPSBbY3VycmVudFJ1biA9IHJ1bl07XG4gICAgICAgICAgICBmb3IgKHZhciBwZGlJbmRleCA9ICh2b2lkIDApOyBjdXJyZW50UnVuICYmIGN1cnJlbnRSdW4uX2VuZHNXaXRoSXNvbEluaXQgJiYgKHBkaUluZGV4ID0gaXNvbGF0aW9uUGFpcnMuZ2V0KGN1cnJlbnRSdW4uX2VuZCkpICE9IG51bGw7KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkNCA9IHJ1bklkeCArIDE7IGkkNCA8IGxldmVsUnVucy5sZW5ndGg7IGkkNCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsUnVuc1tpJDRdLl9zdGFydCA9PT0gcGRpSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHNlcVJ1bnMucHVzaChjdXJyZW50UnVuID0gbGV2ZWxSdW5zW2kkNF0pO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJ1aWxkIGZsYXQgbGlzdCBvZiBpbmRpY2VzIGFjcm9zcyBhbGwgcnVuczpcbiAgICAgICAgICAgIHZhciBzZXFJbmRpY2VzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBzZXFSdW5zLmxlbmd0aDsgaSQ1KyspIHtcbiAgICAgICAgICAgICAgdmFyIHJ1biQxID0gc2VxUnVuc1tpJDVdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gcnVuJDEuX3N0YXJ0OyBqIDw9IHJ1biQxLl9lbmQ7IGorKykge1xuICAgICAgICAgICAgICAgIHNlcUluZGljZXMucHVzaChqKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzb3MvZW9zIHR5cGVzOlxuICAgICAgICAgICAgdmFyIGZpcnN0TGV2ZWwgPSBlbWJlZExldmVsc1tzZXFJbmRpY2VzWzBdXTtcbiAgICAgICAgICAgIHZhciBwcmV2TGV2ZWwgPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDYgPSBzZXFJbmRpY2VzWzBdIC0gMTsgaSQ2ID49IDA7IGkkNi0tKSB7XG4gICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tpJDZdICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjJcbiAgICAgICAgICAgICAgICBwcmV2TGV2ZWwgPSBlbWJlZExldmVsc1tpJDZdO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBzZXFJbmRpY2VzW3NlcUluZGljZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgbGFzdExldmVsID0gZW1iZWRMZXZlbHNbbGFzdEluZGV4XTtcbiAgICAgICAgICAgIHZhciBuZXh0TGV2ZWwgPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbbGFzdEluZGV4XSAmIElTT0xBVEVfSU5JVF9UWVBFUykpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQ3ID0gbGFzdEluZGV4ICsgMTsgaSQ3IDw9IHBhcmFncmFwaC5lbmQ7IGkkNysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW2kkN10gJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMlxuICAgICAgICAgICAgICAgICAgbmV4dExldmVsID0gZW1iZWRMZXZlbHNbaSQ3XTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc29sYXRpbmdSdW5TZXFzLnB1c2goe1xuICAgICAgICAgICAgICBfc2VxSW5kaWNlczogc2VxSW5kaWNlcyxcbiAgICAgICAgICAgICAgX3Nvc1R5cGU6IE1hdGgubWF4KHByZXZMZXZlbCwgZmlyc3RMZXZlbCkgJSAyID8gVFlQRV9SIDogVFlQRV9MLFxuICAgICAgICAgICAgICBfZW9zVHlwZTogTWF0aC5tYXgobmV4dExldmVsLCBsYXN0TGV2ZWwpICUgMiA/IFRZUEVfUiA6IFRZUEVfTFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG5leHQgc3RlcHMgYXJlIGRvbmUgcGVyIGlzb2xhdGluZyBydW4gc2VxdWVuY2VcbiAgICAgICAgZm9yICh2YXIgc2VxSWR4ID0gMDsgc2VxSWR4IDwgaXNvbGF0aW5nUnVuU2Vxcy5sZW5ndGg7IHNlcUlkeCsrKSB7XG4gICAgICAgICAgdmFyIHJlZiA9IGlzb2xhdGluZ1J1blNlcXNbc2VxSWR4XTtcbiAgICAgICAgICB2YXIgc2VxSW5kaWNlcyQxID0gcmVmLl9zZXFJbmRpY2VzO1xuICAgICAgICAgIHZhciBzb3NUeXBlID0gcmVmLl9zb3NUeXBlO1xuICAgICAgICAgIHZhciBlb3NUeXBlID0gcmVmLl9lb3NUeXBlO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEFsbCB0aGUgbGV2ZWwgcnVucyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlIGhhdmUgdGhlIHNhbWUgZW1iZWRkaW5nIGxldmVsLlxuICAgICAgICAgICAqIFxuICAgICAgICAgICAqIERPIE5PVCBjaGFuZ2UgYW55IGBlbWJlZExldmVsc1tpXWAgd2l0aGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBlbWJlZERpcmVjdGlvbiA9ICgoZW1iZWRMZXZlbHNbc2VxSW5kaWNlcyQxWzBdXSkgJiAxKSA/IFRZUEVfUiA6IFRZUEVfTDtcblxuICAgICAgICAgIC8vID09PSAzLjMuNCBSZXNvbHZpbmcgV2VhayBUeXBlcyA9PT1cblxuICAgICAgICAgIC8vIFcxICsgNS4yLiBTZWFyY2ggYmFja3dhcmQgZnJvbSBlYWNoIE5TTSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBpc29sYXRpbmcgcnVuIHNlcXVlbmNlIHdob3NlXG4gICAgICAgICAgLy8gYmlkaXJlY3Rpb25hbCB0eXBlIGlzIG5vdCBCTiwgYW5kIHNldCB0aGUgTlNNIHRvIE9OIGlmIGl0IGlzIGFuIGlzb2xhdGUgaW5pdGlhdG9yIG9yIFBESSwgYW5kIHRvIGl0c1xuICAgICAgICAgIC8vIHR5cGUgb3RoZXJ3aXNlLiBJZiB0aGUgTlNNIGlzIHRoZSBmaXJzdCBub24tQk4gY2hhcmFjdGVyLCBjaGFuZ2UgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiBzb3MuXG4gICAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX05TTSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBpJDggPSBzZXFJbmRpY2VzJDFbc2ldO1xuICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkOF0gJiBUWVBFX05TTSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VHlwZSA9IHNvc1R5cGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2ogPSBzaSAtIDE7IHNqID49IDA7IHNqLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2pdXSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yIHNjYW4gYmFjayB0byBmaXJzdCBub24tQk5cbiAgICAgICAgICAgICAgICAgICAgcHJldlR5cGUgPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqXV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkOCwgKHByZXZUeXBlICYgKElTT0xBVEVfSU5JVF9UWVBFUyB8IFRZUEVfUERJKSkgPyBUWVBFX09OIDogcHJldlR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVzIuIFNlYXJjaCBiYWNrd2FyZCBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXIgdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29zKVxuICAgICAgICAgIC8vIGlzIGZvdW5kLiBJZiBhbiBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljIG51bWJlci5cbiAgICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRU4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzaSQxID0gMDsgc2kkMSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDErKykge1xuICAgICAgICAgICAgICB2YXIgaSQ5ID0gc2VxSW5kaWNlcyQxW3NpJDFdO1xuICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkOV0gJiBUWVBFX0VOKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2okMSA9IHNpJDEgLSAxOyBzaiQxID49IC0xOyBzaiQxLS0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcmV2Q2hhclR5cGUgPSBzaiQxID09PSAtMSA/IHNvc1R5cGUgOiBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDFdXTtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hhclR5cGUgJiBTVFJPTkdfVFlQRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDaGFyVHlwZSA9PT0gVFlQRV9BTCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkOSwgVFlQRV9BTik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUlxuICAgICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9BTCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNpJDIgPSAwOyBzaSQyIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMisrKSB7XG4gICAgICAgICAgICAgIHZhciBpJDEwID0gc2VxSW5kaWNlcyQxW3NpJDJdO1xuICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTBdICYgVFlQRV9BTCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMTAsIFRZUEVfUik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXNC4gQSBzaW5nbGUgRXVyb3BlYW4gc2VwYXJhdG9yIGJldHdlZW4gdHdvIEV1cm9wZWFuIG51bWJlcnMgY2hhbmdlcyB0byBhIEV1cm9wZWFuIG51bWJlci4gQSBzaW5nbGUgY29tbW9uXG4gICAgICAgICAgLy8gc2VwYXJhdG9yIGJldHdlZW4gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cbiAgICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRVMpIHx8IGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0NTKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgc2kkMyA9IDE7IHNpJDMgPCBzZXFJbmRpY2VzJDEubGVuZ3RoIC0gMTsgc2kkMysrKSB7XG4gICAgICAgICAgICAgIHZhciBpJDExID0gc2VxSW5kaWNlcyQxW3NpJDNdO1xuICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTFdICYgKFRZUEVfRVMgfCBUWVBFX0NTKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VHlwZSQxID0gMCwgbmV4dFR5cGUgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNqJDIgPSBzaSQzIC0gMTsgc2okMiA+PSAwOyBzaiQyLS0pIHtcbiAgICAgICAgICAgICAgICAgIHByZXZUeXBlJDEgPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDJdXTtcbiAgICAgICAgICAgICAgICAgIGlmICghKHByZXZUeXBlJDEgJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMlxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaiQzID0gc2kkMyArIDE7IHNqJDMgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaiQzKyspIHtcbiAgICAgICAgICAgICAgICAgIG5leHRUeXBlID0gY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQzXV07XG4gICAgICAgICAgICAgICAgICBpZiAoIShuZXh0VHlwZSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2VHlwZSQxID09PSBuZXh0VHlwZSAmJiAoY2hhclR5cGVzW2kkMTFdID09PSBUWVBFX0VTID8gcHJldlR5cGUkMSA9PT0gVFlQRV9FTiA6IChwcmV2VHlwZSQxICYgKFRZUEVfRU4gfCBUWVBFX0FOKSkpKSB7XG4gICAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDExLCBwcmV2VHlwZSQxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhbiBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VOKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgc2kkNCA9IDA7IHNpJDQgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQ0KyspIHtcbiAgICAgICAgICAgICAgdmFyIGkkMTIgPSBzZXFJbmRpY2VzJDFbc2kkNF07XG4gICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxMl0gJiBUWVBFX0VOKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2okNCA9IHNpJDQgLSAxOyBzaiQ0ID49IDAgJiYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okNF1dICYgKFRZUEVfRVQgfCBCTl9MSUtFX1RZUEVTKSk7IHNqJDQtLSkge1xuICAgICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NqJDRdLCBUWVBFX0VOKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChzaSQ0Kys7IHNpJDQgPCBzZXFJbmRpY2VzJDEubGVuZ3RoICYmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDRdXSAmIChUWVBFX0VUIHwgQk5fTElLRV9UWVBFUyB8IFRZUEVfRU4pKTsgc2kkNCsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQ0XV0gIT09IFRZUEVfRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NpJDRdLCBUWVBFX0VOKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXIgTmV1dHJhbC5cbiAgICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRVQpIHx8IGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VTKSB8fCBjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9DUykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNpJDUgPSAwOyBzaSQ1IDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkNSsrKSB7XG4gICAgICAgICAgICAgIHZhciBpJDEzID0gc2VxSW5kaWNlcyQxW3NpJDVdO1xuICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTNdICYgKFRZUEVfRVQgfCBUWVBFX0VTIHwgVFlQRV9DUykpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDEzLCBUWVBFX09OKTtcbiAgICAgICAgICAgICAgICAvLyA1LjIgdHJhbnNmb3JtIGFkamFjZW50IEJOcyB0b286XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2okNSA9IHNpJDUgLSAxOyBzaiQ1ID49IDAgJiYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okNV1dICYgQk5fTElLRV9UWVBFUyk7IHNqJDUtLSkge1xuICAgICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NqJDVdLCBUWVBFX09OKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2okNiA9IHNpJDUgKyAxOyBzaiQ2IDwgc2VxSW5kaWNlcyQxLmxlbmd0aCAmJiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQ2XV0gJiBCTl9MSUtFX1RZUEVTKTsgc2okNisrKSB7XG4gICAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShzZXFJbmRpY2VzJDFbc2okNl0sIFRZUEVfT04pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmQgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29zKVxuICAgICAgICAgIC8vIGlzIGZvdW5kLiBJZiBhbiBMIGlzIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICAgICAgLy8gTk9URTogaW1wbGVtZW50ZWQgaW4gc2luZ2xlIGZvcndhcmQgcGFzcyBmb3IgZWZmaWNpZW5jeVxuICAgICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FTikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNpJDYgPSAwLCBwcmV2U3Ryb25nVHlwZSA9IHNvc1R5cGU7IHNpJDYgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQ2KyspIHtcbiAgICAgICAgICAgICAgdmFyIGkkMTQgPSBzZXFJbmRpY2VzJDFbc2kkNl07XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gY2hhclR5cGVzW2kkMTRdO1xuICAgICAgICAgICAgICBpZiAodHlwZSAmIFRZUEVfRU4pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlN0cm9uZ1R5cGUgPT09IFRZUEVfTCkge1xuICAgICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQxNCwgVFlQRV9MKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAmIFNUUk9OR19UWVBFUykge1xuICAgICAgICAgICAgICAgIHByZXZTdHJvbmdUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vID09PSAzLjMuNSBSZXNvbHZpbmcgTmV1dHJhbCBhbmQgSXNvbGF0ZSBGb3JtYXR0aW5nIFR5cGVzID09PVxuXG4gICAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChORVVUUkFMX0lTT0xBVEVfVFlQRVMpKSB7XG4gICAgICAgICAgICAvLyBOMC4gUHJvY2VzcyBicmFja2V0IHBhaXJzIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2Ugc2VxdWVudGlhbGx5IGluIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSB0ZXh0XG4gICAgICAgICAgICAvLyBwb3NpdGlvbnMgb2YgdGhlIG9wZW5pbmcgcGFpcmVkIGJyYWNrZXRzIHVzaW5nIHRoZSBsb2dpYyBnaXZlbiBiZWxvdy4gV2l0aGluIHRoaXMgc2NvcGUsIGJpZGlyZWN0aW9uYWxcbiAgICAgICAgICAgIC8vIHR5cGVzIEVOIGFuZCBBTiBhcmUgdHJlYXRlZCBhcyBSLlxuICAgICAgICAgICAgdmFyIFJfVFlQRVNfRk9SX05fU1RFUFMgPSAoVFlQRV9SIHwgVFlQRV9FTiB8IFRZUEVfQU4pO1xuICAgICAgICAgICAgdmFyIFNUUk9OR19UWVBFU19GT1JfTl9TVEVQUyA9IFJfVFlQRVNfRk9SX05fU1RFUFMgfCBUWVBFX0w7XG5cbiAgICAgICAgICAgIC8vICogSWRlbnRpZnkgdGhlIGJyYWNrZXQgcGFpcnMgaW4gdGhlIGN1cnJlbnQgaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZSBhY2NvcmRpbmcgdG8gQkQxNi5cbiAgICAgICAgICAgIHZhciBicmFja2V0UGFpcnMgPSBbXTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIG9wZW5lclN0YWNrID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIHNpJDcgPSAwOyBzaSQ3IDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkNysrKSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URTogZm9yIGFueSBwb3RlbnRpYWwgYnJhY2tldCBjaGFyYWN0ZXIgd2UgYWxzbyB0ZXN0IHRoYXQgaXQgc3RpbGwgY2FycmllcyBhIE5JXG4gICAgICAgICAgICAgICAgLy8gdHlwZSwgYXMgdGhhdCBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgZWFybGllci4gVGhpcyBkb2Vzbid0IHNlZW0gdG8gYmUgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBvdXQgaW4gdGhlIHNwZWMsIGJ1dCBpcyByZXF1aXJlZCBmb3IgcGFzc2FnZSBvZiBjZXJ0YWluIHRlc3RzLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDddXSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBzdHJpbmdbc2VxSW5kaWNlcyQxW3NpJDddXTtcbiAgICAgICAgICAgICAgICAgIHZhciBvcHBvc2l0ZUJyYWNrZXQgPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgIC8vIE9wZW5pbmcgYnJhY2tldFxuICAgICAgICAgICAgICAgICAgaWYgKG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0KGNoYXIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXJTdGFjay5sZW5ndGggPCA2Mykge1xuICAgICAgICAgICAgICAgICAgICAgIG9wZW5lclN0YWNrLnB1c2goeyBjaGFyOiBjaGFyLCBzZXFJbmRleDogc2kkNyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChvcHBvc2l0ZUJyYWNrZXQgPSBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldChjaGFyKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3RhY2tJZHggPSBvcGVuZXJTdGFjay5sZW5ndGggLSAxOyBzdGFja0lkeCA+PSAwOyBzdGFja0lkeC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrQ2hhciA9IG9wZW5lclN0YWNrW3N0YWNrSWR4XS5jaGFyO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja0NoYXIgPT09IG9wcG9zaXRlQnJhY2tldCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tDaGFyID09PSBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldChnZXRDYW5vbmljYWxCcmFja2V0KGNoYXIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQoZ2V0Q2Fub25pY2FsQnJhY2tldChzdGFja0NoYXIpKSA9PT0gY2hhclxuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2tldFBhaXJzLnB1c2goW29wZW5lclN0YWNrW3N0YWNrSWR4XS5zZXFJbmRleCwgc2kkN10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyU3RhY2subGVuZ3RoID0gc3RhY2tJZHg7IC8vcG9wIHRoZSBtYXRjaGluZyBicmFja2V0IGFuZCBhbGwgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmFja2V0UGFpcnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gKiBGb3IgZWFjaCBicmFja2V0LXBhaXIgZWxlbWVudCBpbiB0aGUgbGlzdCBvZiBwYWlycyBvZiB0ZXh0IHBvc2l0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgcGFpcklkeCA9IDA7IHBhaXJJZHggPCBicmFja2V0UGFpcnMubGVuZ3RoOyBwYWlySWR4KyspIHtcbiAgICAgICAgICAgICAgdmFyIHJlZiQxID0gYnJhY2tldFBhaXJzW3BhaXJJZHhdO1xuICAgICAgICAgICAgICB2YXIgb3BlblNlcUlkeCA9IHJlZiQxWzBdO1xuICAgICAgICAgICAgICB2YXIgY2xvc2VTZXFJZHggPSByZWYkMVsxXTtcbiAgICAgICAgICAgICAgLy8gYS4gSW5zcGVjdCB0aGUgYmlkaXJlY3Rpb25hbCB0eXBlcyBvZiB0aGUgY2hhcmFjdGVycyBlbmNsb3NlZCB3aXRoaW4gdGhlIGJyYWNrZXQgcGFpci5cbiAgICAgICAgICAgICAgLy8gYi4gSWYgYW55IHN0cm9uZyB0eXBlIChlaXRoZXIgTCBvciBSKSBtYXRjaGluZyB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbiBpcyBmb3VuZCwgc2V0IHRoZSB0eXBlIGZvciBib3RoXG4gICAgICAgICAgICAgIC8vIGJyYWNrZXRzIGluIHRoZSBwYWlyIHRvIG1hdGNoIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICB2YXIgZm91bmRTdHJvbmdUeXBlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciB1c2VTdHJvbmdUeXBlID0gMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2kkOCA9IG9wZW5TZXFJZHggKyAxOyBzaSQ4IDwgY2xvc2VTZXFJZHg7IHNpJDgrKykge1xuICAgICAgICAgICAgICAgIHZhciBpJDE1ID0gc2VxSW5kaWNlcyQxW3NpJDhdO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxNV0gJiBTVFJPTkdfVFlQRVNfRk9SX05fU1RFUFMpIHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kU3Ryb25nVHlwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbHIgPSAoY2hhclR5cGVzW2kkMTVdICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0w7XG4gICAgICAgICAgICAgICAgICBpZiAobHIgPT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZVN0cm9uZ1R5cGUgPSBscjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYy4gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBhIHN0cm9uZyB0eXBlIGl0IG11c3QgYmUgb3Bwb3NpdGUgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uIFRoZXJlZm9yZSwgdGVzdFxuICAgICAgICAgICAgICAvLyBmb3IgYW4gZXN0YWJsaXNoZWQgY29udGV4dCB3aXRoIGEgcHJlY2VkaW5nIHN0cm9uZyB0eXBlIGJ5IGNoZWNraW5nIGJhY2t3YXJkcyBiZWZvcmUgdGhlIG9wZW5pbmcgcGFpcmVkXG4gICAgICAgICAgICAgIC8vIGJyYWNrZXQgdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChMLCBSLCBvciBzb3MpIGlzIGZvdW5kLlxuICAgICAgICAgICAgICAvLyAgICAxLiBJZiB0aGUgcHJlY2VkaW5nIHN0cm9uZyB0eXBlIGlzIGFsc28gb3Bwb3NpdGUgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24sIGNvbnRleHQgaXMgZXN0YWJsaXNoZWQsIHNvXG4gICAgICAgICAgICAgIC8vICAgIHNldCB0aGUgdHlwZSBmb3IgYm90aCBicmFja2V0cyBpbiB0aGUgcGFpciB0byB0aGF0IGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAgLy8gICAgMi4gT3RoZXJ3aXNlIHNldCB0aGUgdHlwZSBmb3IgYm90aCBicmFja2V0cyBpbiB0aGUgcGFpciB0byB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAgaWYgKGZvdW5kU3Ryb25nVHlwZSAmJiAhdXNlU3Ryb25nVHlwZSkge1xuICAgICAgICAgICAgICAgIHVzZVN0cm9uZ1R5cGUgPSBzb3NUeXBlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpJDkgPSBvcGVuU2VxSWR4IC0gMTsgc2kkOSA+PSAwOyBzaSQ5LS0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpJDE2ID0gc2VxSW5kaWNlcyQxW3NpJDldO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDE2XSAmIFNUUk9OR19UWVBFU19GT1JfTl9TVEVQUykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbHIkMSA9IChjaGFyVHlwZXNbaSQxNl0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxyJDEgIT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdXNlU3Ryb25nVHlwZSA9IGxyJDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdXNlU3Ryb25nVHlwZSA9IGVtYmVkRGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh1c2VTdHJvbmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2hhclR5cGVzW3NlcUluZGljZXMkMVtvcGVuU2VxSWR4XV0gPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW2Nsb3NlU2VxSWR4XV0gPSB1c2VTdHJvbmdUeXBlO1xuICAgICAgICAgICAgICAgIC8vICogQW55IG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgaGFkIG9yaWdpbmFsIGJpZGlyZWN0aW9uYWwgY2hhcmFjdGVyIHR5cGUgTlNNIHByaW9yIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICAgICAgICAgIC8vIG9mIFcxIHRoYXQgaW1tZWRpYXRlbHkgZm9sbG93IGEgcGFpcmVkIGJyYWNrZXQgd2hpY2ggY2hhbmdlZCB0byBMIG9yIFIgdW5kZXIgTjAgc2hvdWxkIGNoYW5nZSB0byBtYXRjaFxuICAgICAgICAgICAgICAgIC8vIHRoZSB0eXBlIG9mIHRoZWlyIHByZWNlZGluZyBicmFja2V0LlxuICAgICAgICAgICAgICAgIGlmICh1c2VTdHJvbmdUeXBlICE9PSBlbWJlZERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc2kkMTAgPSBvcGVuU2VxSWR4ICsgMTsgc2kkMTAgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxMCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTBdXSAmIEJOX0xJS0VfVFlQRVMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGdldEJpZGlDaGFyVHlwZShzdHJpbmdbc2VxSW5kaWNlcyQxW3NpJDEwXV0pICYgVFlQRV9OU00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTBdXSA9IHVzZVN0cm9uZ1R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0cm9uZ1R5cGUgIT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSQxMSA9IGNsb3NlU2VxSWR4ICsgMTsgc2kkMTEgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTFdXSAmIEJOX0xJS0VfVFlQRVMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGdldEJpZGlDaGFyVHlwZShzdHJpbmdbc2VxSW5kaWNlcyQxW3NpJDExXV0pICYgVFlQRV9OU00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTFdXSA9IHVzZVN0cm9uZ1R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgTklzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHN1cnJvdW5kaW5nIHN0cm9uZyB0ZXh0IGlmIHRoZSB0ZXh0IG9uIGJvdGggc2lkZXMgaGFzIHRoZVxuICAgICAgICAgICAgLy8gc2FtZSBkaXJlY3Rpb24uXG4gICAgICAgICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBOSXMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgICAgIGZvciAodmFyIHNpJDEyID0gMDsgc2kkMTIgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxMisrKSB7XG4gICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDEyXV0gJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmlSdW5TdGFydCA9IHNpJDEyLCBuaVJ1bkVuZCA9IHNpJDEyO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VHlwZSQyID0gc29zVHlwZTsgLy9zaSA9PT0gMCA/IHNvc1R5cGUgOiAoY2hhclR5cGVzW3NlcUluZGljZXNbc2kgLSAxXV0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTFxuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpMiA9IHNpJDEyIC0gMTsgc2kyID49IDA7IHNpMi0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaTJdXSAmIEJOX0xJS0VfVFlQRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmlSdW5TdGFydCA9IHNpMjsgLy81LjIgdHJlYXQgQk5zIGFkamFjZW50IHRvIE5JcyBhcyBOSXNcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZUeXBlJDIgPSAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaTJdXSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV4dFR5cGUkMSA9IGVvc1R5cGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kyJDEgPSBzaSQxMiArIDE7IHNpMiQxIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kyJDErKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kyJDFdXSAmIChORVVUUkFMX0lTT0xBVEVfVFlQRVMgfCBCTl9MSUtFX1RZUEVTKSkge1xuICAgICAgICAgICAgICAgICAgICBuaVJ1bkVuZCA9IHNpMiQxO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFR5cGUkMSA9IChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpMiQxXV0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2okNyA9IG5pUnVuU3RhcnQ7IHNqJDcgPD0gbmlSdW5FbmQ7IHNqJDcrKykge1xuICAgICAgICAgICAgICAgICAgY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQ3XV0gPSBwcmV2VHlwZSQyID09PSBuZXh0VHlwZSQxID8gcHJldlR5cGUkMiA6IGVtYmVkRGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaSQxMiA9IG5pUnVuRW5kO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gPT09IDMuMy42IFJlc29sdmluZyBJbXBsaWNpdCBMZXZlbHMgPT09XG5cbiAgICAgICAgZm9yICh2YXIgaSQxNyA9IHBhcmFncmFwaC5zdGFydDsgaSQxNyA8PSBwYXJhZ3JhcGguZW5kOyBpJDE3KyspIHtcbiAgICAgICAgICB2YXIgbGV2ZWwkMyA9IGVtYmVkTGV2ZWxzW2kkMTddO1xuICAgICAgICAgIHZhciB0eXBlJDEgPSBjaGFyVHlwZXNbaSQxN107XG4gICAgICAgICAgLy8gSTIuIEZvciBhbGwgY2hhcmFjdGVycyB3aXRoIGFuIG9kZCAocmlnaHQtdG8tbGVmdCkgZW1iZWRkaW5nIGxldmVsLCB0aG9zZSBvZiB0eXBlIEwsIEVOIG9yIEFOIGdvIHVwIG9uZSBsZXZlbC5cbiAgICAgICAgICBpZiAobGV2ZWwkMyAmIDEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlJDEgJiAoVFlQRV9MIHwgVFlQRV9FTiB8IFRZUEVfQU4pKSB7XG4gICAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSTEuIEZvciBhbGwgY2hhcmFjdGVycyB3aXRoIGFuIGV2ZW4gKGxlZnQtdG8tcmlnaHQpIGVtYmVkZGluZyBsZXZlbCwgdGhvc2Ugb2YgdHlwZSBSIGdvIHVwIG9uZSBsZXZlbFxuICAgICAgICAgIC8vIGFuZCB0aG9zZSBvZiB0eXBlIEFOIG9yIEVOIGdvIHVwIHR3byBsZXZlbHMuXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZSQxICYgVFlQRV9SKSB7XG4gICAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUkMSAmIChUWVBFX0FOIHwgVFlQRV9FTikpIHtcbiAgICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQxN10gKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA1LjI6IFJlc29sdmUgYW55IExSRSwgUkxFLCBMUk8sIFJMTywgUERGLCBvciBCTiB0byB0aGUgbGV2ZWwgb2YgdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIgaWYgdGhlcmUgaXMgb25lLFxuICAgICAgICAgIC8vIGFuZCBvdGhlcndpc2UgdG8gdGhlIGJhc2UgbGV2ZWwuXG4gICAgICAgICAgaWYgKHR5cGUkMSAmIEJOX0xJS0VfVFlQRVMpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddID0gaSQxNyA9PT0gMCA/IHBhcmFncmFwaC5sZXZlbCA6IGVtYmVkTGV2ZWxzW2kkMTcgLSAxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAzLjQgTDEuMS00OiBSZXNldCB0aGUgZW1iZWRkaW5nIGxldmVsIG9mIHNlZ21lbnQvcGFyYWdyYXBoIHNlcGFyYXRvcnMsIGFuZCBhbnkgc2VxdWVuY2Ugb2Ygd2hpdGVzcGFjZSBvclxuICAgICAgICAgIC8vIGlzb2xhdGUgZm9ybWF0dGluZyBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGVtIG9yIHRoZSBlbmQgb2YgdGhlIHBhcmFncmFwaCwgdG8gdGhlIHBhcmFncmFwaCBsZXZlbC5cbiAgICAgICAgICAvLyBOT1RFOiB0aGlzIHdpbGwgYWxzbyBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gZWFjaCBpbmRpdmlkdWFsIGxpbmUgZW5kaW5nIGFmdGVyIGxpbmUgd3JhcHBpbmcgb2NjdXJzLlxuICAgICAgICAgIGlmIChpJDE3ID09PSBwYXJhZ3JhcGguZW5kIHx8IGdldEJpZGlDaGFyVHlwZShzdHJpbmdbaSQxN10pICYgKFRZUEVfUyB8IFRZUEVfQikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGokMSA9IGkkMTc7IGokMSA+PSAwICYmIChnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW2okMV0pICYgVFJBSUxJTkdfVFlQRVMpOyBqJDEtLSkge1xuICAgICAgICAgICAgICBlbWJlZExldmVsc1tqJDFdID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBET05FISBUaGUgcmVzb2x2ZWQgbGV2ZWxzIGNhbiB0aGVuIGJlIHVzZWQsIGFmdGVyIGxpbmUgd3JhcHBpbmcsIHRvIGZsaXAgcnVucyBvZiBjaGFyYWN0ZXJzXG4gICAgICAvLyBhY2NvcmRpbmcgdG8gc2VjdGlvbiAzLjQgUmVvcmRlcmluZyBSZXNvbHZlZCBMZXZlbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxldmVsczogZW1iZWRMZXZlbHMsXG4gICAgICAgIHBhcmFncmFwaHM6IHBhcmFncmFwaHNcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0ZXJtaW5lQXV0b0VtYmVkTGV2ZWwgKHN0YXJ0LCBpc0ZTSSkge1xuICAgICAgICAvLyAzLjMuMSBQMiAtIFAzXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjaGFyVHlwZSA9IGNoYXJUeXBlc1tpXTtcbiAgICAgICAgICBpZiAoY2hhclR5cGUgJiAoVFlQRV9SIHwgVFlQRV9BTCkpIHtcbiAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoY2hhclR5cGUgJiAoVFlQRV9CIHwgVFlQRV9MKSkgfHwgKGlzRlNJICYmIGNoYXJUeXBlID09PSBUWVBFX1BESSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyVHlwZSAmIElTT0xBVEVfSU5JVF9UWVBFUykge1xuICAgICAgICAgICAgdmFyIHBkaSA9IGluZGV4T2ZNYXRjaGluZ1BESShpKTtcbiAgICAgICAgICAgIGkgPSBwZGkgPT09IC0xID8gc3RyaW5nLmxlbmd0aCA6IHBkaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW5kZXhPZk1hdGNoaW5nUERJIChpc29sYXRlU3RhcnQpIHtcbiAgICAgICAgLy8gMy4xLjIgQkQ5XG4gICAgICAgIHZhciBpc29sYXRpb25MZXZlbCA9IDE7XG4gICAgICAgIGZvciAodmFyIGkgPSBpc29sYXRlU3RhcnQgKyAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoYXJUeXBlID0gY2hhclR5cGVzW2ldO1xuICAgICAgICAgIGlmIChjaGFyVHlwZSAmIFRZUEVfQikge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXJUeXBlICYgVFlQRV9QREkpIHtcbiAgICAgICAgICAgIGlmICgtLWlzb2xhdGlvbkxldmVsID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyVHlwZSAmIElTT0xBVEVfSU5JVF9UWVBFUykge1xuICAgICAgICAgICAgaXNvbGF0aW9uTGV2ZWwrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmlkaSBtaXJyb3JlZCBjaGFycyBkYXRhLCBhdXRvIGdlbmVyYXRlZFxuICAgIHZhciBkYXRhID0gXCIxND4xLGo+Mix0PjIsdT4yLDFhPmcsMnYzPjEsMT4xLDFnZT4xLDF3ZD4xLGI+MSwxaj4xLGY+MSxhaT4zLC0yPjMsKzEsOD4xazAsLTFqcT4xeTcsLTF5Nj4xaGYsLTFoZT4xaDYsLTFoNT4xaGEsLTFoOD4xcWksLTFwdT4xLDY+M3UsLTNzPjcsNj4xLDE+MSxmPjEsMT4xLCsyLDM+MSwxPjEsKzEzLDQ+MSwxPjEsNj4xZW8sLTFlZT4xLDM+MW1nLC0xbWU+MW1rLC0xbWo+MW1pLC0xbWc+MW1pLC0xbWQ+MSwxPjEsKzIsMT4xMGssLTEwMz4xLDE+MSw0PjEsNT4xLDE+MSwrMTAsMz4xLDE+OCwtNz44LCsxLC02PjcsKzEsYT4xLDE+MSx1PjEsdTY+MSwxPjEsKzUsMjY+MSwxPjEsMj4xLDI+Miw4PjEsNz4xLDQ+MSwxPjEsKzUsYjg+MSwxPjEsKzMsMT4zLC0yPjEsMj4xLDE+MSwrMixjPjEsMz4xLDE+MSwrMixoPjEsMz4xLGE+MSwxPjEsMj4xLDM+MSwxPjEsZD4xLGY+MSwzPjEsMWE+MSwxPjEsNj4xLDc+MSwxMz4xLGs+MSwxPjEsKzE5LDQ+MSwxPjEsKzIsMj4xLDE+MSwrMTgsbT4xLGE+MSwxPjEsbGs+MSwxPjEsND4xLDI+MSxmPjEsMz4xLDE+MSwrMyxkYj4xLDE+MSwrMywzPjEsMT4xLCsyLDE0cW0+MSwxPjEsKzEsNj4xLDRqPjEsaj4yLHQ+Mix1PjIsMj4xLCsxXCI7XG5cbiAgICB2YXIgbWlycm9yTWFwO1xuXG4gICAgZnVuY3Rpb24gcGFyc2UgKCkge1xuICAgICAgaWYgKCFtaXJyb3JNYXApIHtcbiAgICAgICAgLy9jb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIHZhciByZWYgPSBwYXJzZUNoYXJhY3Rlck1hcChkYXRhLCB0cnVlKTtcbiAgICAgICAgdmFyIG1hcCA9IHJlZi5tYXA7XG4gICAgICAgIHZhciByZXZlcnNlTWFwID0gcmVmLnJldmVyc2VNYXA7XG4gICAgICAgIC8vIENvbWJpbmUgYm90aCBtYXBzIGludG8gb25lXG4gICAgICAgIHJldmVyc2VNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtaXJyb3JNYXAgPSBtYXA7XG4gICAgICAgIC8vY29uc29sZS5sb2coYG1pcnJvcmVkIGNoYXJzIHBhcnNlZCBpbiAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnR9bXNgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1pcnJvcmVkQ2hhcmFjdGVyIChjaGFyKSB7XG4gICAgICBwYXJzZSgpO1xuICAgICAgcmV0dXJuIG1pcnJvck1hcC5nZXQoY2hhcikgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc3RyaW5nIGFuZCBpdHMgcmVzb2x2ZWQgZW1iZWRkaW5nIGxldmVscywgYnVpbGQgYSBtYXAgb2YgaW5kaWNlcyB0byByZXBsYWNlbWVudCBjaGFyc1xuICAgICAqIGZvciBhbnkgY2hhcmFjdGVycyBpbiByaWdodC10by1sZWZ0IHNlZ21lbnRzIHRoYXQgaGF2ZSBkZWZpbmVkIG1pcnJvcmVkIGNoYXJhY3RlcnMuXG4gICAgICogQHBhcmFtIHN0cmluZ1xuICAgICAqIEBwYXJhbSBlbWJlZGRpbmdMZXZlbHNcbiAgICAgKiBAcGFyYW0gW3N0YXJ0XVxuICAgICAqIEBwYXJhbSBbZW5kXVxuICAgICAqIEByZXR1cm4ge01hcDxudW1iZXIsIHN0cmluZz59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWlycm9yZWRDaGFyYWN0ZXJzTWFwKHN0cmluZywgZW1iZWRkaW5nTGV2ZWxzLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQgPT0gbnVsbCA/IDAgOiArc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4oc3RyTGVuIC0gMSwgZW5kID09IG51bGwgPyBzdHJMZW4gLSAxIDogK2VuZCk7XG5cbiAgICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKGVtYmVkZGluZ0xldmVsc1tpXSAmIDEpIHsgLy9vbmx5IG9kZCAocnRsKSBsZXZlbHNcbiAgICAgICAgICB2YXIgbWlycm9yID0gZ2V0TWlycm9yZWRDaGFyYWN0ZXIoc3RyaW5nW2ldKTtcbiAgICAgICAgICBpZiAobWlycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGksIG1pcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzdGFydCBhbmQgZW5kIGRlbm90aW5nIGEgc2luZ2xlIGxpbmUgd2l0aGluIGEgc3RyaW5nLCBhbmQgYSBzZXQgb2YgcHJlY2FsY3VsYXRlZFxuICAgICAqIGJpZGkgZW1iZWRkaW5nIGxldmVscywgcHJvZHVjZSBhIGxpc3Qgb2Ygc2VnbWVudHMgd2hvc2Ugb3JkZXJpbmcgc2hvdWxkIGJlIGZsaXBwZWQsIGluIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSB0aGUgZnVsbCBpbnB1dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0dldEVtYmVkZGluZ0xldmVsc1Jlc3VsdH0gZW1iZWRkaW5nTGV2ZWxzUmVzdWx0IC0gdGhlIHJlc3VsdCBvYmplY3QgZnJvbSBnZXRFbWJlZGRpbmdMZXZlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XSAtIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN1YnNldCBvZiB0aGUgZnVsbCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gLSBsYXN0IGNoYXJhY3RlciBpbiBhIHN1YnNldCBvZiB0aGUgZnVsbCBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXVtdfSAtIHRoZSBsaXN0IG9mIHN0YXJ0L2VuZCBzZWdtZW50cyB0aGF0IHNob3VsZCBiZSBmbGlwcGVkLCBpbiBvcmRlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSZW9yZGVyU2VnbWVudHMoc3RyaW5nLCBlbWJlZGRpbmdMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCA9PSBudWxsID8gMCA6ICtzdGFydCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihzdHJMZW4gLSAxLCBlbmQgPT0gbnVsbCA/IHN0ckxlbiAtIDEgOiArZW5kKTtcblxuICAgICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgICBlbWJlZGRpbmdMZXZlbHNSZXN1bHQucGFyYWdyYXBocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhZ3JhcGgpIHtcbiAgICAgICAgdmFyIGxpbmVTdGFydCA9IE1hdGgubWF4KHN0YXJ0LCBwYXJhZ3JhcGguc3RhcnQpO1xuICAgICAgICB2YXIgbGluZUVuZCA9IE1hdGgubWluKGVuZCwgcGFyYWdyYXBoLmVuZCk7XG4gICAgICAgIGlmIChsaW5lU3RhcnQgPCBsaW5lRW5kKSB7XG4gICAgICAgICAgLy8gTG9jYWwgc2xpY2UgZm9yIG11dGF0aW9uXG4gICAgICAgICAgdmFyIGxpbmVMZXZlbHMgPSBlbWJlZGRpbmdMZXZlbHNSZXN1bHQubGV2ZWxzLnNsaWNlKGxpbmVTdGFydCwgbGluZUVuZCArIDEpO1xuXG4gICAgICAgICAgLy8gMy40IEwxLjQ6IFJlc2V0IGFueSBzZXF1ZW5jZSBvZiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgYW5kL29yIGlzb2xhdGUgZm9ybWF0dGluZyBjaGFyYWN0ZXJzIGF0IHRoZVxuICAgICAgICAgIC8vIGVuZCBvZiB0aGUgbGluZSB0byB0aGUgcGFyYWdyYXBoIGxldmVsLlxuICAgICAgICAgIGZvciAodmFyIGkgPSBsaW5lRW5kOyBpID49IGxpbmVTdGFydCAmJiAoZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tpXSkgJiBUUkFJTElOR19UWVBFUyk7IGktLSkge1xuICAgICAgICAgICAgbGluZUxldmVsc1tpXSA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBMMi4gRnJvbSB0aGUgaGlnaGVzdCBsZXZlbCBmb3VuZCBpbiB0aGUgdGV4dCB0byB0aGUgbG93ZXN0IG9kZCBsZXZlbCBvbiBlYWNoIGxpbmUsIGluY2x1ZGluZyBpbnRlcm1lZGlhdGUgbGV2ZWxzXG4gICAgICAgICAgLy8gbm90IGFjdHVhbGx5IHByZXNlbnQgaW4gdGhlIHRleHQsIHJldmVyc2UgYW55IGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBhdCB0aGF0IGxldmVsIG9yIGhpZ2hlci5cbiAgICAgICAgICB2YXIgbWF4TGV2ZWwgPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgdmFyIG1pbk9kZExldmVsID0gSW5maW5pdHk7XG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGluZUxldmVscy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBsaW5lTGV2ZWxzW2kkMV07XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBtYXhMZXZlbCkgeyBtYXhMZXZlbCA9IGxldmVsOyB9XG4gICAgICAgICAgICBpZiAobGV2ZWwgPCBtaW5PZGRMZXZlbCkgeyBtaW5PZGRMZXZlbCA9IGxldmVsIHwgMTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBsdmwgPSBtYXhMZXZlbDsgbHZsID49IG1pbk9kZExldmVsOyBsdmwtLSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgbGluZUxldmVscy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgIGlmIChsaW5lTGV2ZWxzW2kkMl0gPj0gbHZsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ1N0YXJ0ID0gaSQyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpJDIgKyAxIDwgbGluZUxldmVscy5sZW5ndGggJiYgbGluZUxldmVsc1tpJDIgKyAxXSA+PSBsdmwpIHtcbiAgICAgICAgICAgICAgICAgIGkkMisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSQyID4gc2VnU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goW3NlZ1N0YXJ0ICsgbGluZVN0YXJ0LCBpJDIgKyBsaW5lU3RhcnRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlZ21lbnRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7R2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0fSBlbWJlZExldmVsc1Jlc3VsdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgbmV3IHN0cmluZyB3aXRoIGJpZGkgc2VnbWVudHMgcmVvcmRlcmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UmVvcmRlcmVkU3RyaW5nKHN0cmluZywgZW1iZWRMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRpY2VzID0gZ2V0UmVvcmRlcmVkSW5kaWNlcyhzdHJpbmcsIGVtYmVkTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKTtcbiAgICAgIHZhciBjaGFycyA9IFtdLmNvbmNhdCggc3RyaW5nICk7XG4gICAgICBpbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYXJJbmRleCwgaSkge1xuICAgICAgICBjaGFyc1tpXSA9IChcbiAgICAgICAgICAoZW1iZWRMZXZlbHNSZXN1bHQubGV2ZWxzW2NoYXJJbmRleF0gJiAxKSA/IGdldE1pcnJvcmVkQ2hhcmFjdGVyKHN0cmluZ1tjaGFySW5kZXhdKSA6IG51bGxcbiAgICAgICAgKSB8fCBzdHJpbmdbY2hhckluZGV4XTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7R2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0fSBlbWJlZExldmVsc1Jlc3VsdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAgICogQHJldHVybiB7bnVtYmVyW119IGFuIGFycmF5IHdpdGggY2hhcmFjdGVyIGluZGljZXMgaW4gdGhlaXIgbmV3IGJpZGkgb3JkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSZW9yZGVyZWRJbmRpY2VzKHN0cmluZywgZW1iZWRMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IGdldFJlb3JkZXJTZWdtZW50cyhzdHJpbmcsIGVtYmVkTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKTtcbiAgICAgIC8vIEZpbGwgYW4gYXJyYXkgd2l0aCBpbmRpY2VzXG4gICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5kaWNlc1tpXSA9IGk7XG4gICAgICB9XG4gICAgICAvLyBSZXZlcnNlIGVhY2ggc2VnbWVudCBpbiBvcmRlclxuICAgICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGVuZCA9IHJlZlsxXTtcblxuICAgICAgICB2YXIgc2xpY2UgPSBpbmRpY2VzLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNsaWNlLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGluZGljZXNbZW5kIC0gaV0gPSBzbGljZVtpXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW5kaWNlc1xuICAgIH1cblxuICAgIGV4cG9ydHMuY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQgPSBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldDtcbiAgICBleHBvcnRzLmdldEJpZGlDaGFyVHlwZSA9IGdldEJpZGlDaGFyVHlwZTtcbiAgICBleHBvcnRzLmdldEJpZGlDaGFyVHlwZU5hbWUgPSBnZXRCaWRpQ2hhclR5cGVOYW1lO1xuICAgIGV4cG9ydHMuZ2V0Q2Fub25pY2FsQnJhY2tldCA9IGdldENhbm9uaWNhbEJyYWNrZXQ7XG4gICAgZXhwb3J0cy5nZXRFbWJlZGRpbmdMZXZlbHMgPSBnZXRFbWJlZGRpbmdMZXZlbHM7XG4gICAgZXhwb3J0cy5nZXRNaXJyb3JlZENoYXJhY3RlciA9IGdldE1pcnJvcmVkQ2hhcmFjdGVyO1xuICAgIGV4cG9ydHMuZ2V0TWlycm9yZWRDaGFyYWN0ZXJzTWFwID0gZ2V0TWlycm9yZWRDaGFyYWN0ZXJzTWFwO1xuICAgIGV4cG9ydHMuZ2V0UmVvcmRlclNlZ21lbnRzID0gZ2V0UmVvcmRlclNlZ21lbnRzO1xuICAgIGV4cG9ydHMuZ2V0UmVvcmRlcmVkSW5kaWNlcyA9IGdldFJlb3JkZXJlZEluZGljZXM7XG4gICAgZXhwb3J0cy5nZXRSZW9yZGVyZWRTdHJpbmcgPSBnZXRSZW9yZGVyZWRTdHJpbmc7XG4gICAgZXhwb3J0cy5vcGVuaW5nVG9DbG9zaW5nQnJhY2tldCA9IG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuICAgIHJldHVybiBleHBvcnRzO1xuXG4gIH0oe30pKTtcbiAgcmV0dXJuIGJpZGl9XG5cbiAgcmV0dXJuIGJpZGlGYWN0b3J5O1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bidi-js/dist/bidi.js\n");

/***/ })

};
;